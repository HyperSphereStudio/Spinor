using runtime.core;
/**This Class Was Machine Generated. Do not Modify*/
public enum MemoryType : byte{
    None,
    //CONSTANTS//
    Signed,
    Unsigned,
    Floating,
    Pointer,
    Block,
    Array,
    String,
    //END CONSTANTS//
    
    Type,
    Module,
    Function,
    
    //VARIADICS//
    Variable,
    //END VARIADICS//
}

public enum OperationType : byte{
    None,
    Push,
    Pop,
    PushVariadic,
    PopVariadic,
    Load,
    Invoke
}

public readonly struct JOp {
    public static readonly JOp[] OpCodeTable = new JOp[22];
    public readonly byte OpCode;
    public readonly sbyte StackChange;
    public readonly byte OperandsSize;
    public readonly MemoryType Memory;
    public readonly OperationType Behaviour;

    public bool IsPush => Behaviour == OperationType.Push;
    public bool IsPop => Behaviour == OperationType.Pop;

    private unsafe JOp(byte opCode, sbyte stackChange, byte operandsSize, MemoryType memory, OperationType behaviour) {
        OpCode = opCode;
        StackChange = stackChange;
        OperandsSize = operandsSize;
        Memory = memory;
        Behaviour = behaviour;
        OpCodeTable[OpCode] = this;
    }

    public byte GetRuntimeOpCode() {
        if (Behaviour == OperationType.Push) {
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }

        throw new JuliaException("Unable To Determine OpCode!");
    }

	public const byte PushInt8Op = 0;
	public const byte PushInt16Op = 1;
	public const byte PushInt32Op = 2;
	public const byte PushInt64Op = 3;
	public const byte PushUInt8Op = 4;
	public const byte PushUInt16Op = 5;
	public const byte PushUInt32Op = 6;
	public const byte PushUInt64Op = 7;
	public const byte PushFloat32Op = 8;
	public const byte PushFloat64Op = 9;
	public const byte PushArrayOp = 10;
	public const byte PushStringOp = 11;
	public const byte Pop8Op = 12;
	public const byte Pop16Op = 13;
	public const byte Pop32Op = 14;
	public const byte Pop64Op = 15;
	public const byte PopArrayOp = 16;
	public const byte PopStringOp = 15;
	public const byte LoadTypeOp = 17;
	public const byte LoadModuleOp = 18;
	public const byte LoadMethodOp = 19;
	public const byte InvokeFunctionOp = 20;


	public static readonly JOp PushInt8 = new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt16 = new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt32 = new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt64 = new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushUInt8 = new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt16 = new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt32 = new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt64 = new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushFloat32 = new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push);
	public static readonly JOp PushFloat64 = new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push);
	public static readonly JOp PushArray = new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push);
	public static readonly JOp PushString = new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push);
	public static readonly JOp Pop8 = new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop16 = new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop32 = new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop64 = new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp PopArray = new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop);
	public static readonly JOp PopString = new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp LoadType = new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load);
	public static readonly JOp LoadModule = new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load);
	public static readonly JOp LoadMethod = new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load);
	public static readonly JOp InvokeFunction = new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke);


	public static readonly string[] OpCodeNames = {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"};
	public string Name => OpCodeNames[OpCode];
}

using runtime.core;
runtime.core
runtime
core
public enum MemoryType : byte{
    None,
    //CONSTANTS//
    Signed,
    Unsigned,
    Floating,
    Pointer,
    Block,
    Array,
    String,
    //END CONSTANTS//
    
    Type,
    Module,
    Function,
    
    //VARIADICS//
    Variable,
    //END VARIADICS//
}
: byte
byte
byte
None
Signed
Unsigned
Floating
Pointer
Block
Array
String
Type
Module
Function
Variable
public enum OperationType : byte{
    None,
    Push,
    Pop,
    PushVariadic,
    PopVariadic,
    Load,
    Invoke
}
: byte
byte
byte
None
Push
Pop
PushVariadic
PopVariadic
Load
Invoke
public readonly struct JOp {
    public static readonly JOp[] OpCodeTable = new JOp[22];
    public readonly byte OpCode;
    public readonly sbyte StackChange;
    public readonly byte OperandsSize;
    public readonly MemoryType Memory;
    public readonly OperationType Behaviour;

    public bool IsPush => Behaviour == OperationType.Push;
    public bool IsPop => Behaviour == OperationType.Pop;

    private unsafe JOp(byte opCode, sbyte stackChange, byte operandsSize, MemoryType memory, OperationType behaviour) {
        OpCode = opCode;
        StackChange = stackChange;
        OperandsSize = operandsSize;
        Memory = memory;
        Behaviour = behaviour;
        OpCodeTable[OpCode] = this;
    }

    public byte GetRuntimeOpCode() {
        if (Behaviour == OperationType.Push) {
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }

        throw new JuliaException("Unable To Determine OpCode!");
    }

	public const byte PushInt8Op = 0;
	public const byte PushInt16Op = 1;
	public const byte PushInt32Op = 2;
	public const byte PushInt64Op = 3;
	public const byte PushUInt8Op = 4;
	public const byte PushUInt16Op = 5;
	public const byte PushUInt32Op = 6;
	public const byte PushUInt64Op = 7;
	public const byte PushFloat32Op = 8;
	public const byte PushFloat64Op = 9;
	public const byte PushArrayOp = 10;
	public const byte PushStringOp = 11;
	public const byte Pop8Op = 12;
	public const byte Pop16Op = 13;
	public const byte Pop32Op = 14;
	public const byte Pop64Op = 15;
	public const byte PopArrayOp = 16;
	public const byte PopStringOp = 15;
	public const byte LoadTypeOp = 17;
	public const byte LoadModuleOp = 18;
	public const byte LoadMethodOp = 19;
	public const byte InvokeFunctionOp = 20;


	public static readonly JOp PushInt8 = new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt16 = new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt32 = new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt64 = new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushUInt8 = new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt16 = new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt32 = new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt64 = new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushFloat32 = new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push);
	public static readonly JOp PushFloat64 = new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push);
	public static readonly JOp PushArray = new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push);
	public static readonly JOp PushString = new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push);
	public static readonly JOp Pop8 = new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop16 = new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop32 = new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop64 = new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp PopArray = new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop);
	public static readonly JOp PopString = new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp LoadType = new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load);
	public static readonly JOp LoadModule = new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load);
	public static readonly JOp LoadMethod = new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load);
	public static readonly JOp InvokeFunction = new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke);


	public static readonly string[] OpCodeNames = {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"};
	public string Name => OpCodeNames[OpCode];
}
public static readonly JOp[] OpCodeTable = new JOp[22];
JOp[] OpCodeTable = new JOp[22]
JOp[]
JOp
[]

OpCodeTable = new JOp[22]
= new JOp[22]
new JOp[22]
JOp[22]
JOp
[22]
22
public readonly byte OpCode;
byte OpCode
byte
OpCode
public readonly sbyte StackChange;
sbyte StackChange
sbyte
StackChange
public readonly byte OperandsSize;
byte OperandsSize
byte
OperandsSize
public readonly MemoryType Memory;
MemoryType Memory
MemoryType
Memory
public readonly OperationType Behaviour;
OperationType Behaviour
OperationType
Behaviour
public bool IsPush => Behaviour == OperationType.Push;
bool
=> Behaviour == OperationType.Push
Behaviour == OperationType.Push
Behaviour
OperationType.Push
OperationType
Push
public bool IsPop => Behaviour == OperationType.Pop;
bool
=> Behaviour == OperationType.Pop
Behaviour == OperationType.Pop
Behaviour
OperationType.Pop
OperationType
Pop
private unsafe JOp(byte opCode, sbyte stackChange, byte operandsSize, MemoryType memory, OperationType behaviour) {
        OpCode = opCode;
        StackChange = stackChange;
        OperandsSize = operandsSize;
        Memory = memory;
        Behaviour = behaviour;
        OpCodeTable[OpCode] = this;
    }
(byte opCode, sbyte stackChange, byte operandsSize, MemoryType memory, OperationType behaviour)
byte opCode
byte
sbyte stackChange
sbyte
byte operandsSize
byte
MemoryType memory
MemoryType
OperationType behaviour
OperationType
{
        OpCode = opCode;
        StackChange = stackChange;
        OperandsSize = operandsSize;
        Memory = memory;
        Behaviour = behaviour;
        OpCodeTable[OpCode] = this;
    }
OpCode = opCode;
OpCode = opCode
OpCode
opCode
StackChange = stackChange;
StackChange = stackChange
StackChange
stackChange
OperandsSize = operandsSize;
OperandsSize = operandsSize
OperandsSize
operandsSize
Memory = memory;
Memory = memory
Memory
memory
Behaviour = behaviour;
Behaviour = behaviour
Behaviour
behaviour
OpCodeTable[OpCode] = this;
OpCodeTable[OpCode] = this
OpCodeTable[OpCode]
OpCodeTable
[OpCode]
OpCode
OpCode
this
public byte GetRuntimeOpCode() {
        if (Behaviour == OperationType.Push) {
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }

        throw new JuliaException("Unable To Determine OpCode!");
    }
byte
()
{
        if (Behaviour == OperationType.Push) {
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }

        throw new JuliaException("Unable To Determine OpCode!");
    }
if (Behaviour == OperationType.Push) {
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }
Behaviour == OperationType.Push
Behaviour
OperationType.Push
OperationType
Push
{
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }
if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
Memory == MemoryType.Signed
Memory
MemoryType.Signed
MemoryType
Signed
{
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }
switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
OperandsSize
case 1: return PushInt8.OpCode;
case 1:
1
return PushInt8.OpCode;
PushInt8.OpCode
PushInt8
OpCode
case 2: return PushInt16.OpCode;
case 2:
2
return PushInt16.OpCode;
PushInt16.OpCode
PushInt16
OpCode
case 4: return PushInt32.OpCode;
case 4:
4
return PushInt32.OpCode;
PushInt32.OpCode
PushInt32
OpCode
case 8: return PushInt64.OpCode;
case 8:
8
return PushInt64.OpCode;
PushInt64.OpCode
PushInt64
OpCode
else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
Memory == MemoryType.Unsigned
Memory
MemoryType.Unsigned
MemoryType
Unsigned
{
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }
switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }
OperandsSize
case 1: return PushUInt8.OpCode;
case 1:
1
return PushUInt8.OpCode;
PushUInt8.OpCode
PushUInt8
OpCode
case 2: return PushUInt16.OpCode;
case 2:
2
return PushUInt16.OpCode;
PushUInt16.OpCode
PushUInt16
OpCode
case 4: return PushUInt32.OpCode;
case 4:
4
return PushUInt32.OpCode;
PushUInt32.OpCode
PushUInt32
OpCode
case 8: return PushUInt64.OpCode;
case 8:
8
return PushUInt64.OpCode;
PushUInt64.OpCode
PushUInt64
OpCode
else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
Memory == MemoryType.Floating
Memory
MemoryType.Floating
MemoryType
Floating
{
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }
if (OperandsSize == 4) return PushFloat32.OpCode;
OperandsSize == 4
OperandsSize
4
return PushFloat32.OpCode;
PushFloat32.OpCode
PushFloat32
OpCode
if (OperandsSize == 8) return PushFloat64.OpCode;
OperandsSize == 8
OperandsSize
8
return PushFloat64.OpCode;
PushFloat64.OpCode
PushFloat64
OpCode
else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
Memory == MemoryType.String
Memory
MemoryType.String
MemoryType
String
return PushString.OpCode;
PushString.OpCode
PushString
OpCode
else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
if (Memory == MemoryType.Array)
                return PushArray.OpCode;
Memory == MemoryType.Array
Memory
MemoryType.Array
MemoryType
Array
return PushArray.OpCode;
PushArray.OpCode
PushArray
OpCode
else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }
if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }
Behaviour == OperationType.Pop
Behaviour
OperationType.Pop
OperationType
Pop
{
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }
if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
Memory == MemoryType.Array
Memory
MemoryType.Array
MemoryType
Array
{
                return PopArray.OpCode;
            }
return PopArray.OpCode;
PopArray.OpCode
PopArray
OpCode
switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
OperandsSize
case 1: return Pop8.OpCode;
case 1:
1
return Pop8.OpCode;
Pop8.OpCode
Pop8
OpCode
case 2: return Pop16.OpCode;
case 2:
2
return Pop16.OpCode;
Pop16.OpCode
Pop16
OpCode
case 4: return Pop32.OpCode;
case 4:
4
return Pop32.OpCode;
Pop32.OpCode
Pop32
OpCode
case 8: return Pop64.OpCode;
case 8:
8
return Pop64.OpCode;
Pop64.OpCode
Pop64
OpCode
else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }
if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }
Behaviour == OperationType.Load
Behaviour
OperationType.Load
OperationType
Load
{
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }
switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
Memory
case MemoryType.Type: return LoadType.OpCode;
case MemoryType.Type:
MemoryType.Type
MemoryType
Type
return LoadType.OpCode;
LoadType.OpCode
LoadType
OpCode
case MemoryType.Module: return LoadModule.OpCode;
case MemoryType.Module:
MemoryType.Module
MemoryType
Module
return LoadModule.OpCode;
LoadModule.OpCode
LoadModule
OpCode
case MemoryType.Function: return LoadMethod.OpCode;
case MemoryType.Function:
MemoryType.Function
MemoryType
Function
return LoadMethod.OpCode;
LoadMethod.OpCode
LoadMethod
OpCode
else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }
if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }
Behaviour == OperationType.Invoke
Behaviour
OperationType.Invoke
OperationType
Invoke
{
            return InvokeFunction.OpCode;
        }
return InvokeFunction.OpCode;
InvokeFunction.OpCode
InvokeFunction
OpCode
throw new JuliaException("Unable To Determine OpCode!");
new JuliaException("Unable To Determine OpCode!")
JuliaException
("Unable To Determine OpCode!")
"Unable To Determine OpCode!"
"Unable To Determine OpCode!"
public const byte PushInt8Op = 0;
byte PushInt8Op = 0
byte
PushInt8Op = 0
= 0
0
public const byte PushInt16Op = 1;
byte PushInt16Op = 1
byte
PushInt16Op = 1
= 1
1
public const byte PushInt32Op = 2;
byte PushInt32Op = 2
byte
PushInt32Op = 2
= 2
2
public const byte PushInt64Op = 3;
byte PushInt64Op = 3
byte
PushInt64Op = 3
= 3
3
public const byte PushUInt8Op = 4;
byte PushUInt8Op = 4
byte
PushUInt8Op = 4
= 4
4
public const byte PushUInt16Op = 5;
byte PushUInt16Op = 5
byte
PushUInt16Op = 5
= 5
5
public const byte PushUInt32Op = 6;
byte PushUInt32Op = 6
byte
PushUInt32Op = 6
= 6
6
public const byte PushUInt64Op = 7;
byte PushUInt64Op = 7
byte
PushUInt64Op = 7
= 7
7
public const byte PushFloat32Op = 8;
byte PushFloat32Op = 8
byte
PushFloat32Op = 8
= 8
8
public const byte PushFloat64Op = 9;
byte PushFloat64Op = 9
byte
PushFloat64Op = 9
= 9
9
public const byte PushArrayOp = 10;
byte PushArrayOp = 10
byte
PushArrayOp = 10
= 10
10
public const byte PushStringOp = 11;
byte PushStringOp = 11
byte
PushStringOp = 11
= 11
11
public const byte Pop8Op = 12;
byte Pop8Op = 12
byte
Pop8Op = 12
= 12
12
public const byte Pop16Op = 13;
byte Pop16Op = 13
byte
Pop16Op = 13
= 13
13
public const byte Pop32Op = 14;
byte Pop32Op = 14
byte
Pop32Op = 14
= 14
14
public const byte Pop64Op = 15;
byte Pop64Op = 15
byte
Pop64Op = 15
= 15
15
public const byte PopArrayOp = 16;
byte PopArrayOp = 16
byte
PopArrayOp = 16
= 16
16
public const byte PopStringOp = 15;
byte PopStringOp = 15
byte
PopStringOp = 15
= 15
15
public const byte LoadTypeOp = 17;
byte LoadTypeOp = 17
byte
LoadTypeOp = 17
= 17
17
public const byte LoadModuleOp = 18;
byte LoadModuleOp = 18
byte
LoadModuleOp = 18
= 18
18
public const byte LoadMethodOp = 19;
byte LoadMethodOp = 19
byte
LoadMethodOp = 19
= 19
19
public const byte InvokeFunctionOp = 20;
byte InvokeFunctionOp = 20
byte
InvokeFunctionOp = 20
= 20
20
public static readonly JOp PushInt8 = new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push);
JOp PushInt8 = new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push)
JOp
PushInt8 = new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push)
= new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push)
new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push)
(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push)
PushInt8Op
PushInt8Op
1
1
2
2
MemoryType.Signed
MemoryType.Signed
MemoryType
Signed
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp PushInt16 = new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push);
JOp PushInt16 = new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push)
JOp
PushInt16 = new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push)
= new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push)
new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push)
(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push)
PushInt16Op
PushInt16Op
2
2
3
3
MemoryType.Signed
MemoryType.Signed
MemoryType
Signed
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp PushInt32 = new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push);
JOp PushInt32 = new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push)
JOp
PushInt32 = new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push)
= new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push)
new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push)
(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push)
PushInt32Op
PushInt32Op
4
4
5
5
MemoryType.Signed
MemoryType.Signed
MemoryType
Signed
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp PushInt64 = new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push);
JOp PushInt64 = new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push)
JOp
PushInt64 = new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push)
= new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push)
new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push)
(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push)
PushInt64Op
PushInt64Op
8
8
9
9
MemoryType.Signed
MemoryType.Signed
MemoryType
Signed
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp PushUInt8 = new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push);
JOp PushUInt8 = new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push)
JOp
PushUInt8 = new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push)
= new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push)
new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push)
(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push)
PushUInt8Op
PushUInt8Op
1
1
2
2
MemoryType.Unsigned
MemoryType.Unsigned
MemoryType
Unsigned
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp PushUInt16 = new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push);
JOp PushUInt16 = new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push)
JOp
PushUInt16 = new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push)
= new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push)
new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push)
(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push)
PushUInt16Op
PushUInt16Op
2
2
3
3
MemoryType.Unsigned
MemoryType.Unsigned
MemoryType
Unsigned
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp PushUInt32 = new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push);
JOp PushUInt32 = new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push)
JOp
PushUInt32 = new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push)
= new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push)
new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push)
(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push)
PushUInt32Op
PushUInt32Op
4
4
5
5
MemoryType.Unsigned
MemoryType.Unsigned
MemoryType
Unsigned
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp PushUInt64 = new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push);
JOp PushUInt64 = new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push)
JOp
PushUInt64 = new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push)
= new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push)
new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push)
(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push)
PushUInt64Op
PushUInt64Op
8
8
9
9
MemoryType.Unsigned
MemoryType.Unsigned
MemoryType
Unsigned
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp PushFloat32 = new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push);
JOp PushFloat32 = new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push)
JOp
PushFloat32 = new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push)
= new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push)
new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push)
(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push)
PushFloat32Op
PushFloat32Op
4
4
5
5
MemoryType.Floating
MemoryType.Floating
MemoryType
Floating
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp PushFloat64 = new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push);
JOp PushFloat64 = new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push)
JOp
PushFloat64 = new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push)
= new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push)
new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push)
(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push)
PushFloat64Op
PushFloat64Op
8
8
9
9
MemoryType.Floating
MemoryType.Floating
MemoryType
Floating
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp PushArray = new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push);
JOp PushArray = new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push)
JOp
PushArray = new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push)
= new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push)
new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push)
(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push)
PushArrayOp
PushArrayOp
12
12
13
13
MemoryType.Array
MemoryType.Array
MemoryType
Array
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp PushString = new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push);
JOp PushString = new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push)
JOp
PushString = new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push)
= new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push)
new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push)
(PushStringOp, 8, 5, MemoryType.String, OperationType.Push)
PushStringOp
PushStringOp
8
8
5
5
MemoryType.String
MemoryType.String
MemoryType
String
OperationType.Push
OperationType.Push
OperationType
Push
public static readonly JOp Pop8 = new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop);
JOp Pop8 = new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop)
JOp
Pop8 = new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop)
= new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop)
new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop)
(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop)
Pop8Op
Pop8Op
-1
-1
1
2
2
MemoryType.Block
MemoryType.Block
MemoryType
Block
OperationType.Pop
OperationType.Pop
OperationType
Pop
public static readonly JOp Pop16 = new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop);
JOp Pop16 = new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop)
JOp
Pop16 = new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop)
= new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop)
new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop)
(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop)
Pop16Op
Pop16Op
-1
-1
1
2
2
MemoryType.Block
MemoryType.Block
MemoryType
Block
OperationType.Pop
OperationType.Pop
OperationType
Pop
public static readonly JOp Pop32 = new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop);
JOp Pop32 = new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop)
JOp
Pop32 = new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop)
= new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop)
new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop)
(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop)
Pop32Op
Pop32Op
-1
-1
1
2
2
MemoryType.Block
MemoryType.Block
MemoryType
Block
OperationType.Pop
OperationType.Pop
OperationType
Pop
public static readonly JOp Pop64 = new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop);
JOp Pop64 = new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop)
JOp
Pop64 = new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop)
= new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop)
new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop)
(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop)
Pop64Op
Pop64Op
-1
-1
1
2
2
MemoryType.Block
MemoryType.Block
MemoryType
Block
OperationType.Pop
OperationType.Pop
OperationType
Pop
public static readonly JOp PopArray = new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop);
JOp PopArray = new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop)
JOp
PopArray = new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop)
= new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop)
new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop)
(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop)
PopArrayOp
PopArrayOp
-12
-12
12
13
13
MemoryType.Array
MemoryType.Array
MemoryType
Array
OperationType.Pop
OperationType.Pop
OperationType
Pop
public static readonly JOp PopString = new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop);
JOp PopString = new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop)
JOp
PopString = new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop)
= new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop)
new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop)
(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop)
PopStringOp
PopStringOp
-1
-1
1
2
2
MemoryType.Block
MemoryType.Block
MemoryType
Block
OperationType.Pop
OperationType.Pop
OperationType
Pop
public static readonly JOp LoadType = new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load);
JOp LoadType = new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load)
JOp
LoadType = new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load)
= new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load)
new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load)
(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load)
LoadTypeOp
LoadTypeOp
8
8
5
5
MemoryType.Type
MemoryType.Type
MemoryType
Type
OperationType.Load
OperationType.Load
OperationType
Load
public static readonly JOp LoadModule = new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load);
JOp LoadModule = new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load)
JOp
LoadModule = new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load)
= new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load)
new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load)
(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load)
LoadModuleOp
LoadModuleOp
8
8
5
5
MemoryType.Module
MemoryType.Module
MemoryType
Module
OperationType.Load
OperationType.Load
OperationType
Load
public static readonly JOp LoadMethod = new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load);
JOp LoadMethod = new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load)
JOp
LoadMethod = new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load)
= new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load)
new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load)
(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load)
LoadMethodOp
LoadMethodOp
8
8
5
5
MemoryType.Function
MemoryType.Function
MemoryType
Function
OperationType.Load
OperationType.Load
OperationType
Load
public static readonly JOp InvokeFunction = new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke);
JOp InvokeFunction = new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke)
JOp
InvokeFunction = new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke)
= new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke)
new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke)
(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke)
InvokeFunctionOp
InvokeFunctionOp
0
0
9
9
MemoryType.Function
MemoryType.Function
MemoryType
Function
OperationType.Invoke
OperationType.Invoke
OperationType
Invoke
public static readonly string[] OpCodeNames = {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"};
string[] OpCodeNames = {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"}
string[]
string
[]

OpCodeNames = {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"}
= {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"}
{"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"}
"PushInt8"
"PushInt16"
"PushInt32"
"PushInt64"
"PushUInt8"
"PushUInt16"
"PushUInt32"
"PushUInt64"
"PushFloat32"
"PushFloat64"
"PushArray"
"PushString"
"Pop8"
"Pop16"
"Pop32"
"Pop64"
"PopArray"
"PopString"
"LoadType"
"LoadModule"
"LoadMethod"
"InvokeFunction"
public string Name => OpCodeNames[OpCode];
string
=> OpCodeNames[OpCode]
OpCodeNames[OpCode]
OpCodeNames
[OpCode]
OpCode
OpCode
namespace runtime.core.JIL;

public class JILCompiler : Reader.IJILBaseVisitor
{
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        
    }
    
    
}
namespace runtime.core.JIL;

public class JILCompiler : Reader.IJILBaseVisitor
{
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        
    }
    
    
}
runtime.core.JIL
runtime.core
runtime
core
JIL
public class JILCompiler : Reader.IJILBaseVisitor
{
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        
    }
    
    
}
: Reader.IJILBaseVisitor
Reader.IJILBaseVisitor
Reader.IJILBaseVisitor
Reader
IJILBaseVisitor
public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        
    }
void
(IJType loadedType, ref int loadedTypeIndex)
IJType loadedType
IJType
ref int loadedTypeIndex
int
{
        
    }
using System.Collections.Generic;
using System.Linq;
using runtime.core.Runtime;

namespace runtime.core.JIL;

public class JILInterpreter : JRuntimeContext, Reader.IJILBaseVisitor, IJCodeExecutionContext {
    private readonly List<IJExpr> _expressionStack = new();
    private readonly List<IJModule> _moduleStack = new();
    private int _exprStackEnd;
    private int _moduleStackEnd;
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {}


    public JILInterpreter(string[] strings, IJModule[] modules, IJType[] types) : base(strings, modules, types) {}
    
    public IJExpr GetExpr(int i) => _expressionStack[i];
    public IJModule GetModule(int i) => _moduleStack[i];
    public IJField GetNameField(IJExpr e, JNameRef nameRef) => _expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef);
    
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
        nameRef = default;
        return false;
    }
    
    
    IJModule IJCodeExecutionContext.CurrentModule => _moduleStack.First();
    IJExpr IJCodeExecutionContext.CurrentExpr => _expressionStack.First();

    void IJCodeExecutionContext.EnterModule(IJModule m) {
        _moduleStack.Add(m);
        _moduleStackEnd++;
    }

    void IJCodeExecutionContext.ExitModule() => _moduleStack.RemoveAt(_moduleStackEnd--);

    void IJCodeExecutionContext.EnterExpr(IJExpr e) {
        _expressionStack.Add(e);
        _exprStackEnd++;
    }
    
    void IJCodeExecutionContext.ExitExpr() => _expressionStack.RemoveAt(_exprStackEnd--);
}
using System.Collections.Generic;
System.Collections.Generic
System.Collections
System
Collections
Generic
using System.Linq;
System.Linq
System
Linq
using runtime.core.Runtime;
runtime.core.Runtime
runtime.core
runtime
core
Runtime
namespace runtime.core.JIL;

public class JILInterpreter : JRuntimeContext, Reader.IJILBaseVisitor, IJCodeExecutionContext {
    private readonly List<IJExpr> _expressionStack = new();
    private readonly List<IJModule> _moduleStack = new();
    private int _exprStackEnd;
    private int _moduleStackEnd;
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {}


    public JILInterpreter(string[] strings, IJModule[] modules, IJType[] types) : base(strings, modules, types) {}
    
    public IJExpr GetExpr(int i) => _expressionStack[i];
    public IJModule GetModule(int i) => _moduleStack[i];
    public IJField GetNameField(IJExpr e, JNameRef nameRef) => _expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef);
    
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
        nameRef = default;
        return false;
    }
    
    
    IJModule IJCodeExecutionContext.CurrentModule => _moduleStack.First();
    IJExpr IJCodeExecutionContext.CurrentExpr => _expressionStack.First();

    void IJCodeExecutionContext.EnterModule(IJModule m) {
        _moduleStack.Add(m);
        _moduleStackEnd++;
    }

    void IJCodeExecutionContext.ExitModule() => _moduleStack.RemoveAt(_moduleStackEnd--);

    void IJCodeExecutionContext.EnterExpr(IJExpr e) {
        _expressionStack.Add(e);
        _exprStackEnd++;
    }
    
    void IJCodeExecutionContext.ExitExpr() => _expressionStack.RemoveAt(_exprStackEnd--);
}
runtime.core.JIL
runtime.core
runtime
core
JIL
public class JILInterpreter : JRuntimeContext, Reader.IJILBaseVisitor, IJCodeExecutionContext {
    private readonly List<IJExpr> _expressionStack = new();
    private readonly List<IJModule> _moduleStack = new();
    private int _exprStackEnd;
    private int _moduleStackEnd;
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {}


    public JILInterpreter(string[] strings, IJModule[] modules, IJType[] types) : base(strings, modules, types) {}
    
    public IJExpr GetExpr(int i) => _expressionStack[i];
    public IJModule GetModule(int i) => _moduleStack[i];
    public IJField GetNameField(IJExpr e, JNameRef nameRef) => _expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef);
    
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
        nameRef = default;
        return false;
    }
    
    
    IJModule IJCodeExecutionContext.CurrentModule => _moduleStack.First();
    IJExpr IJCodeExecutionContext.CurrentExpr => _expressionStack.First();

    void IJCodeExecutionContext.EnterModule(IJModule m) {
        _moduleStack.Add(m);
        _moduleStackEnd++;
    }

    void IJCodeExecutionContext.ExitModule() => _moduleStack.RemoveAt(_moduleStackEnd--);

    void IJCodeExecutionContext.EnterExpr(IJExpr e) {
        _expressionStack.Add(e);
        _exprStackEnd++;
    }
    
    void IJCodeExecutionContext.ExitExpr() => _expressionStack.RemoveAt(_exprStackEnd--);
}
: JRuntimeContext, Reader.IJILBaseVisitor, IJCodeExecutionContext
JRuntimeContext
JRuntimeContext
Reader.IJILBaseVisitor
Reader.IJILBaseVisitor
Reader
IJILBaseVisitor
IJCodeExecutionContext
IJCodeExecutionContext
private readonly List<IJExpr> _expressionStack = new();
List<IJExpr> _expressionStack = new()
List<IJExpr>
<IJExpr>
IJExpr
_expressionStack = new()
= new()
new()
()
private readonly List<IJModule> _moduleStack = new();
List<IJModule> _moduleStack = new()
List<IJModule>
<IJModule>
IJModule
_moduleStack = new()
= new()
new()
()
private int _exprStackEnd;
int _exprStackEnd
int
_exprStackEnd
private int _moduleStackEnd;
int _moduleStackEnd
int
_moduleStackEnd
public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {}
void
(IJType loadedType, ref int loadedTypeIndex)
IJType loadedType
IJType
ref int loadedTypeIndex
int
{}
public JILInterpreter(string[] strings, IJModule[] modules, IJType[] types) : base(strings, modules, types) {}
(string[] strings, IJModule[] modules, IJType[] types)
string[] strings
string[]
string
[]

IJModule[] modules
IJModule[]
IJModule
[]

IJType[] types
IJType[]
IJType
[]

: base(strings, modules, types)
(strings, modules, types)
strings
strings
modules
modules
types
types
{}
public IJExpr GetExpr(int i) => _expressionStack[i];
IJExpr
(int i)
int i
int
=> _expressionStack[i]
_expressionStack[i]
_expressionStack
[i]
i
i
public IJModule GetModule(int i) => _moduleStack[i];
IJModule
(int i)
int i
int
=> _moduleStack[i]
_moduleStack[i]
_moduleStack
[i]
i
i
public IJField GetNameField(IJExpr e, JNameRef nameRef) => _expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef);
IJField
(IJExpr e, JNameRef nameRef)
IJExpr e
IJExpr
JNameRef nameRef
JNameRef
=> _expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef)
_expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef)
_expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl
_expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta]
_expressionStack
[_exprStackEnd - nameRef.CompileTimeExprStackDelta]
_exprStackEnd - nameRef.CompileTimeExprStackDelta
_exprStackEnd - nameRef.CompileTimeExprStackDelta
_exprStackEnd
nameRef.CompileTimeExprStackDelta
nameRef
CompileTimeExprStackDelta
GetNameFieldImpl
(nameRef)
nameRef
nameRef
public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
        nameRef = default;
        return false;
    }
bool
(IJExpr e, string name, out JNameRef nameRef)
IJExpr e
IJExpr
string name
string
out JNameRef nameRef
JNameRef
{
        for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
        nameRef = default;
        return false;
    }
for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
int i = _exprStackEnd
int
i = _exprStackEnd
= _exprStackEnd
_exprStackEnd
i >= 0
i
0
i --
i
if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
_expressionStack[i].GetNameRefImpl(name, out nameRef)
_expressionStack[i].GetNameRefImpl
_expressionStack[i]
_expressionStack
[i]
i
i
GetNameRefImpl
(name, out nameRef)
name
name
out nameRef
nameRef
return true;
true
nameRef = default;
nameRef = default
nameRef
default
return false;
false
IJModule IJCodeExecutionContext.CurrentModule => _moduleStack.First();
IJModule
IJCodeExecutionContext.
IJCodeExecutionContext
=> _moduleStack.First()
_moduleStack.First()
_moduleStack.First
_moduleStack
First
()
IJExpr IJCodeExecutionContext.CurrentExpr => _expressionStack.First();
IJExpr
IJCodeExecutionContext.
IJCodeExecutionContext
=> _expressionStack.First()
_expressionStack.First()
_expressionStack.First
_expressionStack
First
()
void IJCodeExecutionContext.EnterModule(IJModule m) {
        _moduleStack.Add(m);
        _moduleStackEnd++;
    }
void
IJCodeExecutionContext.
IJCodeExecutionContext
(IJModule m)
IJModule m
IJModule
{
        _moduleStack.Add(m);
        _moduleStackEnd++;
    }
_moduleStack.Add(m);
_moduleStack.Add(m)
_moduleStack.Add
_moduleStack
Add
(m)
m
m
_moduleStackEnd++;
_moduleStackEnd++
_moduleStackEnd
void IJCodeExecutionContext.ExitModule() => _moduleStack.RemoveAt(_moduleStackEnd--);
void
IJCodeExecutionContext.
IJCodeExecutionContext
()
=> _moduleStack.RemoveAt(_moduleStackEnd--)
_moduleStack.RemoveAt(_moduleStackEnd--)
_moduleStack.RemoveAt
_moduleStack
RemoveAt
(_moduleStackEnd--)
_moduleStackEnd--
_moduleStackEnd--
_moduleStackEnd
void IJCodeExecutionContext.EnterExpr(IJExpr e) {
        _expressionStack.Add(e);
        _exprStackEnd++;
    }
void
IJCodeExecutionContext.
IJCodeExecutionContext
(IJExpr e)
IJExpr e
IJExpr
{
        _expressionStack.Add(e);
        _exprStackEnd++;
    }
_expressionStack.Add(e);
_expressionStack.Add(e)
_expressionStack.Add
_expressionStack
Add
(e)
e
e
_exprStackEnd++;
_exprStackEnd++
_exprStackEnd
void IJCodeExecutionContext.ExitExpr() => _expressionStack.RemoveAt(_exprStackEnd--);
void
IJCodeExecutionContext.
IJCodeExecutionContext
()
=> _expressionStack.RemoveAt(_exprStackEnd--)
_expressionStack.RemoveAt(_exprStackEnd--)
_expressionStack.RemoveAt
_expressionStack
RemoveAt
(_exprStackEnd--)
_exprStackEnd--
_exprStackEnd--
_exprStackEnd
using System;
using System.Text;
using runtime.core.Runtime;
using runtime.Utils;

namespace runtime.core.JIL;

public class JILPrinter : Reader.IJILBaseVisitor {
    private int _indent = 0;
    private bool _hasIdented = true;
    private bool _dump;
    private readonly StringBuilder _sb = new();

    public JILPrinter(bool dump = true) => _dump = dump;

    public void IncIndent() => _indent++;
    public void DecIndent() => _indent--;

    public JILPrinter Print(string s)
    {
        if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }

        _sb.Append(s);
        return this;
    }

    public JILPrinter Println(string s = "")
    {
        Print(s);
        Print("\n");
        _hasIdented = false;
        return this;
    }

    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        if (_dump)
            Println("#=Instantiate Type=#");
                
        PrintType(loadedType);
    }

    public static unsafe void PrintBytes(byte* bytes, int length)
    {
        for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");
        Console.WriteLine();
    }

    private static unsafe string GetFieldTypeName(IJField f) {
        if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
        return f.Type.Name;
    }
    
    public void PrintType(IJType t) {
        if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
        
        Println(t.Name).IncIndent();

        t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });
        
        t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });

        DecIndent();
        Println().Println("end");
    }

    public void PrintMethod(string name, IJMethod m) {
        
    }

    public override string ToString() => _sb.ToString();
}
using System;
System
using System.Text;
System.Text
System
Text
using runtime.core.Runtime;
runtime.core.Runtime
runtime.core
runtime
core
Runtime
using runtime.Utils;
runtime.Utils
runtime
Utils
namespace runtime.core.JIL;

public class JILPrinter : Reader.IJILBaseVisitor {
    private int _indent = 0;
    private bool _hasIdented = true;
    private bool _dump;
    private readonly StringBuilder _sb = new();

    public JILPrinter(bool dump = true) => _dump = dump;

    public void IncIndent() => _indent++;
    public void DecIndent() => _indent--;

    public JILPrinter Print(string s)
    {
        if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }

        _sb.Append(s);
        return this;
    }

    public JILPrinter Println(string s = "")
    {
        Print(s);
        Print("\n");
        _hasIdented = false;
        return this;
    }

    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        if (_dump)
            Println("#=Instantiate Type=#");
                
        PrintType(loadedType);
    }

    public static unsafe void PrintBytes(byte* bytes, int length)
    {
        for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");
        Console.WriteLine();
    }

    private static unsafe string GetFieldTypeName(IJField f) {
        if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
        return f.Type.Name;
    }
    
    public void PrintType(IJType t) {
        if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
        
        Println(t.Name).IncIndent();

        t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });
        
        t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });

        DecIndent();
        Println().Println("end");
    }

    public void PrintMethod(string name, IJMethod m) {
        
    }

    public override string ToString() => _sb.ToString();
}
runtime.core.JIL
runtime.core
runtime
core
JIL
public class JILPrinter : Reader.IJILBaseVisitor {
    private int _indent = 0;
    private bool _hasIdented = true;
    private bool _dump;
    private readonly StringBuilder _sb = new();

    public JILPrinter(bool dump = true) => _dump = dump;

    public void IncIndent() => _indent++;
    public void DecIndent() => _indent--;

    public JILPrinter Print(string s)
    {
        if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }

        _sb.Append(s);
        return this;
    }

    public JILPrinter Println(string s = "")
    {
        Print(s);
        Print("\n");
        _hasIdented = false;
        return this;
    }

    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        if (_dump)
            Println("#=Instantiate Type=#");
                
        PrintType(loadedType);
    }

    public static unsafe void PrintBytes(byte* bytes, int length)
    {
        for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");
        Console.WriteLine();
    }

    private static unsafe string GetFieldTypeName(IJField f) {
        if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
        return f.Type.Name;
    }
    
    public void PrintType(IJType t) {
        if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
        
        Println(t.Name).IncIndent();

        t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });
        
        t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });

        DecIndent();
        Println().Println("end");
    }

    public void PrintMethod(string name, IJMethod m) {
        
    }

    public override string ToString() => _sb.ToString();
}
: Reader.IJILBaseVisitor
Reader.IJILBaseVisitor
Reader.IJILBaseVisitor
Reader
IJILBaseVisitor
private int _indent = 0;
int _indent = 0
int
_indent = 0
= 0
0
private bool _hasIdented = true;
bool _hasIdented = true
bool
_hasIdented = true
= true
true
private bool _dump;
bool _dump
bool
_dump
private readonly StringBuilder _sb = new();
StringBuilder _sb = new()
StringBuilder
_sb = new()
= new()
new()
()
public JILPrinter(bool dump = true) => _dump = dump;
(bool dump = true)
bool dump = true
bool
= true
true
=> _dump = dump
_dump = dump
_dump
dump
public void IncIndent() => _indent++;
void
()
=> _indent++
_indent++
_indent
public void DecIndent() => _indent--;
void
()
=> _indent--
_indent--
_indent
public JILPrinter Print(string s)
    {
        if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }

        _sb.Append(s);
        return this;
    }
JILPrinter
(string s)
string s
string
{
        if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }

        _sb.Append(s);
        return this;
    }
if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }
!_hasIdented
_hasIdented
{
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }
_sb.Capacity += _indent;
_sb.Capacity += _indent
_sb.Capacity
_sb
Capacity
_indent
for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
int i = 0
int
i = 0
= 0
0
i < _indent
i
_indent
i++
i
_sb.Append("\t");
_sb.Append("\t")
_sb.Append
_sb
Append
("\t")
"\t"
"\t"
_hasIdented = true;
_hasIdented = true
_hasIdented
true
_sb.Append(s);
_sb.Append(s)
_sb.Append
_sb
Append
(s)
s
s
return this;
this
public JILPrinter Println(string s = "")
    {
        Print(s);
        Print("\n");
        _hasIdented = false;
        return this;
    }
JILPrinter
(string s = "")
string s = ""
string
= ""
""
{
        Print(s);
        Print("\n");
        _hasIdented = false;
        return this;
    }
Print(s);
Print(s)
Print
(s)
s
s
Print("\n");
Print("\n")
Print
("\n")
"\n"
"\n"
_hasIdented = false;
_hasIdented = false
_hasIdented
false
return this;
this
public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        if (_dump)
            Println("#=Instantiate Type=#");
                
        PrintType(loadedType);
    }
void
(IJType loadedType, ref int loadedTypeIndex)
IJType loadedType
IJType
ref int loadedTypeIndex
int
{
        if (_dump)
            Println("#=Instantiate Type=#");
                
        PrintType(loadedType);
    }
if (_dump)
            Println("#=Instantiate Type=#");
_dump
Println("#=Instantiate Type=#");
Println("#=Instantiate Type=#")
Println
("#=Instantiate Type=#")
"#=Instantiate Type=#"
"#=Instantiate Type=#"
PrintType(loadedType);
PrintType(loadedType)
PrintType
(loadedType)
loadedType
loadedType
public static unsafe void PrintBytes(byte* bytes, int length)
    {
        for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");
        Console.WriteLine();
    }
void
(byte* bytes, int length)
byte* bytes
byte*
byte
int length
int
{
        for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");
        Console.WriteLine();
    }
for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");
int i = 0
int
i = 0
= 0
0
i < length
i
length
i++
i
Console.Write(bytes[i] + " ");
Console.Write(bytes[i] + " ")
Console.Write
Console
Write
(bytes[i] + " ")
bytes[i] + " "
bytes[i] + " "
bytes[i]
bytes
[i]
i
i
" "
Console.WriteLine();
Console.WriteLine()
Console.WriteLine
Console
WriteLine
()
private static unsafe string GetFieldTypeName(IJField f) {
        if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
        return f.Type.Name;
    }
string
(IJField f)
IJField f
IJField
{
        if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
        return f.Type.Name;
    }
if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
f is JILField jf
f
JILField jf
JILField
jf
{
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
return f.Parent.GetNameField(jf.TypeRef).Name;
f.Parent.GetNameField(jf.TypeRef).Name
f.Parent.GetNameField(jf.TypeRef)
f.Parent.GetNameField
f.Parent
f
Parent
GetNameField
(jf.TypeRef)
jf.TypeRef
jf.TypeRef
jf
TypeRef
Name
return f.Type.Name;
f.Type.Name
f.Type
f
Type
Name
public void PrintType(IJType t) {
        if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
        
        Println(t.Name).IncIndent();

        t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });
        
        t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });

        DecIndent();
        Println().Println("end");
    }
void
(IJType t)
IJType t
IJType
{
        if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
        
        Println(t.Name).IncIndent();

        t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });
        
        t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });

        DecIndent();
        Println().Println("end");
    }
if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
t.Type == JTypeType.Struct
t.Type
t
Type
JTypeType.Struct
JTypeType
Struct
Print("struct ");
Print("struct ")
Print
("struct ")
"struct "
"struct "
else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
t.Type == JTypeType.Mutable
t.Type
t
Type
JTypeType.Mutable
JTypeType
Mutable
Print("mutable struct ");
Print("mutable struct ")
Print
("mutable struct ")
"mutable struct "
"mutable struct "
Println(t.Name).IncIndent();
Println(t.Name).IncIndent()
Println(t.Name).IncIndent
Println(t.Name)
Println
(t.Name)
t.Name
t.Name
t
Name
IncIndent
()
t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });
t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        })
t.VisitFields
t
VisitFields
(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        })
x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        }
x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        }
x
{
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        }
if (x.IsConst)
                Print("const ");
x.IsConst
x
IsConst
Print("const ");
Print("const ")
Print
("const ")
"const "
"const "
Println(x.Name);
Println(x.Name)
Println
(x.Name)
x.Name
x.Name
x
Name
var tyName = GetFieldTypeName(x);
var tyName = GetFieldTypeName(x)
var
tyName = GetFieldTypeName(x)
= GetFieldTypeName(x)
GetFieldTypeName(x)
GetFieldTypeName
(x)
x
x
if (tyName != "Any") {
                Print("::").Println(tyName);
            }
tyName != "Any"
tyName
"Any"
{
                Print("::").Println(tyName);
            }
Print("::").Println(tyName);
Print("::").Println(tyName)
Print("::").Println
Print("::")
Print
("::")
"::"
"::"
Println
(tyName)
tyName
tyName
return true;
true
t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });
t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        })
t.VisitConstructors
t
VisitConstructors
(x => {
            PrintMethod(t.Name, x);
            return true;
        })
x => {
            PrintMethod(t.Name, x);
            return true;
        }
x => {
            PrintMethod(t.Name, x);
            return true;
        }
x
{
            PrintMethod(t.Name, x);
            return true;
        }
PrintMethod(t.Name, x);
PrintMethod(t.Name, x)
PrintMethod
(t.Name, x)
t.Name
t.Name
t
Name
x
x
return true;
true
DecIndent();
DecIndent()
DecIndent
()
Println().Println("end");
Println().Println("end")
Println().Println
Println()
Println
()
Println
("end")
"end"
"end"
public void PrintMethod(string name, IJMethod m) {
        
    }
void
(string name, IJMethod m)
string name
string
IJMethod m
IJMethod
{
        
    }
public override string ToString() => _sb.ToString();
string
()
=> _sb.ToString()
_sb.ToString()
_sb.ToString
_sb
ToString
()
namespace runtime.core.JIL;

public class Reader
{
    private static unsafe byte* ReadD(ref byte* p)
    {
        var b = p + 1;
        p += JOp.OpCodeTable[*p].OperandsSize;
        return b;
    }

    private static unsafe T ReadData<T>(ref byte* ptr) where T : unmanaged
    {
        var t = (T*) ptr;
        var v = *t++;
        ptr = (byte*) t;
        return v;
    }

    private static unsafe ref T ReadData<T>(byte* ptr) where T : unmanaged => ref *(T*)ptr;

    public interface IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex);

        unsafe void Visit(IJCodeContext ctx, byte[] code) {
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }
        
        unsafe void Visit(ref byte* p, IJCodeContext ctx) {
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }
    }

    public interface IJILVisitor : IJILBaseVisitor{
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex){}
        
    }
    
    public interface IJILBaseTopVisitor : IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => VisitLoadType(loadedType);
        void VisitLoadType(IJType loadedType);
    }
    
    public interface IJILTopVisitor : IJILBaseTopVisitor {
        void VisitLoadType(IJType loadedType){}
    }
}
namespace runtime.core.JIL;

public class Reader
{
    private static unsafe byte* ReadD(ref byte* p)
    {
        var b = p + 1;
        p += JOp.OpCodeTable[*p].OperandsSize;
        return b;
    }

    private static unsafe T ReadData<T>(ref byte* ptr) where T : unmanaged
    {
        var t = (T*) ptr;
        var v = *t++;
        ptr = (byte*) t;
        return v;
    }

    private static unsafe ref T ReadData<T>(byte* ptr) where T : unmanaged => ref *(T*)ptr;

    public interface IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex);

        unsafe void Visit(IJCodeContext ctx, byte[] code) {
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }
        
        unsafe void Visit(ref byte* p, IJCodeContext ctx) {
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }
    }

    public interface IJILVisitor : IJILBaseVisitor{
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex){}
        
    }
    
    public interface IJILBaseTopVisitor : IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => VisitLoadType(loadedType);
        void VisitLoadType(IJType loadedType);
    }
    
    public interface IJILTopVisitor : IJILBaseTopVisitor {
        void VisitLoadType(IJType loadedType){}
    }
}
runtime.core.JIL
runtime.core
runtime
core
JIL
public class Reader
{
    private static unsafe byte* ReadD(ref byte* p)
    {
        var b = p + 1;
        p += JOp.OpCodeTable[*p].OperandsSize;
        return b;
    }

    private static unsafe T ReadData<T>(ref byte* ptr) where T : unmanaged
    {
        var t = (T*) ptr;
        var v = *t++;
        ptr = (byte*) t;
        return v;
    }

    private static unsafe ref T ReadData<T>(byte* ptr) where T : unmanaged => ref *(T*)ptr;

    public interface IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex);

        unsafe void Visit(IJCodeContext ctx, byte[] code) {
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }
        
        unsafe void Visit(ref byte* p, IJCodeContext ctx) {
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }
    }

    public interface IJILVisitor : IJILBaseVisitor{
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex){}
        
    }
    
    public interface IJILBaseTopVisitor : IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => VisitLoadType(loadedType);
        void VisitLoadType(IJType loadedType);
    }
    
    public interface IJILTopVisitor : IJILBaseTopVisitor {
        void VisitLoadType(IJType loadedType){}
    }
}
private static unsafe byte* ReadD(ref byte* p)
    {
        var b = p + 1;
        p += JOp.OpCodeTable[*p].OperandsSize;
        return b;
    }
byte*
byte
(ref byte* p)
ref byte* p
byte*
byte
{
        var b = p + 1;
        p += JOp.OpCodeTable[*p].OperandsSize;
        return b;
    }
var b = p + 1;
var b = p + 1
var
b = p + 1
= p + 1
p + 1
p
1
p += JOp.OpCodeTable[*p].OperandsSize;
p += JOp.OpCodeTable[*p].OperandsSize
p
JOp.OpCodeTable[*p].OperandsSize
JOp.OpCodeTable[*p]
JOp.OpCodeTable
JOp
OpCodeTable
[*p]
*p
*p
p
OperandsSize
return b;
b
private static unsafe T ReadData<T>(ref byte* ptr) where T : unmanaged
    {
        var t = (T*) ptr;
        var v = *t++;
        ptr = (byte*) t;
        return v;
    }
T
<T>
T
(ref byte* ptr)
ref byte* ptr
byte*
byte
where T : unmanaged
T
unmanaged
unmanaged
{
        var t = (T*) ptr;
        var v = *t++;
        ptr = (byte*) t;
        return v;
    }
var t = (T*) ptr;
var t = (T*) ptr
var
t = (T*) ptr
= (T*) ptr
(T*) ptr
T*
T
ptr
var v = *t++;
var v = *t++
var
v = *t++
= *t++
*t++
t++
t
ptr = (byte*) t;
ptr = (byte*) t
ptr
(byte*) t
byte*
byte
t
return v;
v
private static unsafe ref T ReadData<T>(byte* ptr) where T : unmanaged => ref *(T*)ptr;
ref T
T
<T>
T
(byte* ptr)
byte* ptr
byte*
byte
where T : unmanaged
T
unmanaged
unmanaged
=> ref *(T*)ptr
ref *(T*)ptr
*(T*)ptr
(T*)ptr
T*
T
ptr
public interface IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex);

        unsafe void Visit(IJCodeContext ctx, byte[] code) {
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }
        
        unsafe void Visit(ref byte* p, IJCodeContext ctx) {
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }
    }
void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex);
void
(IJType loadedType, ref int loadedTypeIndex)
IJType loadedType
IJType
ref int loadedTypeIndex
int
unsafe void Visit(IJCodeContext ctx, byte[] code) {
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }
void
(IJCodeContext ctx, byte[] code)
IJCodeContext ctx
IJCodeContext
byte[] code
byte[]
byte
[]

{
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }
fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
byte* ptr = code
byte*
byte
ptr = code
= code
code
{
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
byte* mptr = ptr;
byte* mptr = ptr
byte*
byte
mptr = ptr
= ptr
ptr
var eptr = ptr + code.Length;
var eptr = ptr + code.Length
var
eptr = ptr + code.Length
= ptr + code.Length
ptr + code.Length
ptr
code.Length
code
Length
while (mptr < eptr)
                    Visit(ref mptr, ctx);
mptr < eptr
mptr
eptr
Visit(ref mptr, ctx);
Visit(ref mptr, ctx)
Visit
(ref mptr, ctx)
ref mptr
mptr
ctx
ctx
unsafe void Visit(ref byte* p, IJCodeContext ctx) {
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }
void
(ref byte* p, IJCodeContext ctx)
ref byte* p
byte*
byte
IJCodeContext ctx
IJCodeContext
{
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }
switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
*p
p
case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
case JOp.LoadTypeOp:
JOp.LoadTypeOp
JOp
LoadTypeOp
ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p))
ref var
var
loadedTypeIndex = ref ReadData<int>(ReadD(ref p))
= ref ReadData<int>(ReadD(ref p))
ref ReadData<int>(ReadD(ref p))
ReadData<int>(ReadD(ref p))
ReadData<int>
<int>
int
(ReadD(ref p))
ReadD(ref p)
ReadD(ref p)
ReadD
(ref p)
ref p
p
var loadedType = ctx.GetCtxType(loadedTypeIndex);
var loadedType = ctx.GetCtxType(loadedTypeIndex)
var
loadedType = ctx.GetCtxType(loadedTypeIndex)
= ctx.GetCtxType(loadedTypeIndex)
ctx.GetCtxType(loadedTypeIndex)
ctx.GetCtxType
ctx
GetCtxType
(loadedTypeIndex)
loadedTypeIndex
loadedTypeIndex
if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
loadedType == null
loadedType
null
throw new InternalJuliaException("Type Not Loaded!");
new InternalJuliaException("Type Not Loaded!")
InternalJuliaException
("Type Not Loaded!")
"Type Not Loaded!"
"Type Not Loaded!"
VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
VisitLoadTypeImpl(loadedType, ref loadedTypeIndex)
VisitLoadTypeImpl
(loadedType, ref loadedTypeIndex)
loadedType
loadedType
ref loadedTypeIndex
loadedTypeIndex
return;
public interface IJILVisitor : IJILBaseVisitor{
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex){}
        
    }
: IJILBaseVisitor
IJILBaseVisitor
IJILBaseVisitor
void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex){}
void
(IJType loadedType, ref int loadedTypeIndex)
IJType loadedType
IJType
ref int loadedTypeIndex
int
{}
public interface IJILBaseTopVisitor : IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => VisitLoadType(loadedType);
        void VisitLoadType(IJType loadedType);
    }
: IJILBaseVisitor
IJILBaseVisitor
IJILBaseVisitor
void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => VisitLoadType(loadedType);
void
(IJType loadedType, ref int loadedTypeIndex)
IJType loadedType
IJType
ref int loadedTypeIndex
int
=> VisitLoadType(loadedType)
VisitLoadType(loadedType)
VisitLoadType
(loadedType)
loadedType
loadedType
void VisitLoadType(IJType loadedType);
void
(IJType loadedType)
IJType loadedType
IJType
public interface IJILTopVisitor : IJILBaseTopVisitor {
        void VisitLoadType(IJType loadedType){}
    }
: IJILBaseTopVisitor
IJILBaseTopVisitor
IJILBaseTopVisitor
void VisitLoadType(IJType loadedType){}
void
(IJType loadedType)
IJType loadedType
IJType
{}
namespace runtime.core.JIL;

public class Serialization
{
    
    
}
namespace runtime.core.JIL;

public class Serialization
{
    
    
}
runtime.core.JIL
runtime.core
runtime
core
JIL
public class Serialization
{
    
    
}
using System;using System.Collections.Generic;using System.Reflection.Emit;using runtime.core.JIL;namespace runtime.core.Runtime;public sealed class JRootModule : JRuntimeModule{    private static readonly Dictionary<string, JRootModule> RootModules = new();    private readonly ModuleBuilder _m;    internal JRootModule(ModuleBuilder m, JILModule jm, JRuntimeContext ctx) : base(jm, ctx, null) {        _m = m;        Parent = this;        RootModules.Add(jm.Name, this);    }    public static JRootModule GetRootModule(string name) {        if (RootModules.TryGetValue(name, out JRootModule m))            return m;        return null;    }    internal static JRootModule CreateRootModule(string name) {        // var asm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(name + "Asm"), AssemblyBuilderAccess.Run);        //asm.DefineDynamicModule(name)        var mods = new IJModule[1];        var tys = Array.Empty<IJType>();        var jrc = new JRuntimeContext(new[] { name }, mods, tys);        var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);        jm.Ctx = jrc;                JRootModule em = new(null, jm, jrc);        mods[0] = em;        jm.Parent = em;        return em;    }}
using System;
System
using System.Collections.Generic;
System.Collections.Generic
System.Collections
System
Collections
Generic
using System.Reflection.Emit;
System.Reflection.Emit
System.Reflection
System
Reflection
Emit
using runtime.core.JIL;
runtime.core.JIL
runtime.core
runtime
core
JIL
namespace runtime.core.Runtime;public sealed class JRootModule : JRuntimeModule{    private static readonly Dictionary<string, JRootModule> RootModules = new();    private readonly ModuleBuilder _m;    internal JRootModule(ModuleBuilder m, JILModule jm, JRuntimeContext ctx) : base(jm, ctx, null) {        _m = m;        Parent = this;        RootModules.Add(jm.Name, this);    }    public static JRootModule GetRootModule(string name) {        if (RootModules.TryGetValue(name, out JRootModule m))            return m;        return null;    }    internal static JRootModule CreateRootModule(string name) {        // var asm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(name + "Asm"), AssemblyBuilderAccess.Run);        //asm.DefineDynamicModule(name)        var mods = new IJModule[1];        var tys = Array.Empty<IJType>();        var jrc = new JRuntimeContext(new[] { name }, mods, tys);        var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);        jm.Ctx = jrc;                JRootModule em = new(null, jm, jrc);        mods[0] = em;        jm.Parent = em;        return em;    }}
runtime.core.Runtime
runtime.core
runtime
core
Runtime
public sealed class JRootModule : JRuntimeModule{    private static readonly Dictionary<string, JRootModule> RootModules = new();    private readonly ModuleBuilder _m;    internal JRootModule(ModuleBuilder m, JILModule jm, JRuntimeContext ctx) : base(jm, ctx, null) {        _m = m;        Parent = this;        RootModules.Add(jm.Name, this);    }    public static JRootModule GetRootModule(string name) {        if (RootModules.TryGetValue(name, out JRootModule m))            return m;        return null;    }    internal static JRootModule CreateRootModule(string name) {        // var asm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(name + "Asm"), AssemblyBuilderAccess.Run);        //asm.DefineDynamicModule(name)        var mods = new IJModule[1];        var tys = Array.Empty<IJType>();        var jrc = new JRuntimeContext(new[] { name }, mods, tys);        var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);        jm.Ctx = jrc;                JRootModule em = new(null, jm, jrc);        mods[0] = em;        jm.Parent = em;        return em;    }}
: JRuntimeModule
JRuntimeModule
JRuntimeModule
private static readonly Dictionary<string, JRootModule> RootModules = new();
Dictionary<string, JRootModule> RootModules = new()
Dictionary<string, JRootModule>
<string, JRootModule>
string
JRootModule
RootModules = new()
= new()
new()
()
private readonly ModuleBuilder _m;
ModuleBuilder _m
ModuleBuilder
_m
internal JRootModule(ModuleBuilder m, JILModule jm, JRuntimeContext ctx) : base(jm, ctx, null) {        _m = m;        Parent = this;        RootModules.Add(jm.Name, this);    }
(ModuleBuilder m, JILModule jm, JRuntimeContext ctx)
ModuleBuilder m
ModuleBuilder
JILModule jm
JILModule
JRuntimeContext ctx
JRuntimeContext
: base(jm, ctx, null)
(jm, ctx, null)
jm
jm
ctx
ctx
null
null
{        _m = m;        Parent = this;        RootModules.Add(jm.Name, this);    }
_m = m;
_m = m
_m
m
Parent = this;
Parent = this
Parent
this
RootModules.Add(jm.Name, this);
RootModules.Add(jm.Name, this)
RootModules.Add
RootModules
Add
(jm.Name, this)
jm.Name
jm.Name
jm
Name
this
this
public static JRootModule GetRootModule(string name) {        if (RootModules.TryGetValue(name, out JRootModule m))            return m;        return null;    }
JRootModule
(string name)
string name
string
{        if (RootModules.TryGetValue(name, out JRootModule m))            return m;        return null;    }
if (RootModules.TryGetValue(name, out JRootModule m))            return m;
RootModules.TryGetValue(name, out JRootModule m)
RootModules.TryGetValue
RootModules
TryGetValue
(name, out JRootModule m)
name
name
out JRootModule m
JRootModule m
JRootModule
m
return m;
m
return null;
null
internal static JRootModule CreateRootModule(string name) {        // var asm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(name + "Asm"), AssemblyBuilderAccess.Run);        //asm.DefineDynamicModule(name)        var mods = new IJModule[1];        var tys = Array.Empty<IJType>();        var jrc = new JRuntimeContext(new[] { name }, mods, tys);        var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);        jm.Ctx = jrc;                JRootModule em = new(null, jm, jrc);        mods[0] = em;        jm.Parent = em;        return em;    }
JRootModule
(string name)
string name
string
{        // var asm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(name + "Asm"), AssemblyBuilderAccess.Run);        //asm.DefineDynamicModule(name)        var mods = new IJModule[1];        var tys = Array.Empty<IJType>();        var jrc = new JRuntimeContext(new[] { name }, mods, tys);        var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);        jm.Ctx = jrc;                JRootModule em = new(null, jm, jrc);        mods[0] = em;        jm.Parent = em;        return em;    }
var mods = new IJModule[1];
var mods = new IJModule[1]
var
mods = new IJModule[1]
= new IJModule[1]
new IJModule[1]
IJModule[1]
IJModule
[1]
1
var tys = Array.Empty<IJType>();
var tys = Array.Empty<IJType>()
var
tys = Array.Empty<IJType>()
= Array.Empty<IJType>()
Array.Empty<IJType>()
Array.Empty<IJType>
Array
Empty<IJType>
<IJType>
IJType
()
var jrc = new JRuntimeContext(new[] { name }, mods, tys);
var jrc = new JRuntimeContext(new[] { name }, mods, tys)
var
jrc = new JRuntimeContext(new[] { name }, mods, tys)
= new JRuntimeContext(new[] { name }, mods, tys)
new JRuntimeContext(new[] { name }, mods, tys)
JRuntimeContext
(new[] { name }, mods, tys)
new[] { name }
new[] { name }
{ name }
name
mods
mods
tys
tys
var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);
var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null)
var
jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null)
= new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null)
new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null)
JILModule
(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null)
0
0
JModuleFlags.Bare
JModuleFlags.Bare
JModuleFlags
Bare
JExprFlags.None
JExprFlags.None
JExprFlags
None
Array.Empty<byte>()
Array.Empty<byte>()
Array.Empty<byte>
Array
Empty<byte>
<byte>
byte
()
Array.Empty<JNameRef>()
Array.Empty<JNameRef>()
Array.Empty<JNameRef>
Array
Empty<JNameRef>
<JNameRef>
JNameRef
()
Array.Empty<JILField>()
Array.Empty<JILField>()
Array.Empty<JILField>
Array
Empty<JILField>
<JILField>
JILField
()
null
null
jm.Ctx = jrc;
jm.Ctx = jrc
jm.Ctx
jm
Ctx
jrc
JRootModule em = new(null, jm, jrc);
JRootModule em = new(null, jm, jrc)
JRootModule
em = new(null, jm, jrc)
= new(null, jm, jrc)
new(null, jm, jrc)
(null, jm, jrc)
null
null
jm
jm
jrc
jrc
mods[0] = em;
mods[0] = em
mods[0]
mods
[0]
0
0
em
jm.Parent = em;
jm.Parent = em
jm.Parent
jm
Parent
em
return em;
em
using System;
using runtime.core.JIL;

namespace runtime.core.Runtime;

public class JRuntimeExpr : IJExpr
{
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }
    
    internal JRuntimeExpr(JILExpr e, IJExpr parent) {
        Code = e.Code;
        VarTable = e.VarTable;
        Names = e.Names;
        Parent = parent;
        Modifiers = e.Modifiers;
    }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return false;
    }
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    
    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    public override string ToString() {
        JILPrinter p = new();
        ((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);
        return p.ToString();
    }
}
using System;
System
using runtime.core.JIL;
runtime.core.JIL
runtime.core
runtime
core
JIL
namespace runtime.core.Runtime;

public class JRuntimeExpr : IJExpr
{
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }
    
    internal JRuntimeExpr(JILExpr e, IJExpr parent) {
        Code = e.Code;
        VarTable = e.VarTable;
        Names = e.Names;
        Parent = parent;
        Modifiers = e.Modifiers;
    }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return false;
    }
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    
    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    public override string ToString() {
        JILPrinter p = new();
        ((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);
        return p.ToString();
    }
}
runtime.core.Runtime
runtime.core
runtime
core
Runtime
public class JRuntimeExpr : IJExpr
{
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }
    
    internal JRuntimeExpr(JILExpr e, IJExpr parent) {
        Code = e.Code;
        VarTable = e.VarTable;
        Names = e.Names;
        Parent = parent;
        Modifiers = e.Modifiers;
    }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return false;
    }
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    
    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    public override string ToString() {
        JILPrinter p = new();
        ((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);
        return p.ToString();
    }
}
: IJExpr
IJExpr
IJExpr
public readonly byte[] Code;
byte[] Code
byte[]
byte
[]

Code
public readonly JNameRef[] VarTable;
JNameRef[] VarTable
JNameRef[]
JNameRef
[]

VarTable
public readonly JILField[] Names;
JILField[] Names
JILField[]
JILField
[]

Names
public JExprFlags Modifiers { get; }
JExprFlags
{ get; }
get;
public IJExpr Parent { get; internal set; }
IJExpr
{ get; internal set; }
get;
internal set;
internal JRuntimeExpr(JILExpr e, IJExpr parent) {
        Code = e.Code;
        VarTable = e.VarTable;
        Names = e.Names;
        Parent = parent;
        Modifiers = e.Modifiers;
    }
(JILExpr e, IJExpr parent)
JILExpr e
JILExpr
IJExpr parent
IJExpr
{
        Code = e.Code;
        VarTable = e.VarTable;
        Names = e.Names;
        Parent = parent;
        Modifiers = e.Modifiers;
    }
Code = e.Code;
Code = e.Code
Code
e.Code
e
Code
VarTable = e.VarTable;
VarTable = e.VarTable
VarTable
e.VarTable
e
VarTable
Names = e.Names;
Names = e.Names
Names
e.Names
e
Names
Parent = parent;
Parent = parent
Parent
parent
Modifiers = e.Modifiers;
Modifiers = e.Modifiers
Modifiers
e.Modifiers
e
Modifiers
public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return false;
    }
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
{
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return false;
    }
foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
var
VarTable
{
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
!v(Names[va.CompileTimeNameRefIndex])
v(Names[va.CompileTimeNameRefIndex])
v
(Names[va.CompileTimeNameRefIndex])
Names[va.CompileTimeNameRefIndex]
Names[va.CompileTimeNameRefIndex]
Names
[va.CompileTimeNameRefIndex]
va.CompileTimeNameRefIndex
va.CompileTimeNameRefIndex
va
CompileTimeNameRefIndex
return false;
false
return false;
false
public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
bool
(Func<IJField, object, bool> v)
Func<IJField, object, bool> v
Func<IJField, object, bool>
<IJField, object, bool>
IJField
object
bool
{
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
int i = 0
int
i = 0
= 0
0
i < Names.Length
i
Names.Length
Names
Length
i++
i
if (!v(Names[i], null))
                return false;
!v(Names[i], null)
v(Names[i], null)
v
(Names[i], null)
Names[i]
Names[i]
Names
[i]
i
i
null
null
return false;
false
return true;
true
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];
IJField
IJExpr.
IJExpr
(JNameRef nameRef)
JNameRef nameRef
JNameRef
=> Names[nameRef.CompileTimeNameRefIndex]
Names[nameRef.CompileTimeNameRefIndex]
Names
[nameRef.CompileTimeNameRefIndex]
nameRef.CompileTimeNameRefIndex
nameRef.CompileTimeNameRefIndex
nameRef
CompileTimeNameRefIndex
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
bool
IJExpr.
IJExpr
(string name, out JNameRef nameRef)
string name
string
out JNameRef nameRef
JNameRef
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public override string ToString() {
        JILPrinter p = new();
        ((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);
        return p.ToString();
    }
string
()
{
        JILPrinter p = new();
        ((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);
        return p.ToString();
    }
JILPrinter p = new();
JILPrinter p = new()
JILPrinter
p = new()
= new()
new()
()
((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);
((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code)
((Reader.IJILBaseVisitor) p).Visit
((Reader.IJILBaseVisitor) p)
(Reader.IJILBaseVisitor) p
Reader.IJILBaseVisitor
Reader
IJILBaseVisitor
p
Visit
(Parent.Context, Code)
Parent.Context
Parent.Context
Parent
Context
Code
Code
return p.ToString();
p.ToString()
p.ToString
p
ToString
()
using System;
using System.Collections.Generic;
using runtime.core.JIL;
using runtime.Utils;

namespace runtime.core.Runtime;

public sealed class JRuntimeJILMethod : JILMethod{
    internal JRuntimeJILMethod(JILMethod j, JRuntimeModule parent) : 
        base(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent) {}
}

public sealed class JRuntimeFunction : IJFunction
{
    private readonly List<IJMethod> _methods;
    public string Name { get; }
    
    internal JRuntimeFunction(string name, IJMethod[] mts) {
        Name = name;
        _methods = new(mts);
    }

    public bool VisitMethods(Func<IJMethod, bool> v) => _methods.Visit(v);

    public object Invoke(object[] parameters)
    {
        return null;
    }
}
using System;
System
using System.Collections.Generic;
System.Collections.Generic
System.Collections
System
Collections
Generic
using runtime.core.JIL;
runtime.core.JIL
runtime.core
runtime
core
JIL
using runtime.Utils;
runtime.Utils
runtime
Utils
namespace runtime.core.Runtime;

public sealed class JRuntimeJILMethod : JILMethod{
    internal JRuntimeJILMethod(JILMethod j, JRuntimeModule parent) : 
        base(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent) {}
}

public sealed class JRuntimeFunction : IJFunction
{
    private readonly List<IJMethod> _methods;
    public string Name { get; }
    
    internal JRuntimeFunction(string name, IJMethod[] mts) {
        Name = name;
        _methods = new(mts);
    }

    public bool VisitMethods(Func<IJMethod, bool> v) => _methods.Visit(v);

    public object Invoke(object[] parameters)
    {
        return null;
    }
}
runtime.core.Runtime
runtime.core
runtime
core
Runtime
public sealed class JRuntimeJILMethod : JILMethod{
    internal JRuntimeJILMethod(JILMethod j, JRuntimeModule parent) : 
        base(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent) {}
}
: JILMethod
JILMethod
JILMethod
internal JRuntimeJILMethod(JILMethod j, JRuntimeModule parent) : 
        base(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent) {}
(JILMethod j, JRuntimeModule parent)
JILMethod j
JILMethod
JRuntimeModule parent
JRuntimeModule
: 
        base(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent)
(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent)
j.MethodModifiers
j.MethodModifiers
j
MethodModifiers
j.Parameters
j.Parameters
j
Parameters
j.Modifiers
j.Modifiers
j
Modifiers
j.Code
j.Code
j
Code
j.VarTable
j.VarTable
j
VarTable
j.Names
j.Names
j
Names
parent
parent
{}
public sealed class JRuntimeFunction : IJFunction
{
    private readonly List<IJMethod> _methods;
    public string Name { get; }
    
    internal JRuntimeFunction(string name, IJMethod[] mts) {
        Name = name;
        _methods = new(mts);
    }

    public bool VisitMethods(Func<IJMethod, bool> v) => _methods.Visit(v);

    public object Invoke(object[] parameters)
    {
        return null;
    }
}
: IJFunction
IJFunction
IJFunction
private readonly List<IJMethod> _methods;
List<IJMethod> _methods
List<IJMethod>
<IJMethod>
IJMethod
_methods
public string Name { get; }
string
{ get; }
get;
internal JRuntimeFunction(string name, IJMethod[] mts) {
        Name = name;
        _methods = new(mts);
    }
(string name, IJMethod[] mts)
string name
string
IJMethod[] mts
IJMethod[]
IJMethod
[]

{
        Name = name;
        _methods = new(mts);
    }
Name = name;
Name = name
Name
name
_methods = new(mts);
_methods = new(mts)
_methods
new(mts)
(mts)
mts
mts
public bool VisitMethods(Func<IJMethod, bool> v) => _methods.Visit(v);
bool
(Func<IJMethod, bool> v)
Func<IJMethod, bool> v
Func<IJMethod, bool>
<IJMethod, bool>
IJMethod
bool
=> _methods.Visit(v)
_methods.Visit(v)
_methods.Visit
_methods
Visit
(v)
v
v
public object Invoke(object[] parameters)
    {
        return null;
    }
object
(object[] parameters)
object[] parameters
object[]
object
[]

{
        return null;
    }
return null;
null
using System;
using System.Collections.Generic;
using runtime.core.JIL;
using runtime.parse;
using runtime.Utils;

namespace runtime.core.Runtime;

//High Read/Write Speed for Globals
//High Read for Names
//Slow Write for Names
//Low Memory for Names & Globals
public class JRuntimeModule : JRuntimeExpr, IJModule {
    private readonly MInternContainer<string> _names;
    private readonly List<IJName> names;
    
    public string Name { get; }
    public JModuleFlags ModuleModifiers { get; }
    public IJCodeContext Context { get; }

    internal JRuntimeModule(JILModule m, JRuntimeContext ctx, JRuntimeModule parent) : base(m, parent){
        Context = ctx;
        Name = m.Name;
        ModuleModifiers = m.ModuleModifiers;
        names = new(m.Names.Length);
        for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));
    }
    
    public bool GetNameV<T>(JNameRef r, out T t) { throw new NotImplementedException(); }
    public JRuntimeExpr EvalToExpression(string s) => new JuliaStaticCompiler().Compile(new JuliappParser(s), this);
}
using System;
System
using System.Collections.Generic;
System.Collections.Generic
System.Collections
System
Collections
Generic
using runtime.core.JIL;
runtime.core.JIL
runtime.core
runtime
core
JIL
using runtime.parse;
runtime.parse
runtime
parse
using runtime.Utils;
runtime.Utils
runtime
Utils
namespace runtime.core.Runtime;

//High Read/Write Speed for Globals
//High Read for Names
//Slow Write for Names
//Low Memory for Names & Globals
public class JRuntimeModule : JRuntimeExpr, IJModule {
    private readonly MInternContainer<string> _names;
    private readonly List<IJName> names;
    
    public string Name { get; }
    public JModuleFlags ModuleModifiers { get; }
    public IJCodeContext Context { get; }

    internal JRuntimeModule(JILModule m, JRuntimeContext ctx, JRuntimeModule parent) : base(m, parent){
        Context = ctx;
        Name = m.Name;
        ModuleModifiers = m.ModuleModifiers;
        names = new(m.Names.Length);
        for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));
    }
    
    public bool GetNameV<T>(JNameRef r, out T t) { throw new NotImplementedException(); }
    public JRuntimeExpr EvalToExpression(string s) => new JuliaStaticCompiler().Compile(new JuliappParser(s), this);
}
runtime.core.Runtime
runtime.core
runtime
core
Runtime
public class JRuntimeModule : JRuntimeExpr, IJModule {
    private readonly MInternContainer<string> _names;
    private readonly List<IJName> names;
    
    public string Name { get; }
    public JModuleFlags ModuleModifiers { get; }
    public IJCodeContext Context { get; }

    internal JRuntimeModule(JILModule m, JRuntimeContext ctx, JRuntimeModule parent) : base(m, parent){
        Context = ctx;
        Name = m.Name;
        ModuleModifiers = m.ModuleModifiers;
        names = new(m.Names.Length);
        for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));
    }
    
    public bool GetNameV<T>(JNameRef r, out T t) { throw new NotImplementedException(); }
    public JRuntimeExpr EvalToExpression(string s) => new JuliaStaticCompiler().Compile(new JuliappParser(s), this);
}
: JRuntimeExpr, IJModule
JRuntimeExpr
JRuntimeExpr
IJModule
IJModule
private readonly MInternContainer<string> _names;
MInternContainer<string> _names
MInternContainer<string>
<string>
string
_names
private readonly List<IJName> names;
List<IJName> names
List<IJName>
<IJName>
IJName
names
public string Name { get; }
string
{ get; }
get;
public JModuleFlags ModuleModifiers { get; }
JModuleFlags
{ get; }
get;
public IJCodeContext Context { get; }
IJCodeContext
{ get; }
get;
internal JRuntimeModule(JILModule m, JRuntimeContext ctx, JRuntimeModule parent) : base(m, parent){
        Context = ctx;
        Name = m.Name;
        ModuleModifiers = m.ModuleModifiers;
        names = new(m.Names.Length);
        for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));
    }
(JILModule m, JRuntimeContext ctx, JRuntimeModule parent)
JILModule m
JILModule
JRuntimeContext ctx
JRuntimeContext
JRuntimeModule parent
JRuntimeModule
: base(m, parent)
(m, parent)
m
m
parent
parent
{
        Context = ctx;
        Name = m.Name;
        ModuleModifiers = m.ModuleModifiers;
        names = new(m.Names.Length);
        for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));
    }
Context = ctx;
Context = ctx
Context
ctx
Name = m.Name;
Name = m.Name
Name
m.Name
m
Name
ModuleModifiers = m.ModuleModifiers;
ModuleModifiers = m.ModuleModifiers
ModuleModifiers
m.ModuleModifiers
m
ModuleModifiers
names = new(m.Names.Length);
names = new(m.Names.Length)
names
new(m.Names.Length)
(m.Names.Length)
m.Names.Length
m.Names.Length
m.Names
m
Names
Length
for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));
int i = 0
int
i = 0
= 0
0
i < names.Count
i
names.Count
names
Count
i++
i
names[i] = new JRuntimeName(m.Names[i], new(i, 0));
names[i] = new JRuntimeName(m.Names[i], new(i, 0))
names[i]
names
[i]
i
i
new JRuntimeName(m.Names[i], new(i, 0))
JRuntimeName
(m.Names[i], new(i, 0))
m.Names[i]
m.Names[i]
m.Names
m
Names
[i]
i
i
new(i, 0)
new(i, 0)
(i, 0)
i
i
0
0
public bool GetNameV<T>(JNameRef r, out T t) { throw new NotImplementedException(); }
bool
<T>
T
(JNameRef r, out T t)
JNameRef r
JNameRef
out T t
T
{ throw new NotImplementedException(); }
throw new NotImplementedException();
new NotImplementedException()
NotImplementedException
()
public JRuntimeExpr EvalToExpression(string s) => new JuliaStaticCompiler().Compile(new JuliappParser(s), this);
JRuntimeExpr
(string s)
string s
string
=> new JuliaStaticCompiler().Compile(new JuliappParser(s), this)
new JuliaStaticCompiler().Compile(new JuliappParser(s), this)
new JuliaStaticCompiler().Compile
new JuliaStaticCompiler()
JuliaStaticCompiler
()
Compile
(new JuliappParser(s), this)
new JuliappParser(s)
new JuliappParser(s)
JuliappParser
(s)
s
s
this
this
using System;
using System.Linq;
using runtime.core.JIL;
using runtime.Utils;

namespace runtime.core.Runtime;

public class JRuntimeName : IJName {
    private readonly IJField _field;

    public object Value { get; set; }
    public object ObjectValue { get => Value; set => Value = value; }
    public string Name => _field.Name;
    public IJType Type => _field.Type;
    public JFieldFlags Modifiers => _field.Modifiers;
    public JNameRef NameRef { get; }
    
    public JRuntimeName(IJField field, JNameRef nameRef, object v = null) {
        _field = field;
        Value = v;
        NameRef = nameRef;
    }
}
    
public class JRuntimeType : IJType {
    public readonly JILField[] Fields;
    private readonly JRuntimeFunction _constructors;

    public string Name { get; }
    public JTypeType Type { get; }
    public JExprFlags Modifiers => JExprFlags.None;
    public IJExpr Parent { get; internal set; }
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.VisitMethods(v);

    internal JRuntimeType(JILType type) {
        Type = type.Type;
        Name = type.Name;
        Fields = type.Fields;
        _constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());
    }

    public bool VisitVariables(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
}
using System;
System
using System.Linq;
System.Linq
System
Linq
using runtime.core.JIL;
runtime.core.JIL
runtime.core
runtime
core
JIL
using runtime.Utils;
runtime.Utils
runtime
Utils
namespace runtime.core.Runtime;

public class JRuntimeName : IJName {
    private readonly IJField _field;

    public object Value { get; set; }
    public object ObjectValue { get => Value; set => Value = value; }
    public string Name => _field.Name;
    public IJType Type => _field.Type;
    public JFieldFlags Modifiers => _field.Modifiers;
    public JNameRef NameRef { get; }
    
    public JRuntimeName(IJField field, JNameRef nameRef, object v = null) {
        _field = field;
        Value = v;
        NameRef = nameRef;
    }
}
    
public class JRuntimeType : IJType {
    public readonly JILField[] Fields;
    private readonly JRuntimeFunction _constructors;

    public string Name { get; }
    public JTypeType Type { get; }
    public JExprFlags Modifiers => JExprFlags.None;
    public IJExpr Parent { get; internal set; }
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.VisitMethods(v);

    internal JRuntimeType(JILType type) {
        Type = type.Type;
        Name = type.Name;
        Fields = type.Fields;
        _constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());
    }

    public bool VisitVariables(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
}
runtime.core.Runtime
runtime.core
runtime
core
Runtime
public class JRuntimeName : IJName {
    private readonly IJField _field;

    public object Value { get; set; }
    public object ObjectValue { get => Value; set => Value = value; }
    public string Name => _field.Name;
    public IJType Type => _field.Type;
    public JFieldFlags Modifiers => _field.Modifiers;
    public JNameRef NameRef { get; }
    
    public JRuntimeName(IJField field, JNameRef nameRef, object v = null) {
        _field = field;
        Value = v;
        NameRef = nameRef;
    }
}
: IJName
IJName
IJName
private readonly IJField _field;
IJField _field
IJField
_field
public object Value { get; set; }
object
{ get; set; }
get;
set;
public object ObjectValue { get => Value; set => Value = value; }
object
{ get => Value; set => Value = value; }
get => Value;
=> Value
Value
set => Value = value;
=> Value = value
Value = value
Value
value
public string Name => _field.Name;
string
=> _field.Name
_field.Name
_field
Name
public IJType Type => _field.Type;
IJType
=> _field.Type
_field.Type
_field
Type
public JFieldFlags Modifiers => _field.Modifiers;
JFieldFlags
=> _field.Modifiers
_field.Modifiers
_field
Modifiers
public JNameRef NameRef { get; }
JNameRef
{ get; }
get;
public JRuntimeName(IJField field, JNameRef nameRef, object v = null) {
        _field = field;
        Value = v;
        NameRef = nameRef;
    }
(IJField field, JNameRef nameRef, object v = null)
IJField field
IJField
JNameRef nameRef
JNameRef
object v = null
object
= null
null
{
        _field = field;
        Value = v;
        NameRef = nameRef;
    }
_field = field;
_field = field
_field
field
Value = v;
Value = v
Value
v
NameRef = nameRef;
NameRef = nameRef
NameRef
nameRef
public class JRuntimeType : IJType {
    public readonly JILField[] Fields;
    private readonly JRuntimeFunction _constructors;

    public string Name { get; }
    public JTypeType Type { get; }
    public JExprFlags Modifiers => JExprFlags.None;
    public IJExpr Parent { get; internal set; }
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.VisitMethods(v);

    internal JRuntimeType(JILType type) {
        Type = type.Type;
        Name = type.Name;
        Fields = type.Fields;
        _constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());
    }

    public bool VisitVariables(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
}
: IJType
IJType
IJType
public readonly JILField[] Fields;
JILField[] Fields
JILField[]
JILField
[]

Fields
private readonly JRuntimeFunction _constructors;
JRuntimeFunction _constructors
JRuntimeFunction
_constructors
public string Name { get; }
string
{ get; }
get;
public JTypeType Type { get; }
JTypeType
{ get; }
get;
public JExprFlags Modifiers => JExprFlags.None;
JExprFlags
=> JExprFlags.None
JExprFlags.None
JExprFlags
None
public IJExpr Parent { get; internal set; }
IJExpr
{ get; internal set; }
get;
internal set;
public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
=> Fields.Visit(x => v(x))
Fields.Visit(x => v(x))
Fields.Visit
Fields
Visit
(x => v(x))
x => v(x)
x => v(x)
x
v(x)
v
(x)
x
x
public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.VisitMethods(v);
bool
(Func<IJMethod, bool> v)
Func<IJMethod, bool> v
Func<IJMethod, bool>
<IJMethod, bool>
IJMethod
bool
=> _constructors.VisitMethods(v)
_constructors.VisitMethods(v)
_constructors.VisitMethods
_constructors
VisitMethods
(v)
v
v
internal JRuntimeType(JILType type) {
        Type = type.Type;
        Name = type.Name;
        Fields = type.Fields;
        _constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());
    }
(JILType type)
JILType type
JILType
{
        Type = type.Type;
        Name = type.Name;
        Fields = type.Fields;
        _constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());
    }
Type = type.Type;
Type = type.Type
Type
type.Type
type
Type
Name = type.Name;
Name = type.Name
Name
type.Name
type
Name
Fields = type.Fields;
Fields = type.Fields
Fields
type.Fields
type
Fields
_constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());
_constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray())
_constructors
new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray())
(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray())
type.Name
type.Name
type
Name
type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray()
type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray()
type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray
type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null))
type.Constructors.Select
type.Constructors
type
Constructors
Select
(x => (IJMethod) new JRuntimeJILMethod(x, null))
x => (IJMethod) new JRuntimeJILMethod(x, null)
x => (IJMethod) new JRuntimeJILMethod(x, null)
x
(IJMethod) new JRuntimeJILMethod(x, null)
IJMethod
new JRuntimeJILMethod(x, null)
JRuntimeJILMethod
(x, null)
x
x
null
null
ToArray
()
public bool VisitVariables(Func<IJField, bool> v) => Fields.Visit(x => v(x));
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
=> Fields.Visit(x => v(x))
Fields.Visit(x => v(x))
Fields.Visit
Fields
Visit
(x => v(x))
x => v(x)
x => v(x)
x
v(x)
v
(x)
x
x
public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }
bool
(Func<IJField, object, bool> v)
Func<IJField, object, bool> v
Func<IJField, object, bool>
<IJField, object, bool>
IJField
object
bool
{
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }
for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
int i = 0
int
i = 0
= 0
0
i < Fields.Length
i
Fields.Length
Fields
Length
i++
i
if (!v(Fields[i], null))
                return false;
!v(Fields[i], null)
v(Fields[i], null)
v
(Fields[i], null)
Fields[i]
Fields[i]
Fields
[i]
i
i
null
null
return false;
false
return true;
true
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
IJField
IJExpr.
IJExpr
(JNameRef nameRef)
JNameRef nameRef
JNameRef
=> Fields[nameRef.CompileTimeNameRefIndex]
Fields[nameRef.CompileTimeNameRefIndex]
Fields
[nameRef.CompileTimeNameRefIndex]
nameRef.CompileTimeNameRefIndex
nameRef.CompileTimeNameRefIndex
nameRef
CompileTimeNameRefIndex
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
bool
IJExpr.
IJExpr
(string name, out JNameRef nameRef)
string name
string
out JNameRef nameRef
JNameRef
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
using System;
using System.Text;

namespace runtime.core
{
    public class JuliaException : Exception
    {
        protected readonly string _message;
        public JuliaException(string message) => _message = message;
        public JuliaException() => _message = "";
        
        public JuliaException(params object[] messages) {
            StringBuilder sb = new StringBuilder();
            foreach(var v in messages)
                sb.Append(v);
            _message = sb.ToString();
        }

        public override string Message => _message;
    }

    public class InternalJuliaException : JuliaException
    {
        public InternalJuliaException(string message) : base(message){}
        public InternalJuliaException() : base(){}
        
        public InternalJuliaException(params object[] messages) : base(messages){}
        
        public override string Message => "Internal Julia Exception. Please report this exception!\n" + _message;
    }
}
using System;
System
using System.Text;
System.Text
System
Text
namespace runtime.core
{
    public class JuliaException : Exception
    {
        protected readonly string _message;
        public JuliaException(string message) => _message = message;
        public JuliaException() => _message = "";
        
        public JuliaException(params object[] messages) {
            StringBuilder sb = new StringBuilder();
            foreach(var v in messages)
                sb.Append(v);
            _message = sb.ToString();
        }

        public override string Message => _message;
    }

    public class InternalJuliaException : JuliaException
    {
        public InternalJuliaException(string message) : base(message){}
        public InternalJuliaException() : base(){}
        
        public InternalJuliaException(params object[] messages) : base(messages){}
        
        public override string Message => "Internal Julia Exception. Please report this exception!\n" + _message;
    }
}
runtime.core
runtime
core
public class JuliaException : Exception
    {
        protected readonly string _message;
        public JuliaException(string message) => _message = message;
        public JuliaException() => _message = "";
        
        public JuliaException(params object[] messages) {
            StringBuilder sb = new StringBuilder();
            foreach(var v in messages)
                sb.Append(v);
            _message = sb.ToString();
        }

        public override string Message => _message;
    }
: Exception
Exception
Exception
protected readonly string _message;
string _message
string
_message
public JuliaException(string message) => _message = message;
(string message)
string message
string
=> _message = message
_message = message
_message
message
public JuliaException() => _message = "";
()
=> _message = ""
_message = ""
_message
""
public JuliaException(params object[] messages) {
            StringBuilder sb = new StringBuilder();
            foreach(var v in messages)
                sb.Append(v);
            _message = sb.ToString();
        }
(params object[] messages)
params object[] messages
object[]
object
[]

{
            StringBuilder sb = new StringBuilder();
            foreach(var v in messages)
                sb.Append(v);
            _message = sb.ToString();
        }
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder()
StringBuilder
sb = new StringBuilder()
= new StringBuilder()
new StringBuilder()
StringBuilder
()
foreach(var v in messages)
                sb.Append(v);
var
messages
sb.Append(v);
sb.Append(v)
sb.Append
sb
Append
(v)
v
v
_message = sb.ToString();
_message = sb.ToString()
_message
sb.ToString()
sb.ToString
sb
ToString
()
public override string Message => _message;
string
=> _message
_message
public class InternalJuliaException : JuliaException
    {
        public InternalJuliaException(string message) : base(message){}
        public InternalJuliaException() : base(){}
        
        public InternalJuliaException(params object[] messages) : base(messages){}
        
        public override string Message => "Internal Julia Exception. Please report this exception!\n" + _message;
    }
: JuliaException
JuliaException
JuliaException
public InternalJuliaException(string message) : base(message){}
(string message)
string message
string
: base(message)
(message)
message
message
{}
public InternalJuliaException() : base(){}
()
: base()
()
{}
public InternalJuliaException(params object[] messages) : base(messages){}
(params object[] messages)
params object[] messages
object[]
object
[]

: base(messages)
(messages)
messages
messages
{}
public override string Message => "Internal Julia Exception. Please report this exception!\n" + _message;
string
=> "Internal Julia Exception. Please report this exception!\n" + _message
"Internal Julia Exception. Please report this exception!\n" + _message
"Internal Julia Exception. Please report this exception!\n"
_message
using System;
using System.Linq.Expressions;
using System.Reflection;

namespace runtime.core
{
    public class EmptyClass{private EmptyClass(){}}
    
    public class SharpReflect
    {
        public readonly static BindingFlags FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic;
        
        public static MethodInfo GetMethod<T>(string methodName, params Type[] types) => typeof(T).GetMethod(methodName, FLAGS, null, types, null);
        public static MethodInfo GetMethod<T, T1>(string methodName) => GetMethod<T>(methodName, typeof(T1));
        public static MethodInfo GetMethod<T, T1, T2>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2));
        public static MethodInfo GetMethod<T, T1, T2, T3>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4, T5>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        public static MethodInfo GetMethod(Type t, string methodName, params Type[] types) => t.GetMethod(methodName, FLAGS, null, types, null);
         
        
        public static ConstructorInfo GetConstructor<T>(params Type[] types) => typeof(T).GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor(Type t, params Type[] types) => t.GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor<T, T1>() => GetConstructor<T>(typeof(T1));
        public static ConstructorInfo GetConstructor<T, T1, T2>() => GetConstructor<T>( typeof(T1), typeof(T2));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4, T5>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));


        public static FieldInfo GetField<T>(string name) => typeof(T).GetField(name, FLAGS);
        public static FieldInfo GetField(Type t, string name) => t.GetField(name, FLAGS);

    }

}
using System;
System
using System.Linq.Expressions;
System.Linq.Expressions
System.Linq
System
Linq
Expressions
using System.Reflection;
System.Reflection
System
Reflection
namespace runtime.core
{
    public class EmptyClass{private EmptyClass(){}}
    
    public class SharpReflect
    {
        public readonly static BindingFlags FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic;
        
        public static MethodInfo GetMethod<T>(string methodName, params Type[] types) => typeof(T).GetMethod(methodName, FLAGS, null, types, null);
        public static MethodInfo GetMethod<T, T1>(string methodName) => GetMethod<T>(methodName, typeof(T1));
        public static MethodInfo GetMethod<T, T1, T2>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2));
        public static MethodInfo GetMethod<T, T1, T2, T3>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4, T5>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        public static MethodInfo GetMethod(Type t, string methodName, params Type[] types) => t.GetMethod(methodName, FLAGS, null, types, null);
         
        
        public static ConstructorInfo GetConstructor<T>(params Type[] types) => typeof(T).GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor(Type t, params Type[] types) => t.GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor<T, T1>() => GetConstructor<T>(typeof(T1));
        public static ConstructorInfo GetConstructor<T, T1, T2>() => GetConstructor<T>( typeof(T1), typeof(T2));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4, T5>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));


        public static FieldInfo GetField<T>(string name) => typeof(T).GetField(name, FLAGS);
        public static FieldInfo GetField(Type t, string name) => t.GetField(name, FLAGS);

    }

}
runtime.core
runtime
core
public class EmptyClass{private EmptyClass(){}}
private EmptyClass(){}
()
{}
public class SharpReflect
    {
        public readonly static BindingFlags FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic;
        
        public static MethodInfo GetMethod<T>(string methodName, params Type[] types) => typeof(T).GetMethod(methodName, FLAGS, null, types, null);
        public static MethodInfo GetMethod<T, T1>(string methodName) => GetMethod<T>(methodName, typeof(T1));
        public static MethodInfo GetMethod<T, T1, T2>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2));
        public static MethodInfo GetMethod<T, T1, T2, T3>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4, T5>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        public static MethodInfo GetMethod(Type t, string methodName, params Type[] types) => t.GetMethod(methodName, FLAGS, null, types, null);
         
        
        public static ConstructorInfo GetConstructor<T>(params Type[] types) => typeof(T).GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor(Type t, params Type[] types) => t.GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor<T, T1>() => GetConstructor<T>(typeof(T1));
        public static ConstructorInfo GetConstructor<T, T1, T2>() => GetConstructor<T>( typeof(T1), typeof(T2));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4, T5>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));


        public static FieldInfo GetField<T>(string name) => typeof(T).GetField(name, FLAGS);
        public static FieldInfo GetField(Type t, string name) => t.GetField(name, FLAGS);

    }
public readonly static BindingFlags FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic;
BindingFlags FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic
BindingFlags
FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic
= BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic
BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic
BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public
BindingFlags.Instance | BindingFlags.Static
BindingFlags.Instance
BindingFlags
Instance
BindingFlags.Static
BindingFlags
Static
BindingFlags.Public
BindingFlags
Public
BindingFlags.NonPublic
BindingFlags
NonPublic
public static MethodInfo GetMethod<T>(string methodName, params Type[] types) => typeof(T).GetMethod(methodName, FLAGS, null, types, null);
MethodInfo
<T>
T
(string methodName, params Type[] types)
string methodName
string
params Type[] types
Type[]
Type
[]

=> typeof(T).GetMethod(methodName, FLAGS, null, types, null)
typeof(T).GetMethod(methodName, FLAGS, null, types, null)
typeof(T).GetMethod
typeof(T)
T
GetMethod
(methodName, FLAGS, null, types, null)
methodName
methodName
FLAGS
FLAGS
null
null
types
types
null
null
public static MethodInfo GetMethod<T, T1>(string methodName) => GetMethod<T>(methodName, typeof(T1));
MethodInfo
<T, T1>
T
T1
(string methodName)
string methodName
string
=> GetMethod<T>(methodName, typeof(T1))
GetMethod<T>(methodName, typeof(T1))
GetMethod<T>
<T>
T
(methodName, typeof(T1))
methodName
methodName
typeof(T1)
typeof(T1)
T1
public static MethodInfo GetMethod<T, T1, T2>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2));
MethodInfo
<T, T1, T2>
T
T1
T2
(string methodName)
string methodName
string
=> GetMethod<T>(methodName, typeof(T1), typeof(T2))
GetMethod<T>(methodName, typeof(T1), typeof(T2))
GetMethod<T>
<T>
T
(methodName, typeof(T1), typeof(T2))
methodName
methodName
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
public static MethodInfo GetMethod<T, T1, T2, T3>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3));
MethodInfo
<T, T1, T2, T3>
T
T1
T2
T3
(string methodName)
string methodName
string
=> GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3))
GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3))
GetMethod<T>
<T>
T
(methodName, typeof(T1), typeof(T2), typeof(T3))
methodName
methodName
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
public static MethodInfo GetMethod<T, T1, T2, T3, T4>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4));
MethodInfo
<T, T1, T2, T3, T4>
T
T1
T2
T3
T4
(string methodName)
string methodName
string
=> GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4))
GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4))
GetMethod<T>
<T>
T
(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4))
methodName
methodName
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
typeof(T4)
typeof(T4)
T4
public static MethodInfo GetMethod<T, T1, T2, T3, T4, T5>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
MethodInfo
<T, T1, T2, T3, T4, T5>
T
T1
T2
T3
T4
T5
(string methodName)
string methodName
string
=> GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
GetMethod<T>
<T>
T
(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
methodName
methodName
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
typeof(T4)
typeof(T4)
T4
typeof(T5)
typeof(T5)
T5
public static MethodInfo GetMethod(Type t, string methodName, params Type[] types) => t.GetMethod(methodName, FLAGS, null, types, null);
MethodInfo
(Type t, string methodName, params Type[] types)
Type t
Type
string methodName
string
params Type[] types
Type[]
Type
[]

=> t.GetMethod(methodName, FLAGS, null, types, null)
t.GetMethod(methodName, FLAGS, null, types, null)
t.GetMethod
t
GetMethod
(methodName, FLAGS, null, types, null)
methodName
methodName
FLAGS
FLAGS
null
null
types
types
null
null
public static ConstructorInfo GetConstructor<T>(params Type[] types) => typeof(T).GetConstructor(FLAGS, null, types, null);
ConstructorInfo
<T>
T
(params Type[] types)
params Type[] types
Type[]
Type
[]

=> typeof(T).GetConstructor(FLAGS, null, types, null)
typeof(T).GetConstructor(FLAGS, null, types, null)
typeof(T).GetConstructor
typeof(T)
T
GetConstructor
(FLAGS, null, types, null)
FLAGS
FLAGS
null
null
types
types
null
null
public static ConstructorInfo GetConstructor(Type t, params Type[] types) => t.GetConstructor(FLAGS, null, types, null);
ConstructorInfo
(Type t, params Type[] types)
Type t
Type
params Type[] types
Type[]
Type
[]

=> t.GetConstructor(FLAGS, null, types, null)
t.GetConstructor(FLAGS, null, types, null)
t.GetConstructor
t
GetConstructor
(FLAGS, null, types, null)
FLAGS
FLAGS
null
null
types
types
null
null
public static ConstructorInfo GetConstructor<T, T1>() => GetConstructor<T>(typeof(T1));
ConstructorInfo
<T, T1>
T
T1
()
=> GetConstructor<T>(typeof(T1))
GetConstructor<T>(typeof(T1))
GetConstructor<T>
<T>
T
(typeof(T1))
typeof(T1)
typeof(T1)
T1
public static ConstructorInfo GetConstructor<T, T1, T2>() => GetConstructor<T>( typeof(T1), typeof(T2));
ConstructorInfo
<T, T1, T2>
T
T1
T2
()
=> GetConstructor<T>( typeof(T1), typeof(T2))
GetConstructor<T>( typeof(T1), typeof(T2))
GetConstructor<T>
<T>
T
( typeof(T1), typeof(T2))
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
public static ConstructorInfo GetConstructor<T, T1, T2, T3>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3));
ConstructorInfo
<T, T1, T2, T3>
T
T1
T2
T3
()
=> GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3))
GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3))
GetConstructor<T>
<T>
T
( typeof(T1), typeof(T2), typeof(T3))
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4));
ConstructorInfo
<T, T1, T2, T3, T4>
T
T1
T2
T3
T4
()
=> GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4))
GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4))
GetConstructor<T>
<T>
T
( typeof(T1), typeof(T2), typeof(T3), typeof(T4))
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
typeof(T4)
typeof(T4)
T4
public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4, T5>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
ConstructorInfo
<T, T1, T2, T3, T4, T5>
T
T1
T2
T3
T4
T5
()
=> GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
GetConstructor<T>
<T>
T
( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
typeof(T4)
typeof(T4)
T4
typeof(T5)
typeof(T5)
T5
public static FieldInfo GetField<T>(string name) => typeof(T).GetField(name, FLAGS);
FieldInfo
<T>
T
(string name)
string name
string
=> typeof(T).GetField(name, FLAGS)
typeof(T).GetField(name, FLAGS)
typeof(T).GetField
typeof(T)
T
GetField
(name, FLAGS)
name
name
FLAGS
FLAGS
public static FieldInfo GetField(Type t, string name) => t.GetField(name, FLAGS);
FieldInfo
(Type t, string name)
Type t
Type
string name
string
=> t.GetField(name, FLAGS)
t.GetField(name, FLAGS)
t.GetField
t
GetField
(name, FLAGS)
name
name
FLAGS
FLAGS
using System;
using System.Reflection;
using System.Reflection.Emit;

namespace runtime.ILCompiler
{
    public struct ILTypeBuilder
    {
        public readonly TypeBuilder InternalBuilder;
        public readonly IlExprBuilder TypeInitializer;

        internal ILTypeBuilder(TypeBuilder t) {
            TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());
            InternalBuilder = t;
        }

        internal FieldBuilder CreateFieldImpl(string name, Type type, FieldAttributes extra = 0) => InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra);

        public FieldBuilder CreateField(string name, Type type, bool isConst) => CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0);
        public IlExprBuilder CreateMethod(string name, Type returnType, params Type[] parameters) =>
            new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters));

        public IlExprBuilder CreateMethod(string name) => CreateMethod(name, typeof(void));
        public IlExprBuilder CreateMethod<TOut>(string name) => CreateMethod(name, typeof(TOut));
        public IlExprBuilder CreateMethod<TOut, T1>(string name) => CreateMethod(name, typeof(TOut), typeof(T1));
        public IlExprBuilder CreateMethod<TOut, T1, T2>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4, T5>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));

        public IlExprBuilder CreateConstructor(params Type[] parameters) =>
            new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters));

        public IlExprBuilder CreateConstructor<T1>() => CreateConstructor(typeof(T1));
        public IlExprBuilder CreateConstructor<T1, T2>() => CreateConstructor(typeof(T1), typeof(T2));
        public IlExprBuilder CreateConstructor<T1, T2, T3>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4, T5>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        
        public Type Create() {
            var ti = TypeInitializer;
            ti.ReturnVoid();
            return InternalBuilder.CreateType();
        }
    }
}
using System;
System
using System.Reflection;
System.Reflection
System
Reflection
using System.Reflection.Emit;
System.Reflection.Emit
System.Reflection
System
Reflection
Emit
namespace runtime.ILCompiler
{
    public struct ILTypeBuilder
    {
        public readonly TypeBuilder InternalBuilder;
        public readonly IlExprBuilder TypeInitializer;

        internal ILTypeBuilder(TypeBuilder t) {
            TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());
            InternalBuilder = t;
        }

        internal FieldBuilder CreateFieldImpl(string name, Type type, FieldAttributes extra = 0) => InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra);

        public FieldBuilder CreateField(string name, Type type, bool isConst) => CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0);
        public IlExprBuilder CreateMethod(string name, Type returnType, params Type[] parameters) =>
            new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters));

        public IlExprBuilder CreateMethod(string name) => CreateMethod(name, typeof(void));
        public IlExprBuilder CreateMethod<TOut>(string name) => CreateMethod(name, typeof(TOut));
        public IlExprBuilder CreateMethod<TOut, T1>(string name) => CreateMethod(name, typeof(TOut), typeof(T1));
        public IlExprBuilder CreateMethod<TOut, T1, T2>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4, T5>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));

        public IlExprBuilder CreateConstructor(params Type[] parameters) =>
            new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters));

        public IlExprBuilder CreateConstructor<T1>() => CreateConstructor(typeof(T1));
        public IlExprBuilder CreateConstructor<T1, T2>() => CreateConstructor(typeof(T1), typeof(T2));
        public IlExprBuilder CreateConstructor<T1, T2, T3>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4, T5>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        
        public Type Create() {
            var ti = TypeInitializer;
            ti.ReturnVoid();
            return InternalBuilder.CreateType();
        }
    }
}
runtime.ILCompiler
runtime
ILCompiler
public struct ILTypeBuilder
    {
        public readonly TypeBuilder InternalBuilder;
        public readonly IlExprBuilder TypeInitializer;

        internal ILTypeBuilder(TypeBuilder t) {
            TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());
            InternalBuilder = t;
        }

        internal FieldBuilder CreateFieldImpl(string name, Type type, FieldAttributes extra = 0) => InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra);

        public FieldBuilder CreateField(string name, Type type, bool isConst) => CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0);
        public IlExprBuilder CreateMethod(string name, Type returnType, params Type[] parameters) =>
            new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters));

        public IlExprBuilder CreateMethod(string name) => CreateMethod(name, typeof(void));
        public IlExprBuilder CreateMethod<TOut>(string name) => CreateMethod(name, typeof(TOut));
        public IlExprBuilder CreateMethod<TOut, T1>(string name) => CreateMethod(name, typeof(TOut), typeof(T1));
        public IlExprBuilder CreateMethod<TOut, T1, T2>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4, T5>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));

        public IlExprBuilder CreateConstructor(params Type[] parameters) =>
            new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters));

        public IlExprBuilder CreateConstructor<T1>() => CreateConstructor(typeof(T1));
        public IlExprBuilder CreateConstructor<T1, T2>() => CreateConstructor(typeof(T1), typeof(T2));
        public IlExprBuilder CreateConstructor<T1, T2, T3>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4, T5>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        
        public Type Create() {
            var ti = TypeInitializer;
            ti.ReturnVoid();
            return InternalBuilder.CreateType();
        }
    }
public readonly TypeBuilder InternalBuilder;
TypeBuilder InternalBuilder
TypeBuilder
InternalBuilder
public readonly IlExprBuilder TypeInitializer;
IlExprBuilder TypeInitializer
IlExprBuilder
TypeInitializer
internal ILTypeBuilder(TypeBuilder t) {
            TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());
            InternalBuilder = t;
        }
(TypeBuilder t)
TypeBuilder t
TypeBuilder
{
            TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());
            InternalBuilder = t;
        }
TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());
TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer())
TypeInitializer
new IlExprBuilder(t.DefineTypeInitializer())
IlExprBuilder
(t.DefineTypeInitializer())
t.DefineTypeInitializer()
t.DefineTypeInitializer()
t.DefineTypeInitializer
t
DefineTypeInitializer
()
InternalBuilder = t;
InternalBuilder = t
InternalBuilder
t
internal FieldBuilder CreateFieldImpl(string name, Type type, FieldAttributes extra = 0) => InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra);
FieldBuilder
(string name, Type type, FieldAttributes extra = 0)
string name
string
Type type
Type
FieldAttributes extra = 0
FieldAttributes
= 0
0
=> InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra)
InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra)
InternalBuilder.DefineField
InternalBuilder
DefineField
(name, type, FieldAttributes.Public | extra)
name
name
type
type
FieldAttributes.Public | extra
FieldAttributes.Public | extra
FieldAttributes.Public
FieldAttributes
Public
extra
public FieldBuilder CreateField(string name, Type type, bool isConst) => CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0);
FieldBuilder
(string name, Type type, bool isConst)
string name
string
Type type
Type
bool isConst
bool
=> CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0)
CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0)
CreateFieldImpl
(name, type, isConst ? FieldAttributes.InitOnly : 0)
name
name
type
type
isConst ? FieldAttributes.InitOnly : 0
isConst ? FieldAttributes.InitOnly : 0
isConst
FieldAttributes.InitOnly
FieldAttributes
InitOnly
0
public IlExprBuilder CreateMethod(string name, Type returnType, params Type[] parameters) =>
            new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters));
IlExprBuilder
(string name, Type returnType, params Type[] parameters)
string name
string
Type returnType
Type
params Type[] parameters
Type[]
Type
[]

=>
            new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters))
new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters))
(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters))
InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters)
InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters)
InternalBuilder.DefineMethod
InternalBuilder
DefineMethod
(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters)
name
name
MethodAttributes.Static | MethodAttributes.Public
MethodAttributes.Static | MethodAttributes.Public
MethodAttributes.Static
MethodAttributes
Static
MethodAttributes.Public
MethodAttributes
Public
returnType
returnType
parameters
parameters
public IlExprBuilder CreateMethod(string name) => CreateMethod(name, typeof(void));
IlExprBuilder
(string name)
string name
string
=> CreateMethod(name, typeof(void))
CreateMethod(name, typeof(void))
CreateMethod
(name, typeof(void))
name
name
typeof(void)
typeof(void)
void
public IlExprBuilder CreateMethod<TOut>(string name) => CreateMethod(name, typeof(TOut));
IlExprBuilder
<TOut>
TOut
(string name)
string name
string
=> CreateMethod(name, typeof(TOut))
CreateMethod(name, typeof(TOut))
CreateMethod
(name, typeof(TOut))
name
name
typeof(TOut)
typeof(TOut)
TOut
public IlExprBuilder CreateMethod<TOut, T1>(string name) => CreateMethod(name, typeof(TOut), typeof(T1));
IlExprBuilder
<TOut, T1>
TOut
T1
(string name)
string name
string
=> CreateMethod(name, typeof(TOut), typeof(T1))
CreateMethod(name, typeof(TOut), typeof(T1))
CreateMethod
(name, typeof(TOut), typeof(T1))
name
name
typeof(TOut)
typeof(TOut)
TOut
typeof(T1)
typeof(T1)
T1
public IlExprBuilder CreateMethod<TOut, T1, T2>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2));
IlExprBuilder
<TOut, T1, T2>
TOut
T1
T2
(string name)
string name
string
=> CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2))
CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2))
CreateMethod
(name, typeof(TOut), typeof(T1), typeof(T2))
name
name
typeof(TOut)
typeof(TOut)
TOut
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
public IlExprBuilder CreateMethod<TOut, T1, T2, T3>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3));
IlExprBuilder
<TOut, T1, T2, T3>
TOut
T1
T2
T3
(string name)
string name
string
=> CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3))
CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3))
CreateMethod
(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3))
name
name
typeof(TOut)
typeof(TOut)
TOut
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4));
IlExprBuilder
<TOut, T1, T2, T3, T4>
TOut
T1
T2
T3
T4
(string name)
string name
string
=> CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4))
CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4))
CreateMethod
(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4))
name
name
typeof(TOut)
typeof(TOut)
TOut
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
typeof(T4)
typeof(T4)
T4
public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4, T5>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
IlExprBuilder
<TOut, T1, T2, T3, T4, T5>
TOut
T1
T2
T3
T4
T5
(string name)
string name
string
=> CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
CreateMethod
(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
name
name
typeof(TOut)
typeof(TOut)
TOut
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
typeof(T4)
typeof(T4)
T4
typeof(T5)
typeof(T5)
T5
public IlExprBuilder CreateConstructor(params Type[] parameters) =>
            new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters));
IlExprBuilder
(params Type[] parameters)
params Type[] parameters
Type[]
Type
[]

=>
            new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters))
new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters))
(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters))
InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters)
InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters)
InternalBuilder.DefineConstructor
InternalBuilder
DefineConstructor
(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters)
MethodAttributes.Static | MethodAttributes.Public
MethodAttributes.Static | MethodAttributes.Public
MethodAttributes.Static
MethodAttributes
Static
MethodAttributes.Public
MethodAttributes
Public
CallingConventions.Any
CallingConventions.Any
CallingConventions
Any
parameters
parameters
public IlExprBuilder CreateConstructor<T1>() => CreateConstructor(typeof(T1));
IlExprBuilder
<T1>
T1
()
=> CreateConstructor(typeof(T1))
CreateConstructor(typeof(T1))
CreateConstructor
(typeof(T1))
typeof(T1)
typeof(T1)
T1
public IlExprBuilder CreateConstructor<T1, T2>() => CreateConstructor(typeof(T1), typeof(T2));
IlExprBuilder
<T1, T2>
T1
T2
()
=> CreateConstructor(typeof(T1), typeof(T2))
CreateConstructor(typeof(T1), typeof(T2))
CreateConstructor
(typeof(T1), typeof(T2))
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
public IlExprBuilder CreateConstructor<T1, T2, T3>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3));
IlExprBuilder
<T1, T2, T3>
T1
T2
T3
()
=> CreateConstructor(typeof(T1), typeof(T2), typeof(T3))
CreateConstructor(typeof(T1), typeof(T2), typeof(T3))
CreateConstructor
(typeof(T1), typeof(T2), typeof(T3))
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
public IlExprBuilder CreateConstructor<T1, T2, T3, T4>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4));
IlExprBuilder
<T1, T2, T3, T4>
T1
T2
T3
T4
()
=> CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4))
CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4))
CreateConstructor
(typeof(T1), typeof(T2), typeof(T3), typeof(T4))
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
typeof(T4)
typeof(T4)
T4
public IlExprBuilder CreateConstructor<T1, T2, T3, T4, T5>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
IlExprBuilder
<T1, T2, T3, T4, T5>
T1
T2
T3
T4
T5
()
=> CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
CreateConstructor
(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))
typeof(T1)
typeof(T1)
T1
typeof(T2)
typeof(T2)
T2
typeof(T3)
typeof(T3)
T3
typeof(T4)
typeof(T4)
T4
typeof(T5)
typeof(T5)
T5
public Type Create() {
            var ti = TypeInitializer;
            ti.ReturnVoid();
            return InternalBuilder.CreateType();
        }
Type
()
{
            var ti = TypeInitializer;
            ti.ReturnVoid();
            return InternalBuilder.CreateType();
        }
var ti = TypeInitializer;
var ti = TypeInitializer
var
ti = TypeInitializer
= TypeInitializer
TypeInitializer
ti.ReturnVoid();
ti.ReturnVoid()
ti.ReturnVoid
ti
ReturnVoid
()
return InternalBuilder.CreateType();
InternalBuilder.CreateType()
InternalBuilder.CreateType
InternalBuilder
CreateType
()
namespace runtime.ILCompiler
{
    public class ILUtils
    {
        
    }
}
namespace runtime.ILCompiler
{
    public class ILUtils
    {
        
    }
}
runtime.ILCompiler
runtime
ILCompiler
public class ILUtils
    {
        
    }
namespace HyperSphere {

using Antlr4.Runtime.Misc;
using IErrorNode = Antlr4.Runtime.Tree.IErrorNode;
using ITerminalNode = Antlr4.Runtime.Tree.ITerminalNode;
using IToken = Antlr4.Runtime.IToken;
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;

/// <summary>
/// This class provides an empty implementation of <see cref="IJuliaListener"/>,
/// which can be extended to create a listener which only needs to handle a subset
/// of the available methods.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseListener : IJuliaListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterEndExpr([NotNull] JuliaParser.EndExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitEndExpr([NotNull] JuliaParser.EndExprContext context) { }

	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void EnterEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void ExitEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitTerminal([NotNull] ITerminalNode node) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitErrorNode([NotNull] IErrorNode node) { }
}
} // namespace HyperSphere

namespace HyperSphere {

using Antlr4.Runtime.Misc;
using IErrorNode = Antlr4.Runtime.Tree.IErrorNode;
using ITerminalNode = Antlr4.Runtime.Tree.ITerminalNode;
using IToken = Antlr4.Runtime.IToken;
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;

/// <summary>
/// This class provides an empty implementation of <see cref="IJuliaListener"/>,
/// which can be extended to create a listener which only needs to handle a subset
/// of the available methods.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseListener : IJuliaListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterEndExpr([NotNull] JuliaParser.EndExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitEndExpr([NotNull] JuliaParser.EndExprContext context) { }

	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void EnterEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void ExitEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitTerminal([NotNull] ITerminalNode node) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitErrorNode([NotNull] IErrorNode node) { }
}
}
HyperSphere
using Antlr4.Runtime.Misc;
Antlr4.Runtime.Misc
Antlr4.Runtime
Antlr4
Runtime
Misc
using IErrorNode = Antlr4.Runtime.Tree.IErrorNode;
IErrorNode =
IErrorNode
Antlr4.Runtime.Tree.IErrorNode
Antlr4.Runtime.Tree
Antlr4.Runtime
Antlr4
Runtime
Tree
IErrorNode
using ITerminalNode = Antlr4.Runtime.Tree.ITerminalNode;
ITerminalNode =
ITerminalNode
Antlr4.Runtime.Tree.ITerminalNode
Antlr4.Runtime.Tree
Antlr4.Runtime
Antlr4
Runtime
Tree
ITerminalNode
using IToken = Antlr4.Runtime.IToken;
IToken =
IToken
Antlr4.Runtime.IToken
Antlr4.Runtime
Antlr4
Runtime
IToken
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;
ParserRuleContext =
ParserRuleContext
Antlr4.Runtime.ParserRuleContext
Antlr4.Runtime
Antlr4
Runtime
ParserRuleContext
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseListener : IJuliaListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterEndExpr([NotNull] JuliaParser.EndExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitEndExpr([NotNull] JuliaParser.EndExprContext context) { }

	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void EnterEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void ExitEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitTerminal([NotNull] ITerminalNode node) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitErrorNode([NotNull] IErrorNode node) { }
}
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")
System.CodeDom.Compiler.GeneratedCode
System.CodeDom.Compiler
System.CodeDom
System
CodeDom
Compiler
GeneratedCode
("ANTLR", "4.10.1")
"ANTLR"
"ANTLR"
"4.10.1"
"4.10.1"
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
[System.CLSCompliant(false)]
System.CLSCompliant(false)
System.CLSCompliant
System
CLSCompliant
(false)
false
false
: IJuliaListener
IJuliaListener
IJuliaListener
public virtual void EnterScript([NotNull] JuliaParser.ScriptContext context) { }
void
([NotNull] JuliaParser.ScriptContext context)
[NotNull] JuliaParser.ScriptContext context
[NotNull]
NotNull
NotNull
JuliaParser.ScriptContext
JuliaParser
ScriptContext
{ }
public virtual void ExitScript([NotNull] JuliaParser.ScriptContext context) { }
void
([NotNull] JuliaParser.ScriptContext context)
[NotNull] JuliaParser.ScriptContext context
[NotNull]
NotNull
NotNull
JuliaParser.ScriptContext
JuliaParser
ScriptContext
{ }
public virtual void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
void
([NotNull] JuliaParser.ModuleExprContext context)
[NotNull] JuliaParser.ModuleExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprContext
JuliaParser
ModuleExprContext
{ }
public virtual void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
void
([NotNull] JuliaParser.ModuleExprContext context)
[NotNull] JuliaParser.ModuleExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprContext
JuliaParser
ModuleExprContext
{ }
public virtual void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
void
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)
[NotNull] JuliaParser.ModuleVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleVariableDeclarationContext
JuliaParser
ModuleVariableDeclarationContext
{ }
public virtual void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
void
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)
[NotNull] JuliaParser.ModuleVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleVariableDeclarationContext
JuliaParser
ModuleVariableDeclarationContext
{ }
public virtual void EnterModule([NotNull] JuliaParser.ModuleContext context) { }
void
([NotNull] JuliaParser.ModuleContext context)
[NotNull] JuliaParser.ModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleContext
JuliaParser
ModuleContext
{ }
public virtual void ExitModule([NotNull] JuliaParser.ModuleContext context) { }
void
([NotNull] JuliaParser.ModuleContext context)
[NotNull] JuliaParser.ModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleContext
JuliaParser
ModuleContext
{ }
public virtual void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
void
([NotNull] JuliaParser.ModuleExprStatementContext context)
[NotNull] JuliaParser.ModuleExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprStatementContext
JuliaParser
ModuleExprStatementContext
{ }
public virtual void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
void
([NotNull] JuliaParser.ModuleExprStatementContext context)
[NotNull] JuliaParser.ModuleExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprStatementContext
JuliaParser
ModuleExprStatementContext
{ }
public virtual void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
void
([NotNull] JuliaParser.UsingModuleContext context)
[NotNull] JuliaParser.UsingModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.UsingModuleContext
JuliaParser
UsingModuleContext
{ }
public virtual void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
void
([NotNull] JuliaParser.UsingModuleContext context)
[NotNull] JuliaParser.UsingModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.UsingModuleContext
JuliaParser
UsingModuleContext
{ }
public virtual void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
void
([NotNull] JuliaParser.ModuleRefContext context)
[NotNull] JuliaParser.ModuleRefContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleRefContext
JuliaParser
ModuleRefContext
{ }
public virtual void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
void
([NotNull] JuliaParser.ModuleRefContext context)
[NotNull] JuliaParser.ModuleRefContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleRefContext
JuliaParser
ModuleRefContext
{ }
public virtual void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
void
([NotNull] JuliaParser.ModuleIdentifierContext context)
[NotNull] JuliaParser.ModuleIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleIdentifierContext
JuliaParser
ModuleIdentifierContext
{ }
public virtual void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
void
([NotNull] JuliaParser.ModuleIdentifierContext context)
[NotNull] JuliaParser.ModuleIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleIdentifierContext
JuliaParser
ModuleIdentifierContext
{ }
public virtual void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
void
([NotNull] JuliaParser.SymbolIdentifierContext context)
[NotNull] JuliaParser.SymbolIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.SymbolIdentifierContext
JuliaParser
SymbolIdentifierContext
{ }
public virtual void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
void
([NotNull] JuliaParser.SymbolIdentifierContext context)
[NotNull] JuliaParser.SymbolIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.SymbolIdentifierContext
JuliaParser
SymbolIdentifierContext
{ }
public virtual void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
void
([NotNull] JuliaParser.AbstractStructureContext context)
[NotNull] JuliaParser.AbstractStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.AbstractStructureContext
JuliaParser
AbstractStructureContext
{ }
public virtual void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
void
([NotNull] JuliaParser.AbstractStructureContext context)
[NotNull] JuliaParser.AbstractStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.AbstractStructureContext
JuliaParser
AbstractStructureContext
{ }
public virtual void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
void
([NotNull] JuliaParser.CompositeStructureContext context)
[NotNull] JuliaParser.CompositeStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.CompositeStructureContext
JuliaParser
CompositeStructureContext
{ }
public virtual void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
void
([NotNull] JuliaParser.CompositeStructureContext context)
[NotNull] JuliaParser.CompositeStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.CompositeStructureContext
JuliaParser
CompositeStructureContext
{ }
public virtual void EnterStructure([NotNull] JuliaParser.StructureContext context) { }
void
([NotNull] JuliaParser.StructureContext context)
[NotNull] JuliaParser.StructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructureContext
JuliaParser
StructureContext
{ }
public virtual void ExitStructure([NotNull] JuliaParser.StructureContext context) { }
void
([NotNull] JuliaParser.StructureContext context)
[NotNull] JuliaParser.StructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructureContext
JuliaParser
StructureContext
{ }
public virtual void EnterStructField([NotNull] JuliaParser.StructFieldContext context) { }
void
([NotNull] JuliaParser.StructFieldContext context)
[NotNull] JuliaParser.StructFieldContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructFieldContext
JuliaParser
StructFieldContext
{ }
public virtual void ExitStructField([NotNull] JuliaParser.StructFieldContext context) { }
void
([NotNull] JuliaParser.StructFieldContext context)
[NotNull] JuliaParser.StructFieldContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructFieldContext
JuliaParser
StructFieldContext
{ }
public virtual void EnterStructItem([NotNull] JuliaParser.StructItemContext context) { }
void
([NotNull] JuliaParser.StructItemContext context)
[NotNull] JuliaParser.StructItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructItemContext
JuliaParser
StructItemContext
{ }
public virtual void ExitStructItem([NotNull] JuliaParser.StructItemContext context) { }
void
([NotNull] JuliaParser.StructItemContext context)
[NotNull] JuliaParser.StructItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructItemContext
JuliaParser
StructItemContext
{ }
public virtual void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
void
([NotNull] JuliaParser.BlockExprContext context)
[NotNull] JuliaParser.BlockExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprContext
JuliaParser
BlockExprContext
{ }
public virtual void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
void
([NotNull] JuliaParser.BlockExprContext context)
[NotNull] JuliaParser.BlockExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprContext
JuliaParser
BlockExprContext
{ }
public virtual void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
void
([NotNull] JuliaParser.BlockExprStatementContext context)
[NotNull] JuliaParser.BlockExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprStatementContext
JuliaParser
BlockExprStatementContext
{ }
public virtual void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
void
([NotNull] JuliaParser.BlockExprStatementContext context)
[NotNull] JuliaParser.BlockExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprStatementContext
JuliaParser
BlockExprStatementContext
{ }
public virtual void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
void
([NotNull] JuliaParser.BlockVariableInstatiationContext context)
[NotNull] JuliaParser.BlockVariableInstatiationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableInstatiationContext
JuliaParser
BlockVariableInstatiationContext
{ }
public virtual void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
void
([NotNull] JuliaParser.BlockVariableInstatiationContext context)
[NotNull] JuliaParser.BlockVariableInstatiationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableInstatiationContext
JuliaParser
BlockVariableInstatiationContext
{ }
public virtual void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
void
([NotNull] JuliaParser.BlockArgContext context)
[NotNull] JuliaParser.BlockArgContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockArgContext
JuliaParser
BlockArgContext
{ }
public virtual void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
void
([NotNull] JuliaParser.BlockArgContext context)
[NotNull] JuliaParser.BlockArgContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockArgContext
JuliaParser
BlockArgContext
{ }
public virtual void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
void
([NotNull] JuliaParser.BlockVariableDeclarationContext context)
[NotNull] JuliaParser.BlockVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableDeclarationContext
JuliaParser
BlockVariableDeclarationContext
{ }
public virtual void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
void
([NotNull] JuliaParser.BlockVariableDeclarationContext context)
[NotNull] JuliaParser.BlockVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableDeclarationContext
JuliaParser
BlockVariableDeclarationContext
{ }
public virtual void EnterFunction([NotNull] JuliaParser.FunctionContext context) { }
void
([NotNull] JuliaParser.FunctionContext context)
[NotNull] JuliaParser.FunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionContext
JuliaParser
FunctionContext
{ }
public virtual void ExitFunction([NotNull] JuliaParser.FunctionContext context) { }
void
([NotNull] JuliaParser.FunctionContext context)
[NotNull] JuliaParser.FunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionContext
JuliaParser
FunctionContext
{ }
public virtual void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
void
([NotNull] JuliaParser.FunctionHeaderContext context)
[NotNull] JuliaParser.FunctionHeaderContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionHeaderContext
JuliaParser
FunctionHeaderContext
{ }
public virtual void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
void
([NotNull] JuliaParser.FunctionHeaderContext context)
[NotNull] JuliaParser.FunctionHeaderContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionHeaderContext
JuliaParser
FunctionHeaderContext
{ }
public virtual void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
void
([NotNull] JuliaParser.FunctionItemContext context)
[NotNull] JuliaParser.FunctionItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionItemContext
JuliaParser
FunctionItemContext
{ }
public virtual void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
void
([NotNull] JuliaParser.FunctionItemContext context)
[NotNull] JuliaParser.FunctionItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionItemContext
JuliaParser
FunctionItemContext
{ }
public virtual void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
void
([NotNull] JuliaParser.FunctionCallContext context)
[NotNull] JuliaParser.FunctionCallContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionCallContext
JuliaParser
FunctionCallContext
{ }
public virtual void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
void
([NotNull] JuliaParser.FunctionCallContext context)
[NotNull] JuliaParser.FunctionCallContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionCallContext
JuliaParser
FunctionCallContext
{ }
public virtual void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
void
([NotNull] JuliaParser.ShortFunctionContext context)
[NotNull] JuliaParser.ShortFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.ShortFunctionContext
JuliaParser
ShortFunctionContext
{ }
public virtual void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
void
([NotNull] JuliaParser.ShortFunctionContext context)
[NotNull] JuliaParser.ShortFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.ShortFunctionContext
JuliaParser
ShortFunctionContext
{ }
public virtual void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
void
([NotNull] JuliaParser.LongFunctionContext context)
[NotNull] JuliaParser.LongFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.LongFunctionContext
JuliaParser
LongFunctionContext
{ }
public virtual void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
void
([NotNull] JuliaParser.LongFunctionContext context)
[NotNull] JuliaParser.LongFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.LongFunctionContext
JuliaParser
LongFunctionContext
{ }
public virtual void EnterTuple([NotNull] JuliaParser.TupleContext context) { }
void
([NotNull] JuliaParser.TupleContext context)
[NotNull] JuliaParser.TupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleContext
JuliaParser
TupleContext
{ }
public virtual void ExitTuple([NotNull] JuliaParser.TupleContext context) { }
void
([NotNull] JuliaParser.TupleContext context)
[NotNull] JuliaParser.TupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleContext
JuliaParser
TupleContext
{ }
public virtual void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
void
([NotNull] JuliaParser.NamedTupleContext context)
[NotNull] JuliaParser.NamedTupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.NamedTupleContext
JuliaParser
NamedTupleContext
{ }
public virtual void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
void
([NotNull] JuliaParser.NamedTupleContext context)
[NotNull] JuliaParser.NamedTupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.NamedTupleContext
JuliaParser
NamedTupleContext
{ }
public virtual void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
void
([NotNull] JuliaParser.TypetupleContext context)
[NotNull] JuliaParser.TypetupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypetupleContext
JuliaParser
TypetupleContext
{ }
public virtual void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
void
([NotNull] JuliaParser.TypetupleContext context)
[NotNull] JuliaParser.TypetupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypetupleContext
JuliaParser
TypetupleContext
{ }
public virtual void EnterTupleList([NotNull] JuliaParser.TupleListContext context) { }
void
([NotNull] JuliaParser.TupleListContext context)
[NotNull] JuliaParser.TupleListContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleListContext
JuliaParser
TupleListContext
{ }
public virtual void ExitTupleList([NotNull] JuliaParser.TupleListContext context) { }
void
([NotNull] JuliaParser.TupleListContext context)
[NotNull] JuliaParser.TupleListContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleListContext
JuliaParser
TupleListContext
{ }
public virtual void EnterTypeName([NotNull] JuliaParser.TypeNameContext context) { }
void
([NotNull] JuliaParser.TypeNameContext context)
[NotNull] JuliaParser.TypeNameContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeNameContext
JuliaParser
TypeNameContext
{ }
public virtual void ExitTypeName([NotNull] JuliaParser.TypeNameContext context) { }
void
([NotNull] JuliaParser.TypeNameContext context)
[NotNull] JuliaParser.TypeNameContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeNameContext
JuliaParser
TypeNameContext
{ }
public virtual void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
void
([NotNull] JuliaParser.ParameterizedTypeContext context)
[NotNull] JuliaParser.ParameterizedTypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.ParameterizedTypeContext
JuliaParser
ParameterizedTypeContext
{ }
public virtual void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
void
([NotNull] JuliaParser.ParameterizedTypeContext context)
[NotNull] JuliaParser.ParameterizedTypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.ParameterizedTypeContext
JuliaParser
ParameterizedTypeContext
{ }
public virtual void EnterType([NotNull] JuliaParser.TypeContext context) { }
void
([NotNull] JuliaParser.TypeContext context)
[NotNull] JuliaParser.TypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeContext
JuliaParser
TypeContext
{ }
public virtual void ExitType([NotNull] JuliaParser.TypeContext context) { }
void
([NotNull] JuliaParser.TypeContext context)
[NotNull] JuliaParser.TypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeContext
JuliaParser
TypeContext
{ }
public virtual void EnterEndExpr([NotNull] JuliaParser.EndExprContext context) { }
void
([NotNull] JuliaParser.EndExprContext context)
[NotNull] JuliaParser.EndExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.EndExprContext
JuliaParser
EndExprContext
{ }
public virtual void ExitEndExpr([NotNull] JuliaParser.EndExprContext context) { }
void
([NotNull] JuliaParser.EndExprContext context)
[NotNull] JuliaParser.EndExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.EndExprContext
JuliaParser
EndExprContext
{ }
public virtual void EnterEveryRule([NotNull] ParserRuleContext context) { }
void
([NotNull] ParserRuleContext context)
[NotNull] ParserRuleContext context
[NotNull]
NotNull
NotNull
ParserRuleContext
{ }
public virtual void ExitEveryRule([NotNull] ParserRuleContext context) { }
void
([NotNull] ParserRuleContext context)
[NotNull] ParserRuleContext context
[NotNull]
NotNull
NotNull
ParserRuleContext
{ }
public virtual void VisitTerminal([NotNull] ITerminalNode node) { }
void
([NotNull] ITerminalNode node)
[NotNull] ITerminalNode node
[NotNull]
NotNull
NotNull
ITerminalNode
{ }
public virtual void VisitErrorNode([NotNull] IErrorNode node) { }
void
([NotNull] IErrorNode node)
[NotNull] IErrorNode node
[NotNull]
NotNull
NotNull
IErrorNode
{ }
namespace HyperSphere {
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using IToken = Antlr4.Runtime.IToken;
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;

/// <summary>
/// This class provides an empty implementation of <see cref="IJuliaVisitor{Result}"/>,
/// which can be extended to create a visitor which only needs to handle a subset
/// of the available methods.
/// </summary>
/// <typeparam name="Result">The return type of the visit operation.</typeparam>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseVisitor<Result> : AbstractParseTreeVisitor<Result>, IJuliaVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitScript([NotNull] JuliaParser.ScriptContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModule([NotNull] JuliaParser.ModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructure([NotNull] JuliaParser.StructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructField([NotNull] JuliaParser.StructFieldContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructItem([NotNull] JuliaParser.StructItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunction([NotNull] JuliaParser.FunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTuple([NotNull] JuliaParser.TupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTupleList([NotNull] JuliaParser.TupleListContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitType([NotNull] JuliaParser.TypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context) { return VisitChildren(context); }
}
} // namespace HyperSphere

namespace HyperSphere {
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using IToken = Antlr4.Runtime.IToken;
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;

/// <summary>
/// This class provides an empty implementation of <see cref="IJuliaVisitor{Result}"/>,
/// which can be extended to create a visitor which only needs to handle a subset
/// of the available methods.
/// </summary>
/// <typeparam name="Result">The return type of the visit operation.</typeparam>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseVisitor<Result> : AbstractParseTreeVisitor<Result>, IJuliaVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitScript([NotNull] JuliaParser.ScriptContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModule([NotNull] JuliaParser.ModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructure([NotNull] JuliaParser.StructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructField([NotNull] JuliaParser.StructFieldContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructItem([NotNull] JuliaParser.StructItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunction([NotNull] JuliaParser.FunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTuple([NotNull] JuliaParser.TupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTupleList([NotNull] JuliaParser.TupleListContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitType([NotNull] JuliaParser.TypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context) { return VisitChildren(context); }
}
}
HyperSphere
using Antlr4.Runtime.Misc;
Antlr4.Runtime.Misc
Antlr4.Runtime
Antlr4
Runtime
Misc
using Antlr4.Runtime.Tree;
Antlr4.Runtime.Tree
Antlr4.Runtime
Antlr4
Runtime
Tree
using IToken = Antlr4.Runtime.IToken;
IToken =
IToken
Antlr4.Runtime.IToken
Antlr4.Runtime
Antlr4
Runtime
IToken
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;
ParserRuleContext =
ParserRuleContext
Antlr4.Runtime.ParserRuleContext
Antlr4.Runtime
Antlr4
Runtime
ParserRuleContext
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseVisitor<Result> : AbstractParseTreeVisitor<Result>, IJuliaVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitScript([NotNull] JuliaParser.ScriptContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModule([NotNull] JuliaParser.ModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructure([NotNull] JuliaParser.StructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructField([NotNull] JuliaParser.StructFieldContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructItem([NotNull] JuliaParser.StructItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunction([NotNull] JuliaParser.FunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTuple([NotNull] JuliaParser.TupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTupleList([NotNull] JuliaParser.TupleListContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitType([NotNull] JuliaParser.TypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context) { return VisitChildren(context); }
}
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")
System.CodeDom.Compiler.GeneratedCode
System.CodeDom.Compiler
System.CodeDom
System
CodeDom
Compiler
GeneratedCode
("ANTLR", "4.10.1")
"ANTLR"
"ANTLR"
"4.10.1"
"4.10.1"
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
[System.CLSCompliant(false)]
System.CLSCompliant(false)
System.CLSCompliant
System
CLSCompliant
(false)
false
false
<Result>
Result
: AbstractParseTreeVisitor<Result>, IJuliaVisitor<Result>
AbstractParseTreeVisitor<Result>
AbstractParseTreeVisitor<Result>
<Result>
Result
IJuliaVisitor<Result>
IJuliaVisitor<Result>
<Result>
Result
public virtual Result VisitScript([NotNull] JuliaParser.ScriptContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.ScriptContext context)
[NotNull] JuliaParser.ScriptContext context
[NotNull]
NotNull
NotNull
JuliaParser.ScriptContext
JuliaParser
ScriptContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.ModuleExprContext context)
[NotNull] JuliaParser.ModuleExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprContext
JuliaParser
ModuleExprContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)
[NotNull] JuliaParser.ModuleVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleVariableDeclarationContext
JuliaParser
ModuleVariableDeclarationContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitModule([NotNull] JuliaParser.ModuleContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.ModuleContext context)
[NotNull] JuliaParser.ModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleContext
JuliaParser
ModuleContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.ModuleExprStatementContext context)
[NotNull] JuliaParser.ModuleExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprStatementContext
JuliaParser
ModuleExprStatementContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.UsingModuleContext context)
[NotNull] JuliaParser.UsingModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.UsingModuleContext
JuliaParser
UsingModuleContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.ModuleRefContext context)
[NotNull] JuliaParser.ModuleRefContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleRefContext
JuliaParser
ModuleRefContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.ModuleIdentifierContext context)
[NotNull] JuliaParser.ModuleIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleIdentifierContext
JuliaParser
ModuleIdentifierContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.SymbolIdentifierContext context)
[NotNull] JuliaParser.SymbolIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.SymbolIdentifierContext
JuliaParser
SymbolIdentifierContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.AbstractStructureContext context)
[NotNull] JuliaParser.AbstractStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.AbstractStructureContext
JuliaParser
AbstractStructureContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.CompositeStructureContext context)
[NotNull] JuliaParser.CompositeStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.CompositeStructureContext
JuliaParser
CompositeStructureContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitStructure([NotNull] JuliaParser.StructureContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.StructureContext context)
[NotNull] JuliaParser.StructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructureContext
JuliaParser
StructureContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitStructField([NotNull] JuliaParser.StructFieldContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.StructFieldContext context)
[NotNull] JuliaParser.StructFieldContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructFieldContext
JuliaParser
StructFieldContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitStructItem([NotNull] JuliaParser.StructItemContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.StructItemContext context)
[NotNull] JuliaParser.StructItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructItemContext
JuliaParser
StructItemContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.BlockExprContext context)
[NotNull] JuliaParser.BlockExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprContext
JuliaParser
BlockExprContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.BlockExprStatementContext context)
[NotNull] JuliaParser.BlockExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprStatementContext
JuliaParser
BlockExprStatementContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.BlockVariableInstatiationContext context)
[NotNull] JuliaParser.BlockVariableInstatiationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableInstatiationContext
JuliaParser
BlockVariableInstatiationContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.BlockArgContext context)
[NotNull] JuliaParser.BlockArgContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockArgContext
JuliaParser
BlockArgContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.BlockVariableDeclarationContext context)
[NotNull] JuliaParser.BlockVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableDeclarationContext
JuliaParser
BlockVariableDeclarationContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitFunction([NotNull] JuliaParser.FunctionContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.FunctionContext context)
[NotNull] JuliaParser.FunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionContext
JuliaParser
FunctionContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.FunctionHeaderContext context)
[NotNull] JuliaParser.FunctionHeaderContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionHeaderContext
JuliaParser
FunctionHeaderContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.FunctionItemContext context)
[NotNull] JuliaParser.FunctionItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionItemContext
JuliaParser
FunctionItemContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.FunctionCallContext context)
[NotNull] JuliaParser.FunctionCallContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionCallContext
JuliaParser
FunctionCallContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.ShortFunctionContext context)
[NotNull] JuliaParser.ShortFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.ShortFunctionContext
JuliaParser
ShortFunctionContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.LongFunctionContext context)
[NotNull] JuliaParser.LongFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.LongFunctionContext
JuliaParser
LongFunctionContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitTuple([NotNull] JuliaParser.TupleContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.TupleContext context)
[NotNull] JuliaParser.TupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleContext
JuliaParser
TupleContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.NamedTupleContext context)
[NotNull] JuliaParser.NamedTupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.NamedTupleContext
JuliaParser
NamedTupleContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.TypetupleContext context)
[NotNull] JuliaParser.TypetupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypetupleContext
JuliaParser
TypetupleContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitTupleList([NotNull] JuliaParser.TupleListContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.TupleListContext context)
[NotNull] JuliaParser.TupleListContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleListContext
JuliaParser
TupleListContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.TypeNameContext context)
[NotNull] JuliaParser.TypeNameContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeNameContext
JuliaParser
TypeNameContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.ParameterizedTypeContext context)
[NotNull] JuliaParser.ParameterizedTypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.ParameterizedTypeContext
JuliaParser
ParameterizedTypeContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitType([NotNull] JuliaParser.TypeContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.TypeContext context)
[NotNull] JuliaParser.TypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeContext
JuliaParser
TypeContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
public virtual Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context) { return VisitChildren(context); }
Result
([NotNull] JuliaParser.EndExprContext context)
[NotNull] JuliaParser.EndExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.EndExprContext
JuliaParser
EndExprContext
{ return VisitChildren(context); }
return VisitChildren(context);
VisitChildren(context)
VisitChildren
(context)
context
context
namespace HyperSphere {
using System;
using System.IO;
using System.Text;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaLexer : Lexer {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public static string[] channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	};

	public static string[] modeNames = {
		"DEFAULT_MODE"
	};

	public static readonly string[] ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};


	public JuliaLexer(ICharStream input)
	: this(input, Console.Out, Console.Error) { }

	public JuliaLexer(ICharStream input, TextWriter output, TextWriter errorOutput)
	: base(input, output, errorOutput)
	{
		Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string[] ChannelNames { get { return channelNames; } }

	public override string[] ModeNames { get { return modeNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaLexer() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}
	private static int[] _serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace HyperSphere

namespace HyperSphere {
using System;
using System.IO;
using System.Text;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaLexer : Lexer {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public static string[] channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	};

	public static string[] modeNames = {
		"DEFAULT_MODE"
	};

	public static readonly string[] ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};


	public JuliaLexer(ICharStream input)
	: this(input, Console.Out, Console.Error) { }

	public JuliaLexer(ICharStream input, TextWriter output, TextWriter errorOutput)
	: base(input, output, errorOutput)
	{
		Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string[] ChannelNames { get { return channelNames; } }

	public override string[] ModeNames { get { return modeNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaLexer() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}
	private static int[] _serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
}
HyperSphere
using System;
System
using System.IO;
System.IO
System
IO
using System.Text;
System.Text
System
Text
using Antlr4.Runtime;
Antlr4.Runtime
Antlr4
Runtime
using Antlr4.Runtime.Atn;
Antlr4.Runtime.Atn
Antlr4.Runtime
Antlr4
Runtime
Atn
using Antlr4.Runtime.Misc;
Antlr4.Runtime.Misc
Antlr4.Runtime
Antlr4
Runtime
Misc
using DFA = Antlr4.Runtime.Dfa.DFA;
DFA =
DFA
Antlr4.Runtime.Dfa.DFA
Antlr4.Runtime.Dfa
Antlr4.Runtime
Antlr4
Runtime
Dfa
DFA
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaLexer : Lexer {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public static string[] channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	};

	public static string[] modeNames = {
		"DEFAULT_MODE"
	};

	public static readonly string[] ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};


	public JuliaLexer(ICharStream input)
	: this(input, Console.Out, Console.Error) { }

	public JuliaLexer(ICharStream input, TextWriter output, TextWriter errorOutput)
	: base(input, output, errorOutput)
	{
		Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string[] ChannelNames { get { return channelNames; } }

	public override string[] ModeNames { get { return modeNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaLexer() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}
	private static int[] _serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")
System.CodeDom.Compiler.GeneratedCode
System.CodeDom.Compiler
System.CodeDom
System
CodeDom
Compiler
GeneratedCode
("ANTLR", "4.10.1")
"ANTLR"
"ANTLR"
"4.10.1"
"4.10.1"
[System.CLSCompliant(false)]
System.CLSCompliant(false)
System.CLSCompliant
System
CLSCompliant
(false)
false
false
: Lexer
Lexer
Lexer
protected static DFA[] decisionToDFA;
DFA[] decisionToDFA
DFA[]
DFA
[]

decisionToDFA
protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
PredictionContextCache sharedContextCache = new PredictionContextCache()
PredictionContextCache
sharedContextCache = new PredictionContextCache()
= new PredictionContextCache()
new PredictionContextCache()
PredictionContextCache
()
public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67
int
Symbol=1
=1
1
AbstractType=2
=2
2
Using=3
=3
3
Extend=4
=4
4
Global=5
=5
5
Const=6
=6
6
Local=7
=7
7
Mutable=8
=8
8
Function=9
=9
9
Module=10
=10
10
Struct=11
=11
11
For=12
=12
12
Goto=13
=13
13
If=14
=14
14
Else=15
=15
15
ElseIf=16
=16
16
Return=17
=17
17
Continue=18
=18
18
Do=19
=19
19
End=20
=20
20
LeftParen=21
=21
21
RightParen=22
=22
22
LeftBracket=23
=23
23
RightBracket=24
=24
24
LeftBrace=25
=25
25
RightBrace=26
=26
26
And=27
=27
27
Or=28
=28
28
Caret=29
=29
29
Not=30
=30
30
Tilde=31
=31
31
Plus=32
=32
32
Minus=33
=33
33
Star=34
=34
34
Div=35
=35
35
Mod=36
=36
36
LeftShift=37
=37
37
RightShift=38
=38
38
Operator=39
=39
39
Less=40
=40
40
LessEqual=41
=41
41
Greater=42
=42
42
GreaterEqual=43
=43
43
ComparisonOperator=44
=44
44
ShortAnd=45
=45
45
ShortOr=46
=46
46
ShortcutOperator=47
=47
47
Question=48
=48
48
Colon=49
=49
49
ValueType=50
=50
50
Semi=51
=51
51
Comma=52
=52
52
Assign=53
=53
53
Arrow=54
=54
54
Dot=55
=55
55
Splat=56
=56
56
Termination=57
=57
57
AugmentedAssignment=58
=58
58
Assignment=59
=59
59
Constant=60
=60
60
Identifier=61
=61
61
IntegerConstant=62
=62
62
DecimalConstant=63
=63
63
NewLine=64
=64
64
Whitespace=65
=65
65
BlockComment=66
=66
66
LineComment=67
=67
67
public static string[] channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	};
string[] channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	}
string[]
string
[]

channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	}
= {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	}
{
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	}
"DEFAULT_TOKEN_CHANNEL"
"HIDDEN"
public static string[] modeNames = {
		"DEFAULT_MODE"
	};
string[] modeNames = {
		"DEFAULT_MODE"
	}
string[]
string
[]

modeNames = {
		"DEFAULT_MODE"
	}
= {
		"DEFAULT_MODE"
	}
{
		"DEFAULT_MODE"
	}
"DEFAULT_MODE"
public static readonly string[] ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
string[] ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
string[]
string
[]

ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
= {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
{
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
"Symbol"
"AbstractType"
"Using"
"Extend"
"Global"
"Const"
"Local"
"Mutable"
"Function"
"Module"
"Struct"
"For"
"Goto"
"If"
"Else"
"ElseIf"
"Return"
"Continue"
"Do"
"End"
"LeftParen"
"RightParen"
"LeftBracket"
"RightBracket"
"LeftBrace"
"RightBrace"
"And"
"Or"
"Caret"
"Not"
"Tilde"
"Plus"
"Minus"
"Star"
"Div"
"Mod"
"LeftShift"
"RightShift"
"Operator"
"Less"
"LessEqual"
"Greater"
"GreaterEqual"
"ComparisonOperator"
"ShortAnd"
"ShortOr"
"ShortcutOperator"
"Question"
"Colon"
"ValueType"
"Semi"
"Comma"
"Assign"
"Arrow"
"Dot"
"Splat"
"Termination"
"AugmentedAssignment"
"Assignment"
"Constant"
"Identifier"
"IntegerConstant"
"DecimalConstant"
"Digit"
"IdentifierPrefixCharacter"
"IdentifierSuffixCharacter"
"NewLine"
"Whitespace"
"BlockComment"
"LineComment"
public JuliaLexer(ICharStream input)
	: this(input, Console.Out, Console.Error) { }
(ICharStream input)
ICharStream input
ICharStream
: this(input, Console.Out, Console.Error)
(input, Console.Out, Console.Error)
input
input
Console.Out
Console.Out
Console
Out
Console.Error
Console.Error
Console
Error
{ }
public JuliaLexer(ICharStream input, TextWriter output, TextWriter errorOutput)
	: base(input, output, errorOutput)
	{
		Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
(ICharStream input, TextWriter output, TextWriter errorOutput)
ICharStream input
ICharStream
TextWriter output
TextWriter
TextWriter errorOutput
TextWriter
: base(input, output, errorOutput)
(input, output, errorOutput)
input
input
output
output
errorOutput
errorOutput
{
		Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache)
Interpreter
new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache)
LexerATNSimulator
(this, _ATN, decisionToDFA, sharedContextCache)
this
this
_ATN
_ATN
decisionToDFA
decisionToDFA
sharedContextCache
sharedContextCache
private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}
string[]
string
[]

_LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}
= {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}
{
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}
null
null
null
"'using'"
"'<:'"
"'global'"
"'const'"
"'local'"
"'mutable'"
"'function'"
"'module'"
"'struct'"
"'for'"
"'goto'"
"'if'"
"'else'"
"'elseif'"
"'return'"
"'continue'"
"'do'"
"'end'"
"'('"
"')'"
"'['"
"']'"
"'{'"
"'}'"
"'&'"
"'|'"
"'^'"
"'!'"
"'~'"
"'+'"
"'-'"
"'*'"
"'/'"
"'%'"
"'<<'"
"'>>'"
null
"'<'"
"'<='"
"'>'"
"'>='"
null
"'&&'"
"'||'"
null
"'?'"
"':'"
"'::'"
"';'"
"','"
"'='"
"'->'"
"'.'"
"'...'"
private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
string[]
string
[]

_SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
= {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
{
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
null
"Symbol"
"AbstractType"
"Using"
"Extend"
"Global"
"Const"
"Local"
"Mutable"
"Function"
"Module"
"Struct"
"For"
"Goto"
"If"
"Else"
"ElseIf"
"Return"
"Continue"
"Do"
"End"
"LeftParen"
"RightParen"
"LeftBracket"
"RightBracket"
"LeftBrace"
"RightBrace"
"And"
"Or"
"Caret"
"Not"
"Tilde"
"Plus"
"Minus"
"Star"
"Div"
"Mod"
"LeftShift"
"RightShift"
"Operator"
"Less"
"LessEqual"
"Greater"
"GreaterEqual"
"ComparisonOperator"
"ShortAnd"
"ShortOr"
"ShortcutOperator"
"Question"
"Colon"
"ValueType"
"Semi"
"Comma"
"Assign"
"Arrow"
"Dot"
"Splat"
"Termination"
"AugmentedAssignment"
"Assignment"
"Constant"
"Identifier"
"IntegerConstant"
"DecimalConstant"
"NewLine"
"Whitespace"
"BlockComment"
"LineComment"
public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);
IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames)
IVocabulary
DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames)
= new Vocabulary(_LiteralNames, _SymbolicNames)
new Vocabulary(_LiteralNames, _SymbolicNames)
Vocabulary
(_LiteralNames, _SymbolicNames)
_LiteralNames
_LiteralNames
_SymbolicNames
_SymbolicNames
[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}
[NotNull]
NotNull
NotNull
IVocabulary
{
		get
		{
			return DefaultVocabulary;
		}
	}
get
		{
			return DefaultVocabulary;
		}
{
			return DefaultVocabulary;
		}
return DefaultVocabulary;
DefaultVocabulary
public override string GrammarFileName { get { return "Julia.g4"; } }
string
{ get { return "Julia.g4"; } }
get { return "Julia.g4"; }
{ return "Julia.g4"; }
return "Julia.g4";
"Julia.g4"
public override string[] RuleNames { get { return ruleNames; } }
string[]
string
[]

{ get { return ruleNames; } }
get { return ruleNames; }
{ return ruleNames; }
return ruleNames;
ruleNames
public override string[] ChannelNames { get { return channelNames; } }
string[]
string
[]

{ get { return channelNames; } }
get { return channelNames; }
{ return channelNames; }
return channelNames;
channelNames
public override string[] ModeNames { get { return modeNames; } }
string[]
string
[]

{ get { return modeNames; } }
get { return modeNames; }
{ return modeNames; }
return modeNames;
modeNames
public override int[] SerializedAtn { get { return _serializedATN; } }
int[]
int
[]

{ get { return _serializedATN; } }
get { return _serializedATN; }
{ return _serializedATN; }
return _serializedATN;
_serializedATN
static JuliaLexer() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}
()
{
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}
decisionToDFA = new DFA[_ATN.NumberOfDecisions];
decisionToDFA = new DFA[_ATN.NumberOfDecisions]
decisionToDFA
new DFA[_ATN.NumberOfDecisions]
DFA[_ATN.NumberOfDecisions]
DFA
[_ATN.NumberOfDecisions]
_ATN.NumberOfDecisions
_ATN
NumberOfDecisions
for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
int i = 0
int
i = 0
= 0
0
i < _ATN.NumberOfDecisions
i
_ATN.NumberOfDecisions
_ATN
NumberOfDecisions
i++
i
{
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i)
decisionToDFA[i]
decisionToDFA
[i]
i
i
new DFA(_ATN.GetDecisionState(i), i)
DFA
(_ATN.GetDecisionState(i), i)
_ATN.GetDecisionState(i)
_ATN.GetDecisionState(i)
_ATN.GetDecisionState
_ATN
GetDecisionState
(i)
i
i
i
i
private static int[] _serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	};
int[] _serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	}
int[]
int
[]

_serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	}
= {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	}
{
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	}
4
0
67
450
6
-1
1
2
0
7
0
2
1
7
1
2
2
7
2
2
3
7
3
2
4
7
4
2
5
7
5
2
6
7
6
2
7
7
7
2
8
7
8
2
9
7
9
2
10
7
10
2
11
7
11
2
12
7
12
2
13
7
13
2
14
7
14
2
15
7
15
2
16
7
16
2
17
7
17
2
18
7
18
2
19
7
19
2
20
7
20
2
21
7
21
2
22
7
22
2
23
7
23
2
24
7
24
2
25
7
25
2
26
7
26
2
27
7
27
2
28
7
28
2
29
7
29
2
30
7
30
2
31
7
31
2
32
7
32
2
33
7
33
2
34
7
34
2
35
7
35
2
36
7
36
2
37
7
37
2
38
7
38
2
39
7
39
2
40
7
40
2
41
7
41
2
42
7
42
2
43
7
43
2
44
7
44
2
45
7
45
2
46
7
46
2
47
7
47
2
48
7
48
2
49
7
49
2
50
7
50
2
51
7
51
2
52
7
52
2
53
7
53
2
54
7
54
2
55
7
55
2
56
7
56
2
57
7
57
2
58
7
58
2
59
7
59
2
60
7
60
2
61
7
61
2
62
7
62
2
63
7
63
2
64
7
64
2
65
7
65
2
66
7
66
2
67
7
67
2
68
7
68
2
69
7
69
1
0
1
0
5
0
144
8
0
10
0
12
0
147
9
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
2
1
2
1
2
1
2
1
2
1
2
1
3
1
3
1
3
1
4
1
4
1
4
1
4
1
4
1
4
1
4
1
5
1
5
1
5
1
5
1
5
1
5
1
6
1
6
1
6
1
6
1
6
1
6
1
7
1
7
1
7
1
7
1
7
1
7
1
7
1
7
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
9
1
9
1
9
1
9
1
9
1
9
1
9
1
10
1
10
1
10
1
10
1
10
1
10
1
10
1
11
1
11
1
11
1
11
1
12
1
12
1
12
1
12
1
12
1
13
1
13
1
13
1
14
1
14
1
14
1
14
1
14
1
15
1
15
1
15
1
15
1
15
1
15
1
15
1
16
1
16
1
16
1
16
1
16
1
16
1
16
1
17
1
17
1
17
1
17
1
17
1
17
1
17
1
17
1
17
1
18
1
18
1
18
1
19
1
19
1
19
1
19
1
20
1
20
1
21
1
21
1
22
1
22
1
23
1
23
1
24
1
24
1
25
1
25
1
26
1
26
1
27
1
27
1
28
1
28
1
29
1
29
1
30
1
30
1
31
1
31
1
32
1
32
1
33
1
33
1
34
1
34
1
35
1
35
1
36
1
36
1
36
1
37
1
37
1
37
1
38
1
38
1
38
1
38
1
38
1
38
1
38
1
38
1
38
1
38
1
38
3
38
318
8
38
1
39
1
39
1
40
1
40
1
40
1
41
1
41
1
42
1
42
1
42
1
43
1
43
1
43
1
43
3
43
334
8
43
1
44
1
44
1
44
1
45
1
45
1
45
1
46
1
46
3
46
344
8
46
1
47
1
47
1
48
1
48
1
49
1
49
1
49
1
50
1
50
1
51
1
51
1
52
1
52
1
53
1
53
1
53
1
54
1
54
1
55
1
55
1
55
1
55
1
56
1
56
4
56
370
8
56
11
56
12
56
371
1
57
1
57
1
57
1
58
1
58
3
58
379
8
58
1
59
1
59
3
59
383
8
59
1
60
1
60
5
60
387
8
60
10
60
12
60
390
9
60
1
61
4
61
393
8
61
11
61
12
61
394
1
62
4
62
398
8
62
11
62
12
62
399
1
62
1
62
4
62
404
8
62
11
62
12
62
405
1
63
1
63
1
64
1
64
1
65
1
65
1
66
1
66
3
66
416
8
66
1
66
3
66
419
8
66
1
67
4
67
422
8
67
11
67
12
67
423
1
67
1
67
1
68
1
68
1
68
1
68
5
68
432
8
68
10
68
12
68
435
9
68
1
68
1
68
1
68
1
68
1
68
1
69
1
69
5
69
444
8
69
10
69
12
69
447
9
69
1
69
1
69
1
433
0
70
1
1
3
2
5
3
7
4
9
5
11
6
13
7
15
8
17
9
19
10
21
11
23
12
25
13
27
14
29
15
31
16
33
17
35
18
37
19
39
20
41
21
43
22
45
23
47
24
49
25
51
26
53
27
55
28
57
29
59
30
61
31
63
32
65
33
67
34
69
35
71
36
73
37
75
38
77
39
79
40
81
41
83
42
85
43
87
44
89
45
91
46
93
47
95
48
97
49
99
50
101
51
103
52
105
53
107
54
109
55
111
56
113
57
115
58
117
59
119
60
121
61
123
62
125
63
127
0
129
0
131
0
133
64
135
65
137
66
139
67
1
0
5
1
0
48
57
4
0
33
33
65
90
95
95
97
122
5
0
33
33
48
57
65
90
95
95
97
122
2
0
9
9
32
32
2
0
10
10
13
13
474
0
1
1
0
0
0
0
3
1
0
0
0
0
5
1
0
0
0
0
7
1
0
0
0
0
9
1
0
0
0
0
11
1
0
0
0
0
13
1
0
0
0
0
15
1
0
0
0
0
17
1
0
0
0
0
19
1
0
0
0
0
21
1
0
0
0
0
23
1
0
0
0
0
25
1
0
0
0
0
27
1
0
0
0
0
29
1
0
0
0
0
31
1
0
0
0
0
33
1
0
0
0
0
35
1
0
0
0
0
37
1
0
0
0
0
39
1
0
0
0
0
41
1
0
0
0
0
43
1
0
0
0
0
45
1
0
0
0
0
47
1
0
0
0
0
49
1
0
0
0
0
51
1
0
0
0
0
53
1
0
0
0
0
55
1
0
0
0
0
57
1
0
0
0
0
59
1
0
0
0
0
61
1
0
0
0
0
63
1
0
0
0
0
65
1
0
0
0
0
67
1
0
0
0
0
69
1
0
0
0
0
71
1
0
0
0
0
73
1
0
0
0
0
75
1
0
0
0
0
77
1
0
0
0
0
79
1
0
0
0
0
81
1
0
0
0
0
83
1
0
0
0
0
85
1
0
0
0
0
87
1
0
0
0
0
89
1
0
0
0
0
91
1
0
0
0
0
93
1
0
0
0
0
95
1
0
0
0
0
97
1
0
0
0
0
99
1
0
0
0
0
101
1
0
0
0
0
103
1
0
0
0
0
105
1
0
0
0
0
107
1
0
0
0
0
109
1
0
0
0
0
111
1
0
0
0
0
113
1
0
0
0
0
115
1
0
0
0
0
117
1
0
0
0
0
119
1
0
0
0
0
121
1
0
0
0
0
123
1
0
0
0
0
125
1
0
0
0
0
133
1
0
0
0
0
135
1
0
0
0
0
137
1
0
0
0
0
139
1
0
0
0
1
141
1
0
0
0
3
148
1
0
0
0
5
162
1
0
0
0
7
168
1
0
0
0
9
171
1
0
0
0
11
178
1
0
0
0
13
184
1
0
0
0
15
190
1
0
0
0
17
198
1
0
0
0
19
207
1
0
0
0
21
214
1
0
0
0
23
221
1
0
0
0
25
225
1
0
0
0
27
230
1
0
0
0
29
233
1
0
0
0
31
238
1
0
0
0
33
245
1
0
0
0
35
252
1
0
0
0
37
261
1
0
0
0
39
264
1
0
0
0
41
268
1
0
0
0
43
270
1
0
0
0
45
272
1
0
0
0
47
274
1
0
0
0
49
276
1
0
0
0
51
278
1
0
0
0
53
280
1
0
0
0
55
282
1
0
0
0
57
284
1
0
0
0
59
286
1
0
0
0
61
288
1
0
0
0
63
290
1
0
0
0
65
292
1
0
0
0
67
294
1
0
0
0
69
296
1
0
0
0
71
298
1
0
0
0
73
300
1
0
0
0
75
303
1
0
0
0
77
317
1
0
0
0
79
319
1
0
0
0
81
321
1
0
0
0
83
324
1
0
0
0
85
326
1
0
0
0
87
333
1
0
0
0
89
335
1
0
0
0
91
338
1
0
0
0
93
343
1
0
0
0
95
345
1
0
0
0
97
347
1
0
0
0
99
349
1
0
0
0
101
352
1
0
0
0
103
354
1
0
0
0
105
356
1
0
0
0
107
358
1
0
0
0
109
361
1
0
0
0
111
363
1
0
0
0
113
369
1
0
0
0
115
373
1
0
0
0
117
378
1
0
0
0
119
382
1
0
0
0
121
384
1
0
0
0
123
392
1
0
0
0
125
397
1
0
0
0
127
407
1
0
0
0
129
409
1
0
0
0
131
411
1
0
0
0
133
418
1
0
0
0
135
421
1
0
0
0
137
427
1
0
0
0
139
441
1
0
0
0
141
145
3
97
48
0
142
144
3
131
65
0
143
142
1
0
0
0
144
147
1
0
0
0
145
143
1
0
0
0
145
146
1
0
0
0
146
2
1
0
0
0
147
145
1
0
0
0
148
149
5
97
0
0
149
150
5
98
0
0
150
151
5
115
0
0
151
152
5
116
0
0
152
153
5
114
0
0
153
154
5
97
0
0
154
155
5
99
0
0
155
156
5
116
0
0
156
157
1
0
0
0
157
158
5
116
0
0
158
159
5
121
0
0
159
160
5
112
0
0
160
161
5
101
0
0
161
4
1
0
0
0
162
163
5
117
0
0
163
164
5
115
0
0
164
165
5
105
0
0
165
166
5
110
0
0
166
167
5
103
0
0
167
6
1
0
0
0
168
169
5
60
0
0
169
170
5
58
0
0
170
8
1
0
0
0
171
172
5
103
0
0
172
173
5
108
0
0
173
174
5
111
0
0
174
175
5
98
0
0
175
176
5
97
0
0
176
177
5
108
0
0
177
10
1
0
0
0
178
179
5
99
0
0
179
180
5
111
0
0
180
181
5
110
0
0
181
182
5
115
0
0
182
183
5
116
0
0
183
12
1
0
0
0
184
185
5
108
0
0
185
186
5
111
0
0
186
187
5
99
0
0
187
188
5
97
0
0
188
189
5
108
0
0
189
14
1
0
0
0
190
191
5
109
0
0
191
192
5
117
0
0
192
193
5
116
0
0
193
194
5
97
0
0
194
195
5
98
0
0
195
196
5
108
0
0
196
197
5
101
0
0
197
16
1
0
0
0
198
199
5
102
0
0
199
200
5
117
0
0
200
201
5
110
0
0
201
202
5
99
0
0
202
203
5
116
0
0
203
204
5
105
0
0
204
205
5
111
0
0
205
206
5
110
0
0
206
18
1
0
0
0
207
208
5
109
0
0
208
209
5
111
0
0
209
210
5
100
0
0
210
211
5
117
0
0
211
212
5
108
0
0
212
213
5
101
0
0
213
20
1
0
0
0
214
215
5
115
0
0
215
216
5
116
0
0
216
217
5
114
0
0
217
218
5
117
0
0
218
219
5
99
0
0
219
220
5
116
0
0
220
22
1
0
0
0
221
222
5
102
0
0
222
223
5
111
0
0
223
224
5
114
0
0
224
24
1
0
0
0
225
226
5
103
0
0
226
227
5
111
0
0
227
228
5
116
0
0
228
229
5
111
0
0
229
26
1
0
0
0
230
231
5
105
0
0
231
232
5
102
0
0
232
28
1
0
0
0
233
234
5
101
0
0
234
235
5
108
0
0
235
236
5
115
0
0
236
237
5
101
0
0
237
30
1
0
0
0
238
239
5
101
0
0
239
240
5
108
0
0
240
241
5
115
0
0
241
242
5
101
0
0
242
243
5
105
0
0
243
244
5
102
0
0
244
32
1
0
0
0
245
246
5
114
0
0
246
247
5
101
0
0
247
248
5
116
0
0
248
249
5
117
0
0
249
250
5
114
0
0
250
251
5
110
0
0
251
34
1
0
0
0
252
253
5
99
0
0
253
254
5
111
0
0
254
255
5
110
0
0
255
256
5
116
0
0
256
257
5
105
0
0
257
258
5
110
0
0
258
259
5
117
0
0
259
260
5
101
0
0
260
36
1
0
0
0
261
262
5
100
0
0
262
263
5
111
0
0
263
38
1
0
0
0
264
265
5
101
0
0
265
266
5
110
0
0
266
267
5
100
0
0
267
40
1
0
0
0
268
269
5
40
0
0
269
42
1
0
0
0
270
271
5
41
0
0
271
44
1
0
0
0
272
273
5
91
0
0
273
46
1
0
0
0
274
275
5
93
0
0
275
48
1
0
0
0
276
277
5
123
0
0
277
50
1
0
0
0
278
279
5
125
0
0
279
52
1
0
0
0
280
281
5
38
0
0
281
54
1
0
0
0
282
283
5
124
0
0
283
56
1
0
0
0
284
285
5
94
0
0
285
58
1
0
0
0
286
287
5
33
0
0
287
60
1
0
0
0
288
289
5
126
0
0
289
62
1
0
0
0
290
291
5
43
0
0
291
64
1
0
0
0
292
293
5
45
0
0
293
66
1
0
0
0
294
295
5
42
0
0
295
68
1
0
0
0
296
297
5
47
0
0
297
70
1
0
0
0
298
299
5
37
0
0
299
72
1
0
0
0
300
301
5
60
0
0
301
302
5
60
0
0
302
74
1
0
0
0
303
304
5
62
0
0
304
305
5
62
0
0
305
76
1
0
0
0
306
318
3
53
26
0
307
318
3
55
27
0
308
318
3
57
28
0
309
318
3
59
29
0
310
318
3
61
30
0
311
318
3
63
31
0
312
318
3
65
32
0
313
318
3
69
34
0
314
318
3
71
35
0
315
318
3
73
36
0
316
318
3
75
37
0
317
306
1
0
0
0
317
307
1
0
0
0
317
308
1
0
0
0
317
309
1
0
0
0
317
310
1
0
0
0
317
311
1
0
0
0
317
312
1
0
0
0
317
313
1
0
0
0
317
314
1
0
0
0
317
315
1
0
0
0
317
316
1
0
0
0
318
78
1
0
0
0
319
320
5
60
0
0
320
80
1
0
0
0
321
322
5
60
0
0
322
323
5
61
0
0
323
82
1
0
0
0
324
325
5
62
0
0
325
84
1
0
0
0
326
327
5
62
0
0
327
328
5
61
0
0
328
86
1
0
0
0
329
334
3
79
39
0
330
334
3
81
40
0
331
334
3
83
41
0
332
334
3
85
42
0
333
329
1
0
0
0
333
330
1
0
0
0
333
331
1
0
0
0
333
332
1
0
0
0
334
88
1
0
0
0
335
336
5
38
0
0
336
337
5
38
0
0
337
90
1
0
0
0
338
339
5
124
0
0
339
340
5
124
0
0
340
92
1
0
0
0
341
344
3
89
44
0
342
344
3
91
45
0
343
341
1
0
0
0
343
342
1
0
0
0
344
94
1
0
0
0
345
346
5
63
0
0
346
96
1
0
0
0
347
348
5
58
0
0
348
98
1
0
0
0
349
350
5
58
0
0
350
351
5
58
0
0
351
100
1
0
0
0
352
353
5
59
0
0
353
102
1
0
0
0
354
355
5
44
0
0
355
104
1
0
0
0
356
357
5
61
0
0
357
106
1
0
0
0
358
359
5
45
0
0
359
360
5
62
0
0
360
108
1
0
0
0
361
362
5
46
0
0
362
110
1
0
0
0
363
364
5
46
0
0
364
365
5
46
0
0
365
366
5
46
0
0
366
112
1
0
0
0
367
370
3
133
66
0
368
370
3
101
50
0
369
367
1
0
0
0
369
368
1
0
0
0
370
371
1
0
0
0
371
369
1
0
0
0
371
372
1
0
0
0
372
114
1
0
0
0
373
374
3
77
38
0
374
375
3
117
58
0
375
116
1
0
0
0
376
379
3
105
52
0
377
379
3
115
57
0
378
376
1
0
0
0
378
377
1
0
0
0
379
118
1
0
0
0
380
383
3
123
61
0
381
383
3
125
62
0
382
380
1
0
0
0
382
381
1
0
0
0
383
120
1
0
0
0
384
388
3
129
64
0
385
387
3
131
65
0
386
385
1
0
0
0
387
390
1
0
0
0
388
386
1
0
0
0
388
389
1
0
0
0
389
122
1
0
0
0
390
388
1
0
0
0
391
393
3
127
63
0
392
391
1
0
0
0
393
394
1
0
0
0
394
392
1
0
0
0
394
395
1
0
0
0
395
124
1
0
0
0
396
398
3
127
63
0
397
396
1
0
0
0
398
399
1
0
0
0
399
397
1
0
0
0
399
400
1
0
0
0
400
401
1
0
0
0
401
403
3
109
54
0
402
404
3
127
63
0
403
402
1
0
0
0
404
405
1
0
0
0
405
403
1
0
0
0
405
406
1
0
0
0
406
126
1
0
0
0
407
408
7
0
0
0
408
128
1
0
0
0
409
410
7
1
0
0
410
130
1
0
0
0
411
412
7
2
0
0
412
132
1
0
0
0
413
415
5
13
0
0
414
416
5
10
0
0
415
414
1
0
0
0
415
416
1
0
0
0
416
419
1
0
0
0
417
419
5
10
0
0
418
413
1
0
0
0
418
417
1
0
0
0
419
134
1
0
0
0
420
422
7
3
0
0
421
420
1
0
0
0
422
423
1
0
0
0
423
421
1
0
0
0
423
424
1
0
0
0
424
425
1
0
0
0
425
426
6
67
0
0
426
136
1
0
0
0
427
428
5
35
0
0
428
429
5
61
0
0
429
433
1
0
0
0
430
432
9
0
0
0
431
430
1
0
0
0
432
435
1
0
0
0
433
434
1
0
0
0
433
431
1
0
0
0
434
436
1
0
0
0
435
433
1
0
0
0
436
437
5
61
0
0
437
438
5
35
0
0
438
439
1
0
0
0
439
440
6
68
0
0
440
138
1
0
0
0
441
445
5
35
0
0
442
444
8
4
0
0
443
442
1
0
0
0
444
447
1
0
0
0
445
443
1
0
0
0
445
446
1
0
0
0
446
448
1
0
0
0
447
445
1
0
0
0
448
449
6
69
0
0
449
140
1
0
0
0
18
0
145
317
333
343
369
371
378
382
388
394
399
405
415
418
423
433
445
1
6
0
0
public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);
ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN)
ATN
_ATN =
		new ATNDeserializer().Deserialize(_serializedATN)
=
		new ATNDeserializer().Deserialize(_serializedATN)
new ATNDeserializer().Deserialize(_serializedATN)
new ATNDeserializer().Deserialize
new ATNDeserializer()
ATNDeserializer
()
Deserialize
(_serializedATN)
_serializedATN
_serializedATN
namespace HyperSphere {
using Antlr4.Runtime.Misc;
using IParseTreeListener = Antlr4.Runtime.Tree.IParseTreeListener;
using IToken = Antlr4.Runtime.IToken;

/// <summary>
/// This interface defines a complete listener for a parse tree produced by
/// <see cref="JuliaParser"/>.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaListener : IParseTreeListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterEndExpr([NotNull] JuliaParser.EndExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitEndExpr([NotNull] JuliaParser.EndExprContext context);
}
} // namespace HyperSphere

namespace HyperSphere {
using Antlr4.Runtime.Misc;
using IParseTreeListener = Antlr4.Runtime.Tree.IParseTreeListener;
using IToken = Antlr4.Runtime.IToken;

/// <summary>
/// This interface defines a complete listener for a parse tree produced by
/// <see cref="JuliaParser"/>.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaListener : IParseTreeListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterEndExpr([NotNull] JuliaParser.EndExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitEndExpr([NotNull] JuliaParser.EndExprContext context);
}
}
HyperSphere
using Antlr4.Runtime.Misc;
Antlr4.Runtime.Misc
Antlr4.Runtime
Antlr4
Runtime
Misc
using IParseTreeListener = Antlr4.Runtime.Tree.IParseTreeListener;
IParseTreeListener =
IParseTreeListener
Antlr4.Runtime.Tree.IParseTreeListener
Antlr4.Runtime.Tree
Antlr4.Runtime
Antlr4
Runtime
Tree
IParseTreeListener
using IToken = Antlr4.Runtime.IToken;
IToken =
IToken
Antlr4.Runtime.IToken
Antlr4.Runtime
Antlr4
Runtime
IToken
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaListener : IParseTreeListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterEndExpr([NotNull] JuliaParser.EndExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitEndExpr([NotNull] JuliaParser.EndExprContext context);
}
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")
System.CodeDom.Compiler.GeneratedCode
System.CodeDom.Compiler
System.CodeDom
System
CodeDom
Compiler
GeneratedCode
("ANTLR", "4.10.1")
"ANTLR"
"ANTLR"
"4.10.1"
"4.10.1"
[System.CLSCompliant(false)]
System.CLSCompliant(false)
System.CLSCompliant
System
CLSCompliant
(false)
false
false
: IParseTreeListener
IParseTreeListener
IParseTreeListener
void EnterScript([NotNull] JuliaParser.ScriptContext context);
void
([NotNull] JuliaParser.ScriptContext context)
[NotNull] JuliaParser.ScriptContext context
[NotNull]
NotNull
NotNull
JuliaParser.ScriptContext
JuliaParser
ScriptContext
void ExitScript([NotNull] JuliaParser.ScriptContext context);
void
([NotNull] JuliaParser.ScriptContext context)
[NotNull] JuliaParser.ScriptContext context
[NotNull]
NotNull
NotNull
JuliaParser.ScriptContext
JuliaParser
ScriptContext
void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
void
([NotNull] JuliaParser.ModuleExprContext context)
[NotNull] JuliaParser.ModuleExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprContext
JuliaParser
ModuleExprContext
void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
void
([NotNull] JuliaParser.ModuleExprContext context)
[NotNull] JuliaParser.ModuleExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprContext
JuliaParser
ModuleExprContext
void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
void
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)
[NotNull] JuliaParser.ModuleVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleVariableDeclarationContext
JuliaParser
ModuleVariableDeclarationContext
void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
void
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)
[NotNull] JuliaParser.ModuleVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleVariableDeclarationContext
JuliaParser
ModuleVariableDeclarationContext
void EnterModule([NotNull] JuliaParser.ModuleContext context);
void
([NotNull] JuliaParser.ModuleContext context)
[NotNull] JuliaParser.ModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleContext
JuliaParser
ModuleContext
void ExitModule([NotNull] JuliaParser.ModuleContext context);
void
([NotNull] JuliaParser.ModuleContext context)
[NotNull] JuliaParser.ModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleContext
JuliaParser
ModuleContext
void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
void
([NotNull] JuliaParser.ModuleExprStatementContext context)
[NotNull] JuliaParser.ModuleExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprStatementContext
JuliaParser
ModuleExprStatementContext
void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
void
([NotNull] JuliaParser.ModuleExprStatementContext context)
[NotNull] JuliaParser.ModuleExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprStatementContext
JuliaParser
ModuleExprStatementContext
void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context);
void
([NotNull] JuliaParser.UsingModuleContext context)
[NotNull] JuliaParser.UsingModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.UsingModuleContext
JuliaParser
UsingModuleContext
void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
void
([NotNull] JuliaParser.UsingModuleContext context)
[NotNull] JuliaParser.UsingModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.UsingModuleContext
JuliaParser
UsingModuleContext
void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context);
void
([NotNull] JuliaParser.ModuleRefContext context)
[NotNull] JuliaParser.ModuleRefContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleRefContext
JuliaParser
ModuleRefContext
void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
void
([NotNull] JuliaParser.ModuleRefContext context)
[NotNull] JuliaParser.ModuleRefContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleRefContext
JuliaParser
ModuleRefContext
void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
void
([NotNull] JuliaParser.ModuleIdentifierContext context)
[NotNull] JuliaParser.ModuleIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleIdentifierContext
JuliaParser
ModuleIdentifierContext
void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
void
([NotNull] JuliaParser.ModuleIdentifierContext context)
[NotNull] JuliaParser.ModuleIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleIdentifierContext
JuliaParser
ModuleIdentifierContext
void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
void
([NotNull] JuliaParser.SymbolIdentifierContext context)
[NotNull] JuliaParser.SymbolIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.SymbolIdentifierContext
JuliaParser
SymbolIdentifierContext
void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
void
([NotNull] JuliaParser.SymbolIdentifierContext context)
[NotNull] JuliaParser.SymbolIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.SymbolIdentifierContext
JuliaParser
SymbolIdentifierContext
void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
void
([NotNull] JuliaParser.AbstractStructureContext context)
[NotNull] JuliaParser.AbstractStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.AbstractStructureContext
JuliaParser
AbstractStructureContext
void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
void
([NotNull] JuliaParser.AbstractStructureContext context)
[NotNull] JuliaParser.AbstractStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.AbstractStructureContext
JuliaParser
AbstractStructureContext
void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
void
([NotNull] JuliaParser.CompositeStructureContext context)
[NotNull] JuliaParser.CompositeStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.CompositeStructureContext
JuliaParser
CompositeStructureContext
void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
void
([NotNull] JuliaParser.CompositeStructureContext context)
[NotNull] JuliaParser.CompositeStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.CompositeStructureContext
JuliaParser
CompositeStructureContext
void EnterStructure([NotNull] JuliaParser.StructureContext context);
void
([NotNull] JuliaParser.StructureContext context)
[NotNull] JuliaParser.StructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructureContext
JuliaParser
StructureContext
void ExitStructure([NotNull] JuliaParser.StructureContext context);
void
([NotNull] JuliaParser.StructureContext context)
[NotNull] JuliaParser.StructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructureContext
JuliaParser
StructureContext
void EnterStructField([NotNull] JuliaParser.StructFieldContext context);
void
([NotNull] JuliaParser.StructFieldContext context)
[NotNull] JuliaParser.StructFieldContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructFieldContext
JuliaParser
StructFieldContext
void ExitStructField([NotNull] JuliaParser.StructFieldContext context);
void
([NotNull] JuliaParser.StructFieldContext context)
[NotNull] JuliaParser.StructFieldContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructFieldContext
JuliaParser
StructFieldContext
void EnterStructItem([NotNull] JuliaParser.StructItemContext context);
void
([NotNull] JuliaParser.StructItemContext context)
[NotNull] JuliaParser.StructItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructItemContext
JuliaParser
StructItemContext
void ExitStructItem([NotNull] JuliaParser.StructItemContext context);
void
([NotNull] JuliaParser.StructItemContext context)
[NotNull] JuliaParser.StructItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructItemContext
JuliaParser
StructItemContext
void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context);
void
([NotNull] JuliaParser.BlockExprContext context)
[NotNull] JuliaParser.BlockExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprContext
JuliaParser
BlockExprContext
void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
void
([NotNull] JuliaParser.BlockExprContext context)
[NotNull] JuliaParser.BlockExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprContext
JuliaParser
BlockExprContext
void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
void
([NotNull] JuliaParser.BlockExprStatementContext context)
[NotNull] JuliaParser.BlockExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprStatementContext
JuliaParser
BlockExprStatementContext
void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
void
([NotNull] JuliaParser.BlockExprStatementContext context)
[NotNull] JuliaParser.BlockExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprStatementContext
JuliaParser
BlockExprStatementContext
void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
void
([NotNull] JuliaParser.BlockVariableInstatiationContext context)
[NotNull] JuliaParser.BlockVariableInstatiationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableInstatiationContext
JuliaParser
BlockVariableInstatiationContext
void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
void
([NotNull] JuliaParser.BlockVariableInstatiationContext context)
[NotNull] JuliaParser.BlockVariableInstatiationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableInstatiationContext
JuliaParser
BlockVariableInstatiationContext
void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context);
void
([NotNull] JuliaParser.BlockArgContext context)
[NotNull] JuliaParser.BlockArgContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockArgContext
JuliaParser
BlockArgContext
void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context);
void
([NotNull] JuliaParser.BlockArgContext context)
[NotNull] JuliaParser.BlockArgContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockArgContext
JuliaParser
BlockArgContext
void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
void
([NotNull] JuliaParser.BlockVariableDeclarationContext context)
[NotNull] JuliaParser.BlockVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableDeclarationContext
JuliaParser
BlockVariableDeclarationContext
void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
void
([NotNull] JuliaParser.BlockVariableDeclarationContext context)
[NotNull] JuliaParser.BlockVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableDeclarationContext
JuliaParser
BlockVariableDeclarationContext
void EnterFunction([NotNull] JuliaParser.FunctionContext context);
void
([NotNull] JuliaParser.FunctionContext context)
[NotNull] JuliaParser.FunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionContext
JuliaParser
FunctionContext
void ExitFunction([NotNull] JuliaParser.FunctionContext context);
void
([NotNull] JuliaParser.FunctionContext context)
[NotNull] JuliaParser.FunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionContext
JuliaParser
FunctionContext
void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
void
([NotNull] JuliaParser.FunctionHeaderContext context)
[NotNull] JuliaParser.FunctionHeaderContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionHeaderContext
JuliaParser
FunctionHeaderContext
void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
void
([NotNull] JuliaParser.FunctionHeaderContext context)
[NotNull] JuliaParser.FunctionHeaderContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionHeaderContext
JuliaParser
FunctionHeaderContext
void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
void
([NotNull] JuliaParser.FunctionItemContext context)
[NotNull] JuliaParser.FunctionItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionItemContext
JuliaParser
FunctionItemContext
void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
void
([NotNull] JuliaParser.FunctionItemContext context)
[NotNull] JuliaParser.FunctionItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionItemContext
JuliaParser
FunctionItemContext
void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
void
([NotNull] JuliaParser.FunctionCallContext context)
[NotNull] JuliaParser.FunctionCallContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionCallContext
JuliaParser
FunctionCallContext
void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
void
([NotNull] JuliaParser.FunctionCallContext context)
[NotNull] JuliaParser.FunctionCallContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionCallContext
JuliaParser
FunctionCallContext
void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
void
([NotNull] JuliaParser.ShortFunctionContext context)
[NotNull] JuliaParser.ShortFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.ShortFunctionContext
JuliaParser
ShortFunctionContext
void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
void
([NotNull] JuliaParser.ShortFunctionContext context)
[NotNull] JuliaParser.ShortFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.ShortFunctionContext
JuliaParser
ShortFunctionContext
void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context);
void
([NotNull] JuliaParser.LongFunctionContext context)
[NotNull] JuliaParser.LongFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.LongFunctionContext
JuliaParser
LongFunctionContext
void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
void
([NotNull] JuliaParser.LongFunctionContext context)
[NotNull] JuliaParser.LongFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.LongFunctionContext
JuliaParser
LongFunctionContext
void EnterTuple([NotNull] JuliaParser.TupleContext context);
void
([NotNull] JuliaParser.TupleContext context)
[NotNull] JuliaParser.TupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleContext
JuliaParser
TupleContext
void ExitTuple([NotNull] JuliaParser.TupleContext context);
void
([NotNull] JuliaParser.TupleContext context)
[NotNull] JuliaParser.TupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleContext
JuliaParser
TupleContext
void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
void
([NotNull] JuliaParser.NamedTupleContext context)
[NotNull] JuliaParser.NamedTupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.NamedTupleContext
JuliaParser
NamedTupleContext
void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
void
([NotNull] JuliaParser.NamedTupleContext context)
[NotNull] JuliaParser.NamedTupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.NamedTupleContext
JuliaParser
NamedTupleContext
void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context);
void
([NotNull] JuliaParser.TypetupleContext context)
[NotNull] JuliaParser.TypetupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypetupleContext
JuliaParser
TypetupleContext
void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context);
void
([NotNull] JuliaParser.TypetupleContext context)
[NotNull] JuliaParser.TypetupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypetupleContext
JuliaParser
TypetupleContext
void EnterTupleList([NotNull] JuliaParser.TupleListContext context);
void
([NotNull] JuliaParser.TupleListContext context)
[NotNull] JuliaParser.TupleListContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleListContext
JuliaParser
TupleListContext
void ExitTupleList([NotNull] JuliaParser.TupleListContext context);
void
([NotNull] JuliaParser.TupleListContext context)
[NotNull] JuliaParser.TupleListContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleListContext
JuliaParser
TupleListContext
void EnterTypeName([NotNull] JuliaParser.TypeNameContext context);
void
([NotNull] JuliaParser.TypeNameContext context)
[NotNull] JuliaParser.TypeNameContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeNameContext
JuliaParser
TypeNameContext
void ExitTypeName([NotNull] JuliaParser.TypeNameContext context);
void
([NotNull] JuliaParser.TypeNameContext context)
[NotNull] JuliaParser.TypeNameContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeNameContext
JuliaParser
TypeNameContext
void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
void
([NotNull] JuliaParser.ParameterizedTypeContext context)
[NotNull] JuliaParser.ParameterizedTypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.ParameterizedTypeContext
JuliaParser
ParameterizedTypeContext
void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
void
([NotNull] JuliaParser.ParameterizedTypeContext context)
[NotNull] JuliaParser.ParameterizedTypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.ParameterizedTypeContext
JuliaParser
ParameterizedTypeContext
void EnterType([NotNull] JuliaParser.TypeContext context);
void
([NotNull] JuliaParser.TypeContext context)
[NotNull] JuliaParser.TypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeContext
JuliaParser
TypeContext
void ExitType([NotNull] JuliaParser.TypeContext context);
void
([NotNull] JuliaParser.TypeContext context)
[NotNull] JuliaParser.TypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeContext
JuliaParser
TypeContext
void EnterEndExpr([NotNull] JuliaParser.EndExprContext context);
void
([NotNull] JuliaParser.EndExprContext context)
[NotNull] JuliaParser.EndExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.EndExprContext
JuliaParser
EndExprContext
void ExitEndExpr([NotNull] JuliaParser.EndExprContext context);
void
([NotNull] JuliaParser.EndExprContext context)
[NotNull] JuliaParser.EndExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.EndExprContext
JuliaParser
EndExprContext
namespace HyperSphere {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public const int
		RULE_script = 0, RULE_moduleExpr = 1, RULE_moduleVariableDeclaration = 2, 
		RULE_module = 3, RULE_moduleExprStatement = 4, RULE_usingModule = 5, RULE_moduleRef = 6, 
		RULE_moduleIdentifier = 7, RULE_symbolIdentifier = 8, RULE_abstractStructure = 9, 
		RULE_compositeStructure = 10, RULE_structure = 11, RULE_structField = 12, 
		RULE_structItem = 13, RULE_blockExpr = 14, RULE_blockExprStatement = 15, 
		RULE_blockVariableInstatiation = 16, RULE_blockArg = 17, RULE_blockVariableDeclaration = 18, 
		RULE_function = 19, RULE_functionHeader = 20, RULE_functionItem = 21, 
		RULE_functionCall = 22, RULE_shortFunction = 23, RULE_longFunction = 24, 
		RULE_tuple = 25, RULE_namedTuple = 26, RULE_typetuple = 27, RULE_tupleList = 28, 
		RULE_typeName = 29, RULE_parameterizedType = 30, RULE_type = 31, RULE_endExpr = 32;
	public static readonly string[] ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public JuliaParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public JuliaParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ScriptContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(JuliaParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext[] moduleExprStatement() {
			return GetRuleContexts<ModuleExprStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext moduleExprStatement(int i) {
			return GetRuleContext<ModuleExprStatementContext>(i);
		}
		public ScriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_script; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptContext script() {
		ScriptContext _localctx = new ScriptContext(Context, State);
		EnterRule(_localctx, 0, RULE_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructureContext structure() {
			return GetRuleContext<StructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleVariableDeclarationContext moduleVariableDeclaration() {
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleContext module() {
			return GetRuleContext<ModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingModuleContext usingModule() {
			return GetRuleContext<UsingModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprContext moduleExpr() {
		ModuleExprContext _localctx = new ModuleExprContext(Context, State);
		EnterRule(_localctx, 2, RULE_moduleExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		public ModuleVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleVariableDeclarationContext moduleVariableDeclaration() {
		ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Module() { return GetToken(JuliaParser.Module, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext[] moduleExpr() {
			return GetRuleContexts<ModuleExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr(int i) {
			return GetRuleContext<ModuleExprContext>(i);
		}
		public ModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_module; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleContext module() {
		ModuleContext _localctx = new ModuleContext(Context, State);
		EnterRule(_localctx, 6, RULE_module);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprStatementContext moduleExprStatement() {
		ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_moduleExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Using() { return GetToken(JuliaParser.Using, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		public UsingModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingModule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UsingModuleContext usingModule() {
		UsingModuleContext _localctx = new UsingModuleContext(Context, State);
		EnterRule(_localctx, 10, RULE_usingModule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleRefContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(JuliaParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(JuliaParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(JuliaParser.Dot); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(JuliaParser.Dot, i);
		}
		public ModuleRefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleRef; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleRefContext moduleRef() {
		ModuleRefContext _localctx = new ModuleRefContext(Context, State);
		EnterRule(_localctx, 12, RULE_moduleRef);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(JuliaParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public ModuleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleIdentifierContext moduleIdentifier() {
		ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);
		EnterRule(_localctx, 14, RULE_moduleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleIdentifierContext moduleIdentifier() {
			return GetRuleContext<ModuleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public SymbolIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolIdentifierContext symbolIdentifier() {
		SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);
		EnterRule(_localctx, 16, RULE_symbolIdentifier);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AbstractStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AbstractType() { return GetToken(JuliaParser.AbstractType, 0); }
		public AbstractStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abstractStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AbstractStructureContext abstractStructure() {
		AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);
		EnterRule(_localctx, 18, RULE_abstractStructure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompositeStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(JuliaParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mutable() { return GetToken(JuliaParser.Mutable, 0); }
		public CompositeStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compositeStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompositeStructureContext compositeStructure() {
		CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);
		EnterRule(_localctx, 20, RULE_compositeStructure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractStructureContext abstractStructure() {
			return GetRuleContext<AbstractStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompositeStructureContext compositeStructure() {
			return GetRuleContext<CompositeStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext[] structItem() {
			return GetRuleContexts<StructItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext structItem(int i) {
			return GetRuleContext<StructItemContext>(i);
		}
		public StructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructureContext structure() {
		StructureContext _localctx = new StructureContext(Context, State);
		EnterRule(_localctx, 22, RULE_structure);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructFieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structField; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructFieldContext structField() {
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 24, RULE_structField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Termination() { return GetTokens(JuliaParser.Termination); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination(int i) {
			return GetToken(JuliaParser.Termination, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext structField() {
			return GetRuleContext<StructFieldContext>(0);
		}
		public StructItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructItemContext structItem() {
		StructItemContext _localctx = new StructItemContext(Context, State);
		EnterRule(_localctx, 26, RULE_structItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableDeclarationContext blockVariableDeclaration() {
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}
		public BlockExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprContext blockExpr() {
		BlockExprContext _localctx = new BlockExprContext(Context, State);
		EnterRule(_localctx, 28, RULE_blockExpr);
		try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public BlockExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprStatementContext blockExprStatement() {
		BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_blockExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableInstatiationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assignment() { return GetToken(JuliaParser.Assignment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		public BlockVariableInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableInstatiation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableInstatiationContext blockVariableInstatiation() {
		BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);
		EnterRule(_localctx, 32, RULE_blockVariableInstatiation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ValueType() { return GetToken(JuliaParser.ValueType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public BlockArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockArgContext blockArg() {
		BlockArgContext _localctx = new BlockArgContext(Context, State);
		EnterRule(_localctx, 34, RULE_blockArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Global() { return GetToken(JuliaParser.Global, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		public BlockVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableDeclarationContext blockVariableDeclaration() {
		BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 36, RULE_blockVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShortFunctionContext shortFunction() {
			return GetRuleContext<ShortFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LongFunctionContext longFunction() {
			return GetRuleContext<LongFunctionContext>(0);
		}
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 38, RULE_function);
		try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NamedTupleContext namedTuple() {
			return GetRuleContext<NamedTupleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionHeaderContext functionHeader() {
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 40, RULE_functionHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprStatementContext blockExprStatement() {
			return GetRuleContext<BlockExprStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public FunctionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionItemContext functionItem() {
		FunctionItemContext _localctx = new FunctionItemContext(Context, State);
		EnterRule(_localctx, 42, RULE_functionItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolIdentifierContext symbolIdentifier() {
			return GetRuleContext<SymbolIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TupleContext tuple() {
			return GetRuleContext<TupleContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 44, RULE_functionCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShortFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(JuliaParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem() {
			return GetRuleContext<FunctionItemContext>(0);
		}
		public ShortFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shortFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShortFunctionContext shortFunction() {
		ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);
		EnterRule(_localctx, 46, RULE_shortFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LongFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(JuliaParser.Function, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext[] functionItem() {
			return GetRuleContexts<FunctionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem(int i) {
			return GetRuleContext<FunctionItemContext>(i);
		}
		public LongFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_longFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LongFunctionContext longFunction() {
		LongFunctionContext _localctx = new LongFunctionContext(Context, State);
		EnterRule(_localctx, 48, RULE_longFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleContext tuple() {
		TupleContext _localctx = new TupleContext(Context, State);
		EnterRule(_localctx, 50, RULE_tuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedTupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext[] blockArg() {
			return GetRuleContexts<BlockArgContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg(int i) {
			return GetRuleContext<BlockArgContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		public NamedTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedTuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedTupleContext namedTuple() {
		NamedTupleContext _localctx = new NamedTupleContext(Context, State);
		EnterRule(_localctx, 52, RULE_namedTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypetupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(JuliaParser.Comma, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TypetupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typetuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypetupleContext typetuple() {
		TypetupleContext _localctx = new TypetupleContext(Context, State);
		EnterRule(_localctx, 54, RULE_typetuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext[] blockExpr() {
			return GetRuleContexts<BlockExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr(int i) {
			return GetRuleContext<BlockExprContext>(i);
		}
		public TupleListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleListContext tupleList() {
		TupleListContext _localctx = new TupleListContext(Context, State);
		EnterRule(_localctx, 56, RULE_tupleList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extend() { return GetToken(JuliaParser.Extend, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 58, RULE_typeName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterizedTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RightBrace() { return GetTokens(JuliaParser.RightBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace(int i) {
			return GetToken(JuliaParser.RightBrace, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LeftBrace() { return GetTokens(JuliaParser.LeftBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace(int i) {
			return GetToken(JuliaParser.LeftBrace, i);
		}
		public ParameterizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterizedType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterizedTypeContext parameterizedType() {
		ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_parameterizedType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterizedTypeContext parameterizedType() {
			return GetRuleContext<ParameterizedTypeContext>(0);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_type);
		try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(JuliaParser.End, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public EndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EndExprContext endExpr() {
		EndExprContext _localctx = new EndExprContext(Context, State);
		EnterRule(_localctx, 64, RULE_endExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace HyperSphere

namespace HyperSphere {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public const int
		RULE_script = 0, RULE_moduleExpr = 1, RULE_moduleVariableDeclaration = 2, 
		RULE_module = 3, RULE_moduleExprStatement = 4, RULE_usingModule = 5, RULE_moduleRef = 6, 
		RULE_moduleIdentifier = 7, RULE_symbolIdentifier = 8, RULE_abstractStructure = 9, 
		RULE_compositeStructure = 10, RULE_structure = 11, RULE_structField = 12, 
		RULE_structItem = 13, RULE_blockExpr = 14, RULE_blockExprStatement = 15, 
		RULE_blockVariableInstatiation = 16, RULE_blockArg = 17, RULE_blockVariableDeclaration = 18, 
		RULE_function = 19, RULE_functionHeader = 20, RULE_functionItem = 21, 
		RULE_functionCall = 22, RULE_shortFunction = 23, RULE_longFunction = 24, 
		RULE_tuple = 25, RULE_namedTuple = 26, RULE_typetuple = 27, RULE_tupleList = 28, 
		RULE_typeName = 29, RULE_parameterizedType = 30, RULE_type = 31, RULE_endExpr = 32;
	public static readonly string[] ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public JuliaParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public JuliaParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ScriptContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(JuliaParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext[] moduleExprStatement() {
			return GetRuleContexts<ModuleExprStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext moduleExprStatement(int i) {
			return GetRuleContext<ModuleExprStatementContext>(i);
		}
		public ScriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_script; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptContext script() {
		ScriptContext _localctx = new ScriptContext(Context, State);
		EnterRule(_localctx, 0, RULE_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructureContext structure() {
			return GetRuleContext<StructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleVariableDeclarationContext moduleVariableDeclaration() {
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleContext module() {
			return GetRuleContext<ModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingModuleContext usingModule() {
			return GetRuleContext<UsingModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprContext moduleExpr() {
		ModuleExprContext _localctx = new ModuleExprContext(Context, State);
		EnterRule(_localctx, 2, RULE_moduleExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		public ModuleVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleVariableDeclarationContext moduleVariableDeclaration() {
		ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Module() { return GetToken(JuliaParser.Module, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext[] moduleExpr() {
			return GetRuleContexts<ModuleExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr(int i) {
			return GetRuleContext<ModuleExprContext>(i);
		}
		public ModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_module; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleContext module() {
		ModuleContext _localctx = new ModuleContext(Context, State);
		EnterRule(_localctx, 6, RULE_module);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprStatementContext moduleExprStatement() {
		ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_moduleExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Using() { return GetToken(JuliaParser.Using, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		public UsingModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingModule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UsingModuleContext usingModule() {
		UsingModuleContext _localctx = new UsingModuleContext(Context, State);
		EnterRule(_localctx, 10, RULE_usingModule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleRefContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(JuliaParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(JuliaParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(JuliaParser.Dot); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(JuliaParser.Dot, i);
		}
		public ModuleRefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleRef; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleRefContext moduleRef() {
		ModuleRefContext _localctx = new ModuleRefContext(Context, State);
		EnterRule(_localctx, 12, RULE_moduleRef);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(JuliaParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public ModuleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleIdentifierContext moduleIdentifier() {
		ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);
		EnterRule(_localctx, 14, RULE_moduleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleIdentifierContext moduleIdentifier() {
			return GetRuleContext<ModuleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public SymbolIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolIdentifierContext symbolIdentifier() {
		SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);
		EnterRule(_localctx, 16, RULE_symbolIdentifier);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AbstractStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AbstractType() { return GetToken(JuliaParser.AbstractType, 0); }
		public AbstractStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abstractStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AbstractStructureContext abstractStructure() {
		AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);
		EnterRule(_localctx, 18, RULE_abstractStructure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompositeStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(JuliaParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mutable() { return GetToken(JuliaParser.Mutable, 0); }
		public CompositeStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compositeStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompositeStructureContext compositeStructure() {
		CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);
		EnterRule(_localctx, 20, RULE_compositeStructure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractStructureContext abstractStructure() {
			return GetRuleContext<AbstractStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompositeStructureContext compositeStructure() {
			return GetRuleContext<CompositeStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext[] structItem() {
			return GetRuleContexts<StructItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext structItem(int i) {
			return GetRuleContext<StructItemContext>(i);
		}
		public StructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructureContext structure() {
		StructureContext _localctx = new StructureContext(Context, State);
		EnterRule(_localctx, 22, RULE_structure);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructFieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structField; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructFieldContext structField() {
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 24, RULE_structField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Termination() { return GetTokens(JuliaParser.Termination); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination(int i) {
			return GetToken(JuliaParser.Termination, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext structField() {
			return GetRuleContext<StructFieldContext>(0);
		}
		public StructItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructItemContext structItem() {
		StructItemContext _localctx = new StructItemContext(Context, State);
		EnterRule(_localctx, 26, RULE_structItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableDeclarationContext blockVariableDeclaration() {
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}
		public BlockExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprContext blockExpr() {
		BlockExprContext _localctx = new BlockExprContext(Context, State);
		EnterRule(_localctx, 28, RULE_blockExpr);
		try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public BlockExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprStatementContext blockExprStatement() {
		BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_blockExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableInstatiationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assignment() { return GetToken(JuliaParser.Assignment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		public BlockVariableInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableInstatiation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableInstatiationContext blockVariableInstatiation() {
		BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);
		EnterRule(_localctx, 32, RULE_blockVariableInstatiation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ValueType() { return GetToken(JuliaParser.ValueType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public BlockArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockArgContext blockArg() {
		BlockArgContext _localctx = new BlockArgContext(Context, State);
		EnterRule(_localctx, 34, RULE_blockArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Global() { return GetToken(JuliaParser.Global, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		public BlockVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableDeclarationContext blockVariableDeclaration() {
		BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 36, RULE_blockVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShortFunctionContext shortFunction() {
			return GetRuleContext<ShortFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LongFunctionContext longFunction() {
			return GetRuleContext<LongFunctionContext>(0);
		}
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 38, RULE_function);
		try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NamedTupleContext namedTuple() {
			return GetRuleContext<NamedTupleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionHeaderContext functionHeader() {
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 40, RULE_functionHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprStatementContext blockExprStatement() {
			return GetRuleContext<BlockExprStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public FunctionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionItemContext functionItem() {
		FunctionItemContext _localctx = new FunctionItemContext(Context, State);
		EnterRule(_localctx, 42, RULE_functionItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolIdentifierContext symbolIdentifier() {
			return GetRuleContext<SymbolIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TupleContext tuple() {
			return GetRuleContext<TupleContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 44, RULE_functionCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShortFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(JuliaParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem() {
			return GetRuleContext<FunctionItemContext>(0);
		}
		public ShortFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shortFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShortFunctionContext shortFunction() {
		ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);
		EnterRule(_localctx, 46, RULE_shortFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LongFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(JuliaParser.Function, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext[] functionItem() {
			return GetRuleContexts<FunctionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem(int i) {
			return GetRuleContext<FunctionItemContext>(i);
		}
		public LongFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_longFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LongFunctionContext longFunction() {
		LongFunctionContext _localctx = new LongFunctionContext(Context, State);
		EnterRule(_localctx, 48, RULE_longFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleContext tuple() {
		TupleContext _localctx = new TupleContext(Context, State);
		EnterRule(_localctx, 50, RULE_tuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedTupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext[] blockArg() {
			return GetRuleContexts<BlockArgContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg(int i) {
			return GetRuleContext<BlockArgContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		public NamedTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedTuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedTupleContext namedTuple() {
		NamedTupleContext _localctx = new NamedTupleContext(Context, State);
		EnterRule(_localctx, 52, RULE_namedTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypetupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(JuliaParser.Comma, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TypetupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typetuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypetupleContext typetuple() {
		TypetupleContext _localctx = new TypetupleContext(Context, State);
		EnterRule(_localctx, 54, RULE_typetuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext[] blockExpr() {
			return GetRuleContexts<BlockExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr(int i) {
			return GetRuleContext<BlockExprContext>(i);
		}
		public TupleListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleListContext tupleList() {
		TupleListContext _localctx = new TupleListContext(Context, State);
		EnterRule(_localctx, 56, RULE_tupleList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extend() { return GetToken(JuliaParser.Extend, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 58, RULE_typeName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterizedTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RightBrace() { return GetTokens(JuliaParser.RightBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace(int i) {
			return GetToken(JuliaParser.RightBrace, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LeftBrace() { return GetTokens(JuliaParser.LeftBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace(int i) {
			return GetToken(JuliaParser.LeftBrace, i);
		}
		public ParameterizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterizedType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterizedTypeContext parameterizedType() {
		ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_parameterizedType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterizedTypeContext parameterizedType() {
			return GetRuleContext<ParameterizedTypeContext>(0);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_type);
		try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(JuliaParser.End, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public EndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EndExprContext endExpr() {
		EndExprContext _localctx = new EndExprContext(Context, State);
		EnterRule(_localctx, 64, RULE_endExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
}
HyperSphere
using System;
System
using System.IO;
System.IO
System
IO
using System.Text;
System.Text
System
Text
using System.Diagnostics;
System.Diagnostics
System
Diagnostics
using System.Collections.Generic;
System.Collections.Generic
System.Collections
System
Collections
Generic
using Antlr4.Runtime;
Antlr4.Runtime
Antlr4
Runtime
using Antlr4.Runtime.Atn;
Antlr4.Runtime.Atn
Antlr4.Runtime
Antlr4
Runtime
Atn
using Antlr4.Runtime.Misc;
Antlr4.Runtime.Misc
Antlr4.Runtime
Antlr4
Runtime
Misc
using Antlr4.Runtime.Tree;
Antlr4.Runtime.Tree
Antlr4.Runtime
Antlr4
Runtime
Tree
using DFA = Antlr4.Runtime.Dfa.DFA;
DFA =
DFA
Antlr4.Runtime.Dfa.DFA
Antlr4.Runtime.Dfa
Antlr4.Runtime
Antlr4
Runtime
Dfa
DFA
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public const int
		RULE_script = 0, RULE_moduleExpr = 1, RULE_moduleVariableDeclaration = 2, 
		RULE_module = 3, RULE_moduleExprStatement = 4, RULE_usingModule = 5, RULE_moduleRef = 6, 
		RULE_moduleIdentifier = 7, RULE_symbolIdentifier = 8, RULE_abstractStructure = 9, 
		RULE_compositeStructure = 10, RULE_structure = 11, RULE_structField = 12, 
		RULE_structItem = 13, RULE_blockExpr = 14, RULE_blockExprStatement = 15, 
		RULE_blockVariableInstatiation = 16, RULE_blockArg = 17, RULE_blockVariableDeclaration = 18, 
		RULE_function = 19, RULE_functionHeader = 20, RULE_functionItem = 21, 
		RULE_functionCall = 22, RULE_shortFunction = 23, RULE_longFunction = 24, 
		RULE_tuple = 25, RULE_namedTuple = 26, RULE_typetuple = 27, RULE_tupleList = 28, 
		RULE_typeName = 29, RULE_parameterizedType = 30, RULE_type = 31, RULE_endExpr = 32;
	public static readonly string[] ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public JuliaParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public JuliaParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ScriptContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(JuliaParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext[] moduleExprStatement() {
			return GetRuleContexts<ModuleExprStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext moduleExprStatement(int i) {
			return GetRuleContext<ModuleExprStatementContext>(i);
		}
		public ScriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_script; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptContext script() {
		ScriptContext _localctx = new ScriptContext(Context, State);
		EnterRule(_localctx, 0, RULE_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructureContext structure() {
			return GetRuleContext<StructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleVariableDeclarationContext moduleVariableDeclaration() {
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleContext module() {
			return GetRuleContext<ModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingModuleContext usingModule() {
			return GetRuleContext<UsingModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprContext moduleExpr() {
		ModuleExprContext _localctx = new ModuleExprContext(Context, State);
		EnterRule(_localctx, 2, RULE_moduleExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		public ModuleVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleVariableDeclarationContext moduleVariableDeclaration() {
		ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Module() { return GetToken(JuliaParser.Module, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext[] moduleExpr() {
			return GetRuleContexts<ModuleExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr(int i) {
			return GetRuleContext<ModuleExprContext>(i);
		}
		public ModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_module; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleContext module() {
		ModuleContext _localctx = new ModuleContext(Context, State);
		EnterRule(_localctx, 6, RULE_module);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprStatementContext moduleExprStatement() {
		ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_moduleExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Using() { return GetToken(JuliaParser.Using, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		public UsingModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingModule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UsingModuleContext usingModule() {
		UsingModuleContext _localctx = new UsingModuleContext(Context, State);
		EnterRule(_localctx, 10, RULE_usingModule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleRefContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(JuliaParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(JuliaParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(JuliaParser.Dot); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(JuliaParser.Dot, i);
		}
		public ModuleRefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleRef; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleRefContext moduleRef() {
		ModuleRefContext _localctx = new ModuleRefContext(Context, State);
		EnterRule(_localctx, 12, RULE_moduleRef);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(JuliaParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public ModuleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleIdentifierContext moduleIdentifier() {
		ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);
		EnterRule(_localctx, 14, RULE_moduleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleIdentifierContext moduleIdentifier() {
			return GetRuleContext<ModuleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public SymbolIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolIdentifierContext symbolIdentifier() {
		SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);
		EnterRule(_localctx, 16, RULE_symbolIdentifier);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AbstractStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AbstractType() { return GetToken(JuliaParser.AbstractType, 0); }
		public AbstractStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abstractStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AbstractStructureContext abstractStructure() {
		AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);
		EnterRule(_localctx, 18, RULE_abstractStructure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompositeStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(JuliaParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mutable() { return GetToken(JuliaParser.Mutable, 0); }
		public CompositeStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compositeStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompositeStructureContext compositeStructure() {
		CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);
		EnterRule(_localctx, 20, RULE_compositeStructure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractStructureContext abstractStructure() {
			return GetRuleContext<AbstractStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompositeStructureContext compositeStructure() {
			return GetRuleContext<CompositeStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext[] structItem() {
			return GetRuleContexts<StructItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext structItem(int i) {
			return GetRuleContext<StructItemContext>(i);
		}
		public StructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructureContext structure() {
		StructureContext _localctx = new StructureContext(Context, State);
		EnterRule(_localctx, 22, RULE_structure);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructFieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structField; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructFieldContext structField() {
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 24, RULE_structField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Termination() { return GetTokens(JuliaParser.Termination); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination(int i) {
			return GetToken(JuliaParser.Termination, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext structField() {
			return GetRuleContext<StructFieldContext>(0);
		}
		public StructItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructItemContext structItem() {
		StructItemContext _localctx = new StructItemContext(Context, State);
		EnterRule(_localctx, 26, RULE_structItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableDeclarationContext blockVariableDeclaration() {
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}
		public BlockExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprContext blockExpr() {
		BlockExprContext _localctx = new BlockExprContext(Context, State);
		EnterRule(_localctx, 28, RULE_blockExpr);
		try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public BlockExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprStatementContext blockExprStatement() {
		BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_blockExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableInstatiationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assignment() { return GetToken(JuliaParser.Assignment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		public BlockVariableInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableInstatiation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableInstatiationContext blockVariableInstatiation() {
		BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);
		EnterRule(_localctx, 32, RULE_blockVariableInstatiation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ValueType() { return GetToken(JuliaParser.ValueType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public BlockArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockArgContext blockArg() {
		BlockArgContext _localctx = new BlockArgContext(Context, State);
		EnterRule(_localctx, 34, RULE_blockArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Global() { return GetToken(JuliaParser.Global, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		public BlockVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableDeclarationContext blockVariableDeclaration() {
		BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 36, RULE_blockVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShortFunctionContext shortFunction() {
			return GetRuleContext<ShortFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LongFunctionContext longFunction() {
			return GetRuleContext<LongFunctionContext>(0);
		}
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 38, RULE_function);
		try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NamedTupleContext namedTuple() {
			return GetRuleContext<NamedTupleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionHeaderContext functionHeader() {
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 40, RULE_functionHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprStatementContext blockExprStatement() {
			return GetRuleContext<BlockExprStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public FunctionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionItemContext functionItem() {
		FunctionItemContext _localctx = new FunctionItemContext(Context, State);
		EnterRule(_localctx, 42, RULE_functionItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolIdentifierContext symbolIdentifier() {
			return GetRuleContext<SymbolIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TupleContext tuple() {
			return GetRuleContext<TupleContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 44, RULE_functionCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShortFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(JuliaParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem() {
			return GetRuleContext<FunctionItemContext>(0);
		}
		public ShortFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shortFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShortFunctionContext shortFunction() {
		ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);
		EnterRule(_localctx, 46, RULE_shortFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LongFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(JuliaParser.Function, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext[] functionItem() {
			return GetRuleContexts<FunctionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem(int i) {
			return GetRuleContext<FunctionItemContext>(i);
		}
		public LongFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_longFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LongFunctionContext longFunction() {
		LongFunctionContext _localctx = new LongFunctionContext(Context, State);
		EnterRule(_localctx, 48, RULE_longFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleContext tuple() {
		TupleContext _localctx = new TupleContext(Context, State);
		EnterRule(_localctx, 50, RULE_tuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedTupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext[] blockArg() {
			return GetRuleContexts<BlockArgContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg(int i) {
			return GetRuleContext<BlockArgContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		public NamedTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedTuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedTupleContext namedTuple() {
		NamedTupleContext _localctx = new NamedTupleContext(Context, State);
		EnterRule(_localctx, 52, RULE_namedTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypetupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(JuliaParser.Comma, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TypetupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typetuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypetupleContext typetuple() {
		TypetupleContext _localctx = new TypetupleContext(Context, State);
		EnterRule(_localctx, 54, RULE_typetuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext[] blockExpr() {
			return GetRuleContexts<BlockExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr(int i) {
			return GetRuleContext<BlockExprContext>(i);
		}
		public TupleListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleListContext tupleList() {
		TupleListContext _localctx = new TupleListContext(Context, State);
		EnterRule(_localctx, 56, RULE_tupleList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extend() { return GetToken(JuliaParser.Extend, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 58, RULE_typeName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterizedTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RightBrace() { return GetTokens(JuliaParser.RightBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace(int i) {
			return GetToken(JuliaParser.RightBrace, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LeftBrace() { return GetTokens(JuliaParser.LeftBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace(int i) {
			return GetToken(JuliaParser.LeftBrace, i);
		}
		public ParameterizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterizedType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterizedTypeContext parameterizedType() {
		ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_parameterizedType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterizedTypeContext parameterizedType() {
			return GetRuleContext<ParameterizedTypeContext>(0);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_type);
		try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(JuliaParser.End, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public EndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EndExprContext endExpr() {
		EndExprContext _localctx = new EndExprContext(Context, State);
		EnterRule(_localctx, 64, RULE_endExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")
System.CodeDom.Compiler.GeneratedCode
System.CodeDom.Compiler
System.CodeDom
System
CodeDom
Compiler
GeneratedCode
("ANTLR", "4.10.1")
"ANTLR"
"ANTLR"
"4.10.1"
"4.10.1"
[System.CLSCompliant(false)]
System.CLSCompliant(false)
System.CLSCompliant
System
CLSCompliant
(false)
false
false
: Parser
Parser
Parser
protected static DFA[] decisionToDFA;
DFA[] decisionToDFA
DFA[]
DFA
[]

decisionToDFA
protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
PredictionContextCache sharedContextCache = new PredictionContextCache()
PredictionContextCache
sharedContextCache = new PredictionContextCache()
= new PredictionContextCache()
new PredictionContextCache()
PredictionContextCache
()
public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67
int
Symbol=1
=1
1
AbstractType=2
=2
2
Using=3
=3
3
Extend=4
=4
4
Global=5
=5
5
Const=6
=6
6
Local=7
=7
7
Mutable=8
=8
8
Function=9
=9
9
Module=10
=10
10
Struct=11
=11
11
For=12
=12
12
Goto=13
=13
13
If=14
=14
14
Else=15
=15
15
ElseIf=16
=16
16
Return=17
=17
17
Continue=18
=18
18
Do=19
=19
19
End=20
=20
20
LeftParen=21
=21
21
RightParen=22
=22
22
LeftBracket=23
=23
23
RightBracket=24
=24
24
LeftBrace=25
=25
25
RightBrace=26
=26
26
And=27
=27
27
Or=28
=28
28
Caret=29
=29
29
Not=30
=30
30
Tilde=31
=31
31
Plus=32
=32
32
Minus=33
=33
33
Star=34
=34
34
Div=35
=35
35
Mod=36
=36
36
LeftShift=37
=37
37
RightShift=38
=38
38
Operator=39
=39
39
Less=40
=40
40
LessEqual=41
=41
41
Greater=42
=42
42
GreaterEqual=43
=43
43
ComparisonOperator=44
=44
44
ShortAnd=45
=45
45
ShortOr=46
=46
46
ShortcutOperator=47
=47
47
Question=48
=48
48
Colon=49
=49
49
ValueType=50
=50
50
Semi=51
=51
51
Comma=52
=52
52
Assign=53
=53
53
Arrow=54
=54
54
Dot=55
=55
55
Splat=56
=56
56
Termination=57
=57
57
AugmentedAssignment=58
=58
58
Assignment=59
=59
59
Constant=60
=60
60
Identifier=61
=61
61
IntegerConstant=62
=62
62
DecimalConstant=63
=63
63
NewLine=64
=64
64
Whitespace=65
=65
65
BlockComment=66
=66
66
LineComment=67
=67
67
public const int
		RULE_script = 0, RULE_moduleExpr = 1, RULE_moduleVariableDeclaration = 2, 
		RULE_module = 3, RULE_moduleExprStatement = 4, RULE_usingModule = 5, RULE_moduleRef = 6, 
		RULE_moduleIdentifier = 7, RULE_symbolIdentifier = 8, RULE_abstractStructure = 9, 
		RULE_compositeStructure = 10, RULE_structure = 11, RULE_structField = 12, 
		RULE_structItem = 13, RULE_blockExpr = 14, RULE_blockExprStatement = 15, 
		RULE_blockVariableInstatiation = 16, RULE_blockArg = 17, RULE_blockVariableDeclaration = 18, 
		RULE_function = 19, RULE_functionHeader = 20, RULE_functionItem = 21, 
		RULE_functionCall = 22, RULE_shortFunction = 23, RULE_longFunction = 24, 
		RULE_tuple = 25, RULE_namedTuple = 26, RULE_typetuple = 27, RULE_tupleList = 28, 
		RULE_typeName = 29, RULE_parameterizedType = 30, RULE_type = 31, RULE_endExpr = 32;
int
		RULE_script = 0, RULE_moduleExpr = 1, RULE_moduleVariableDeclaration = 2, 
		RULE_module = 3, RULE_moduleExprStatement = 4, RULE_usingModule = 5, RULE_moduleRef = 6, 
		RULE_moduleIdentifier = 7, RULE_symbolIdentifier = 8, RULE_abstractStructure = 9, 
		RULE_compositeStructure = 10, RULE_structure = 11, RULE_structField = 12, 
		RULE_structItem = 13, RULE_blockExpr = 14, RULE_blockExprStatement = 15, 
		RULE_blockVariableInstatiation = 16, RULE_blockArg = 17, RULE_blockVariableDeclaration = 18, 
		RULE_function = 19, RULE_functionHeader = 20, RULE_functionItem = 21, 
		RULE_functionCall = 22, RULE_shortFunction = 23, RULE_longFunction = 24, 
		RULE_tuple = 25, RULE_namedTuple = 26, RULE_typetuple = 27, RULE_tupleList = 28, 
		RULE_typeName = 29, RULE_parameterizedType = 30, RULE_type = 31, RULE_endExpr = 32
int
RULE_script = 0
= 0
0
RULE_moduleExpr = 1
= 1
1
RULE_moduleVariableDeclaration = 2
= 2
2
RULE_module = 3
= 3
3
RULE_moduleExprStatement = 4
= 4
4
RULE_usingModule = 5
= 5
5
RULE_moduleRef = 6
= 6
6
RULE_moduleIdentifier = 7
= 7
7
RULE_symbolIdentifier = 8
= 8
8
RULE_abstractStructure = 9
= 9
9
RULE_compositeStructure = 10
= 10
10
RULE_structure = 11
= 11
11
RULE_structField = 12
= 12
12
RULE_structItem = 13
= 13
13
RULE_blockExpr = 14
= 14
14
RULE_blockExprStatement = 15
= 15
15
RULE_blockVariableInstatiation = 16
= 16
16
RULE_blockArg = 17
= 17
17
RULE_blockVariableDeclaration = 18
= 18
18
RULE_function = 19
= 19
19
RULE_functionHeader = 20
= 20
20
RULE_functionItem = 21
= 21
21
RULE_functionCall = 22
= 22
22
RULE_shortFunction = 23
= 23
23
RULE_longFunction = 24
= 24
24
RULE_tuple = 25
= 25
25
RULE_namedTuple = 26
= 26
26
RULE_typetuple = 27
= 27
27
RULE_tupleList = 28
= 28
28
RULE_typeName = 29
= 29
29
RULE_parameterizedType = 30
= 30
30
RULE_type = 31
= 31
31
RULE_endExpr = 32
= 32
32
public static readonly string[] ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	};
string[] ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	}
string[]
string
[]

ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	}
= {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	}
{
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	}
"script"
"moduleExpr"
"moduleVariableDeclaration"
"module"
"moduleExprStatement"
"usingModule"
"moduleRef"
"moduleIdentifier"
"symbolIdentifier"
"abstractStructure"
"compositeStructure"
"structure"
"structField"
"structItem"
"blockExpr"
"blockExprStatement"
"blockVariableInstatiation"
"blockArg"
"blockVariableDeclaration"
"function"
"functionHeader"
"functionItem"
"functionCall"
"shortFunction"
"longFunction"
"tuple"
"namedTuple"
"typetuple"
"tupleList"
"typeName"
"parameterizedType"
"type"
"endExpr"
private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}
string[]
string
[]

_LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}
= {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}
{
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}
null
null
null
"'using'"
"'<:'"
"'global'"
"'const'"
"'local'"
"'mutable'"
"'function'"
"'module'"
"'struct'"
"'for'"
"'goto'"
"'if'"
"'else'"
"'elseif'"
"'return'"
"'continue'"
"'do'"
"'end'"
"'('"
"')'"
"'['"
"']'"
"'{'"
"'}'"
"'&'"
"'|'"
"'^'"
"'!'"
"'~'"
"'+'"
"'-'"
"'*'"
"'/'"
"'%'"
"'<<'"
"'>>'"
null
"'<'"
"'<='"
"'>'"
"'>='"
null
"'&&'"
"'||'"
null
"'?'"
"':'"
"'::'"
"';'"
"','"
"'='"
"'->'"
"'.'"
"'...'"
private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
string[]
string
[]

_SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
= {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
{
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}
null
"Symbol"
"AbstractType"
"Using"
"Extend"
"Global"
"Const"
"Local"
"Mutable"
"Function"
"Module"
"Struct"
"For"
"Goto"
"If"
"Else"
"ElseIf"
"Return"
"Continue"
"Do"
"End"
"LeftParen"
"RightParen"
"LeftBracket"
"RightBracket"
"LeftBrace"
"RightBrace"
"And"
"Or"
"Caret"
"Not"
"Tilde"
"Plus"
"Minus"
"Star"
"Div"
"Mod"
"LeftShift"
"RightShift"
"Operator"
"Less"
"LessEqual"
"Greater"
"GreaterEqual"
"ComparisonOperator"
"ShortAnd"
"ShortOr"
"ShortcutOperator"
"Question"
"Colon"
"ValueType"
"Semi"
"Comma"
"Assign"
"Arrow"
"Dot"
"Splat"
"Termination"
"AugmentedAssignment"
"Assignment"
"Constant"
"Identifier"
"IntegerConstant"
"DecimalConstant"
"NewLine"
"Whitespace"
"BlockComment"
"LineComment"
public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);
IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames)
IVocabulary
DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames)
= new Vocabulary(_LiteralNames, _SymbolicNames)
new Vocabulary(_LiteralNames, _SymbolicNames)
Vocabulary
(_LiteralNames, _SymbolicNames)
_LiteralNames
_LiteralNames
_SymbolicNames
_SymbolicNames
[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}
[NotNull]
NotNull
NotNull
IVocabulary
{
		get
		{
			return DefaultVocabulary;
		}
	}
get
		{
			return DefaultVocabulary;
		}
{
			return DefaultVocabulary;
		}
return DefaultVocabulary;
DefaultVocabulary
public override string GrammarFileName { get { return "Julia.g4"; } }
string
{ get { return "Julia.g4"; } }
get { return "Julia.g4"; }
{ return "Julia.g4"; }
return "Julia.g4";
"Julia.g4"
public override string[] RuleNames { get { return ruleNames; } }
string[]
string
[]

{ get { return ruleNames; } }
get { return ruleNames; }
{ return ruleNames; }
return ruleNames;
ruleNames
public override int[] SerializedAtn { get { return _serializedATN; } }
int[]
int
[]

{ get { return _serializedATN; } }
get { return _serializedATN; }
{ return _serializedATN; }
return _serializedATN;
_serializedATN
static JuliaParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}
()
{
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}
decisionToDFA = new DFA[_ATN.NumberOfDecisions];
decisionToDFA = new DFA[_ATN.NumberOfDecisions]
decisionToDFA
new DFA[_ATN.NumberOfDecisions]
DFA[_ATN.NumberOfDecisions]
DFA
[_ATN.NumberOfDecisions]
_ATN.NumberOfDecisions
_ATN
NumberOfDecisions
for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
int i = 0
int
i = 0
= 0
0
i < _ATN.NumberOfDecisions
i
_ATN.NumberOfDecisions
_ATN
NumberOfDecisions
i++
i
{
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i)
decisionToDFA[i]
decisionToDFA
[i]
i
i
new DFA(_ATN.GetDecisionState(i), i)
DFA
(_ATN.GetDecisionState(i), i)
_ATN.GetDecisionState(i)
_ATN.GetDecisionState(i)
_ATN.GetDecisionState
_ATN
GetDecisionState
(i)
i
i
i
i
public JuliaParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }
(ITokenStream input)
ITokenStream input
ITokenStream
: this(input, Console.Out, Console.Error)
(input, Console.Out, Console.Error)
input
input
Console.Out
Console.Out
Console
Out
Console.Error
Console.Error
Console
Error
{ }
public JuliaParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
(ITokenStream input, TextWriter output, TextWriter errorOutput)
ITokenStream input
ITokenStream
TextWriter output
TextWriter
TextWriter errorOutput
TextWriter
: base(input, output, errorOutput)
(input, output, errorOutput)
input
input
output
output
errorOutput
errorOutput
{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache)
Interpreter
new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache)
ParserATNSimulator
(this, _ATN, decisionToDFA, sharedContextCache)
this
this
_ATN
_ATN
decisionToDFA
decisionToDFA
sharedContextCache
sharedContextCache
public partial class ScriptContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(JuliaParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext[] moduleExprStatement() {
			return GetRuleContexts<ModuleExprStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext moduleExprStatement(int i) {
			return GetRuleContext<ModuleExprStatementContext>(i);
		}
		public ScriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_script; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(JuliaParser.Eof, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Eof, 0); }
return GetToken(JuliaParser.Eof, 0);
GetToken(JuliaParser.Eof, 0)
GetToken
(JuliaParser.Eof, 0)
JuliaParser.Eof
JuliaParser.Eof
JuliaParser
Eof
0
0
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleExprContext
()
{
			return GetRuleContext<ModuleExprContext>(0);
		}
return GetRuleContext<ModuleExprContext>(0);
GetRuleContext<ModuleExprContext>(0)
GetRuleContext<ModuleExprContext>
<ModuleExprContext>
ModuleExprContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext[] moduleExprStatement() {
			return GetRuleContexts<ModuleExprStatementContext>();
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleExprStatementContext[]
ModuleExprStatementContext
[]

()
{
			return GetRuleContexts<ModuleExprStatementContext>();
		}
return GetRuleContexts<ModuleExprStatementContext>();
GetRuleContexts<ModuleExprStatementContext>()
GetRuleContexts<ModuleExprStatementContext>
<ModuleExprStatementContext>
ModuleExprStatementContext
()
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext moduleExprStatement(int i) {
			return GetRuleContext<ModuleExprStatementContext>(i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleExprStatementContext
(int i)
int i
int
{
			return GetRuleContext<ModuleExprStatementContext>(i);
		}
return GetRuleContext<ModuleExprStatementContext>(i);
GetRuleContext<ModuleExprStatementContext>(i)
GetRuleContext<ModuleExprStatementContext>
<ModuleExprStatementContext>
ModuleExprStatementContext
(i)
i
i
public ScriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_script; } }
int
{ get { return RULE_script; } }
get { return RULE_script; }
{ return RULE_script; }
return RULE_script;
RULE_script
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterScript(this);
typedListener != null
typedListener
null
typedListener.EnterScript(this);
typedListener.EnterScript(this)
typedListener.EnterScript
typedListener
EnterScript
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitScript(this);
typedListener != null
typedListener
null
typedListener.ExitScript(this);
typedListener.ExitScript(this)
typedListener.ExitScript
typedListener
ExitScript
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitScript(this);
typedVisitor.VisitScript(this)
typedVisitor.VisitScript
typedVisitor
VisitScript
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public ScriptContext script() {
		ScriptContext _localctx = new ScriptContext(Context, State);
		EnterRule(_localctx, 0, RULE_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
ScriptContext
()
{
		ScriptContext _localctx = new ScriptContext(Context, State);
		EnterRule(_localctx, 0, RULE_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
ScriptContext _localctx = new ScriptContext(Context, State);
ScriptContext _localctx = new ScriptContext(Context, State)
ScriptContext
_localctx = new ScriptContext(Context, State)
= new ScriptContext(Context, State)
new ScriptContext(Context, State)
ScriptContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 0, RULE_script);
EnterRule(_localctx, 0, RULE_script)
EnterRule
(_localctx, 0, RULE_script)
_localctx
_localctx
0
0
RULE_script
RULE_script
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
State = 77;
State = 77
State
77
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
case Eof:
Eof
{
				State = 66;
				Match(Eof);
				}
State = 66;
State = 66
State
66
Match(Eof);
Match(Eof)
Match
(Eof)
Eof
Eof
break;
case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
case AbstractType:
AbstractType
case Using:
Using
case Global:
Global
case Const:
Const
case Local:
Local
case Mutable:
Mutable
case Module:
Module
case Struct:
Struct
case Termination:
Termination
case Identifier:
Identifier
{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
State = 73;
State = 73
State
73
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
Interpreter.AdaptivePredict(TokenStream,1,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,1,Context)
TokenStream
TokenStream
1
1
Context
Context
case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
case 1:
1
{
					State = 67;
					moduleExpr();
					}
State = 67;
State = 67
State
67
moduleExpr();
moduleExpr()
moduleExpr
()
break;
case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
case 2:
2
{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
State = 69;
State = 69
State
69
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
{
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
{
						{
						State = 68;
						moduleExprStatement();
						}
						}
{
						State = 68;
						moduleExprStatement();
						}
State = 68;
State = 68
State
68
moduleExprStatement();
moduleExprStatement()
moduleExprStatement
()
State = 71;
State = 71
State
71
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
(((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0)
((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0
((_la) & ~0x3f) == 0
((_la) & ~0x3f)
(_la) & ~0x3f
(_la)
_la
~0x3f
0x3f
0
((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0
((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier)))
(1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))
(1L << _la)
1L << _la
1L
_la
((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier)
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination)
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct)
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module)
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable)
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local)
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const)
(1L << AbstractType) | (1L << Using) | (1L << Global)
(1L << AbstractType) | (1L << Using)
(1L << AbstractType)
1L << AbstractType
1L
AbstractType
(1L << Using)
1L << Using
1L
Using
(1L << Global)
1L << Global
1L
Global
(1L << Const)
1L << Const
1L
Const
(1L << Local)
1L << Local
1L
Local
(1L << Mutable)
1L << Mutable
1L
Mutable
(1L << Module)
1L << Module
1L
Module
(1L << Struct)
1L << Struct
1L
Struct
(1L << Termination)
1L << Termination
1L
Termination
(1L << Identifier)
1L << Identifier
1L
Identifier
0
break;
State = 75;
State = 75
State
75
Match(Eof);
Match(Eof)
Match
(Eof)
Eof
Eof
break;
default:
				throw new NoViableAltException(this);
default:
throw new NoViableAltException(this);
new NoViableAltException(this)
NoViableAltException
(this)
this
this
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class ModuleExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructureContext structure() {
			return GetRuleContext<StructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleVariableDeclarationContext moduleVariableDeclaration() {
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleContext module() {
			return GetRuleContext<ModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingModuleContext usingModule() {
			return GetRuleContext<UsingModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public StructureContext structure() {
			return GetRuleContext<StructureContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
StructureContext
()
{
			return GetRuleContext<StructureContext>(0);
		}
return GetRuleContext<StructureContext>(0);
GetRuleContext<StructureContext>(0)
GetRuleContext<StructureContext>
<StructureContext>
StructureContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ModuleVariableDeclarationContext moduleVariableDeclaration() {
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleVariableDeclarationContext
()
{
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}
return GetRuleContext<ModuleVariableDeclarationContext>(0);
GetRuleContext<ModuleVariableDeclarationContext>(0)
GetRuleContext<ModuleVariableDeclarationContext>
<ModuleVariableDeclarationContext>
ModuleVariableDeclarationContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ModuleContext module() {
			return GetRuleContext<ModuleContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleContext
()
{
			return GetRuleContext<ModuleContext>(0);
		}
return GetRuleContext<ModuleContext>(0);
GetRuleContext<ModuleContext>(0)
GetRuleContext<ModuleContext>
<ModuleContext>
ModuleContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public UsingModuleContext usingModule() {
			return GetRuleContext<UsingModuleContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
UsingModuleContext
()
{
			return GetRuleContext<UsingModuleContext>(0);
		}
return GetRuleContext<UsingModuleContext>(0);
GetRuleContext<UsingModuleContext>(0)
GetRuleContext<UsingModuleContext>
<UsingModuleContext>
UsingModuleContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockExprContext
()
{
			return GetRuleContext<BlockExprContext>(0);
		}
return GetRuleContext<BlockExprContext>(0);
GetRuleContext<BlockExprContext>(0)
GetRuleContext<BlockExprContext>
<BlockExprContext>
BlockExprContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Termination, 0); }
return GetToken(JuliaParser.Termination, 0);
GetToken(JuliaParser.Termination, 0)
GetToken
(JuliaParser.Termination, 0)
JuliaParser.Termination
JuliaParser.Termination
JuliaParser
Termination
0
0
public ModuleExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_moduleExpr; } }
int
{ get { return RULE_moduleExpr; } }
get { return RULE_moduleExpr; }
{ return RULE_moduleExpr; }
return RULE_moduleExpr;
RULE_moduleExpr
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterModuleExpr(this);
typedListener != null
typedListener
null
typedListener.EnterModuleExpr(this);
typedListener.EnterModuleExpr(this)
typedListener.EnterModuleExpr
typedListener
EnterModuleExpr
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitModuleExpr(this);
typedListener != null
typedListener
null
typedListener.ExitModuleExpr(this);
typedListener.ExitModuleExpr(this)
typedListener.ExitModuleExpr
typedListener
ExitModuleExpr
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitModuleExpr(this);
typedVisitor.VisitModuleExpr(this)
typedVisitor.VisitModuleExpr
typedVisitor
VisitModuleExpr
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public ModuleExprContext moduleExpr() {
		ModuleExprContext _localctx = new ModuleExprContext(Context, State);
		EnterRule(_localctx, 2, RULE_moduleExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
ModuleExprContext
()
{
		ModuleExprContext _localctx = new ModuleExprContext(Context, State);
		EnterRule(_localctx, 2, RULE_moduleExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
ModuleExprContext _localctx = new ModuleExprContext(Context, State);
ModuleExprContext _localctx = new ModuleExprContext(Context, State)
ModuleExprContext
_localctx = new ModuleExprContext(Context, State)
= new ModuleExprContext(Context, State)
new ModuleExprContext(Context, State)
ModuleExprContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 2, RULE_moduleExpr);
EnterRule(_localctx, 2, RULE_moduleExpr)
EnterRule
(_localctx, 2, RULE_moduleExpr)
_localctx
_localctx
2
2
RULE_moduleExpr
RULE_moduleExpr
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
State = 80;
State = 80
State
80
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}
_la==Termination
_la
Termination
{
				{
				State = 79;
				Match(Termination);
				}
			}
{
				State = 79;
				Match(Termination);
				}
State = 79;
State = 79
State
79
Match(Termination);
Match(Termination)
Match
(Termination)
Termination
Termination
State = 87;
State = 87
State
87
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
Interpreter.AdaptivePredict(TokenStream,4,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,4,Context)
TokenStream
TokenStream
4
4
Context
Context
case 1:
				{
				State = 82;
				structure();
				}
				break;
case 1:
1
{
				State = 82;
				structure();
				}
State = 82;
State = 82
State
82
structure();
structure()
structure
()
break;
case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
case 2:
2
{
				State = 83;
				moduleVariableDeclaration();
				}
State = 83;
State = 83
State
83
moduleVariableDeclaration();
moduleVariableDeclaration()
moduleVariableDeclaration
()
break;
case 3:
				{
				State = 84;
				module();
				}
				break;
case 3:
3
{
				State = 84;
				module();
				}
State = 84;
State = 84
State
84
module();
module()
module
()
break;
case 4:
				{
				State = 85;
				usingModule();
				}
				break;
case 4:
4
{
				State = 85;
				usingModule();
				}
State = 85;
State = 85
State
85
usingModule();
usingModule()
usingModule
()
break;
case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
case 5:
5
{
				State = 86;
				blockExpr();
				}
State = 86;
State = 86
State
86
blockExpr();
blockExpr()
blockExpr
()
break;
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class ModuleVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		public ModuleVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockArgContext
()
{
			return GetRuleContext<BlockArgContext>(0);
		}
return GetRuleContext<BlockArgContext>(0);
GetRuleContext<BlockArgContext>(0)
GetRuleContext<BlockArgContext>
<BlockArgContext>
BlockArgContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Const, 0); }
return GetToken(JuliaParser.Const, 0);
GetToken(JuliaParser.Const, 0)
GetToken
(JuliaParser.Const, 0)
JuliaParser.Const
JuliaParser.Const
JuliaParser
Const
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Local, 0); }
return GetToken(JuliaParser.Local, 0);
GetToken(JuliaParser.Local, 0)
GetToken
(JuliaParser.Local, 0)
JuliaParser.Local
JuliaParser.Local
JuliaParser
Local
0
0
[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockVariableInstatiationContext
()
{
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
return GetRuleContext<BlockVariableInstatiationContext>(0);
GetRuleContext<BlockVariableInstatiationContext>(0)
GetRuleContext<BlockVariableInstatiationContext>
<BlockVariableInstatiationContext>
BlockVariableInstatiationContext
(0)
0
0
public ModuleVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_moduleVariableDeclaration; } }
int
{ get { return RULE_moduleVariableDeclaration; } }
get { return RULE_moduleVariableDeclaration; }
{ return RULE_moduleVariableDeclaration; }
return RULE_moduleVariableDeclaration;
RULE_moduleVariableDeclaration
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
typedListener != null
typedListener
null
typedListener.EnterModuleVariableDeclaration(this);
typedListener.EnterModuleVariableDeclaration(this)
typedListener.EnterModuleVariableDeclaration
typedListener
EnterModuleVariableDeclaration
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
typedListener != null
typedListener
null
typedListener.ExitModuleVariableDeclaration(this);
typedListener.ExitModuleVariableDeclaration(this)
typedListener.ExitModuleVariableDeclaration
typedListener
ExitModuleVariableDeclaration
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitModuleVariableDeclaration(this);
typedVisitor.VisitModuleVariableDeclaration(this)
typedVisitor.VisitModuleVariableDeclaration
typedVisitor
VisitModuleVariableDeclaration
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public ModuleVariableDeclarationContext moduleVariableDeclaration() {
		ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
ModuleVariableDeclarationContext
()
{
		ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);
ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State)
ModuleVariableDeclarationContext
_localctx = new ModuleVariableDeclarationContext(Context, State)
= new ModuleVariableDeclarationContext(Context, State)
new ModuleVariableDeclarationContext(Context, State)
ModuleVariableDeclarationContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);
EnterRule(_localctx, 4, RULE_moduleVariableDeclaration)
EnterRule
(_localctx, 4, RULE_moduleVariableDeclaration)
_localctx
_localctx
4
4
RULE_moduleVariableDeclaration
RULE_moduleVariableDeclaration
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
State = 90;
State = 90
State
90
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}
_la==Const
_la
Const
{
				{
				State = 89;
				Match(Const);
				}
			}
{
				State = 89;
				Match(Const);
				}
State = 89;
State = 89
State
89
Match(Const);
Match(Const)
Match
(Const)
Const
Const
State = 93;
State = 93
State
93
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}
_la==Local
_la
Local
{
				{
				State = 92;
				Match(Local);
				}
			}
{
				State = 92;
				Match(Local);
				}
State = 92;
State = 92
State
92
Match(Local);
Match(Local)
Match
(Local)
Local
Local
State = 95;
State = 95
State
95
blockArg();
blockArg()
blockArg
()
State = 97;
State = 97
State
97
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}
_la==Assignment
_la
Assignment
{
				{
				State = 96;
				blockVariableInstatiation();
				}
			}
{
				State = 96;
				blockVariableInstatiation();
				}
State = 96;
State = 96
State
96
blockVariableInstatiation();
blockVariableInstatiation()
blockVariableInstatiation
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class ModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Module() { return GetToken(JuliaParser.Module, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext[] moduleExpr() {
			return GetRuleContexts<ModuleExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr(int i) {
			return GetRuleContext<ModuleExprContext>(i);
		}
		public ModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_module; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Module() { return GetToken(JuliaParser.Module, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Module, 0); }
return GetToken(JuliaParser.Module, 0);
GetToken(JuliaParser.Module, 0)
GetToken
(JuliaParser.Module, 0)
JuliaParser.Module
JuliaParser.Module
JuliaParser
Module
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Identifier, 0); }
return GetToken(JuliaParser.Identifier, 0);
GetToken(JuliaParser.Identifier, 0)
GetToken
(JuliaParser.Identifier, 0)
JuliaParser.Identifier
JuliaParser.Identifier
JuliaParser
Identifier
0
0
[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
EndExprContext
()
{
			return GetRuleContext<EndExprContext>(0);
		}
return GetRuleContext<EndExprContext>(0);
GetRuleContext<EndExprContext>(0)
GetRuleContext<EndExprContext>
<EndExprContext>
EndExprContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext[] moduleExpr() {
			return GetRuleContexts<ModuleExprContext>();
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleExprContext[]
ModuleExprContext
[]

()
{
			return GetRuleContexts<ModuleExprContext>();
		}
return GetRuleContexts<ModuleExprContext>();
GetRuleContexts<ModuleExprContext>()
GetRuleContexts<ModuleExprContext>
<ModuleExprContext>
ModuleExprContext
()
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr(int i) {
			return GetRuleContext<ModuleExprContext>(i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleExprContext
(int i)
int i
int
{
			return GetRuleContext<ModuleExprContext>(i);
		}
return GetRuleContext<ModuleExprContext>(i);
GetRuleContext<ModuleExprContext>(i)
GetRuleContext<ModuleExprContext>
<ModuleExprContext>
ModuleExprContext
(i)
i
i
public ModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_module; } }
int
{ get { return RULE_module; } }
get { return RULE_module; }
{ return RULE_module; }
return RULE_module;
RULE_module
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterModule(this);
typedListener != null
typedListener
null
typedListener.EnterModule(this);
typedListener.EnterModule(this)
typedListener.EnterModule
typedListener
EnterModule
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitModule(this);
typedListener != null
typedListener
null
typedListener.ExitModule(this);
typedListener.ExitModule(this)
typedListener.ExitModule
typedListener
ExitModule
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitModule(this);
typedVisitor.VisitModule(this)
typedVisitor.VisitModule
typedVisitor
VisitModule
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public ModuleContext module() {
		ModuleContext _localctx = new ModuleContext(Context, State);
		EnterRule(_localctx, 6, RULE_module);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
ModuleContext
()
{
		ModuleContext _localctx = new ModuleContext(Context, State);
		EnterRule(_localctx, 6, RULE_module);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
ModuleContext _localctx = new ModuleContext(Context, State);
ModuleContext _localctx = new ModuleContext(Context, State)
ModuleContext
_localctx = new ModuleContext(Context, State)
= new ModuleContext(Context, State)
new ModuleContext(Context, State)
ModuleContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 6, RULE_module);
EnterRule(_localctx, 6, RULE_module)
EnterRule
(_localctx, 6, RULE_module)
_localctx
_localctx
6
6
RULE_module
RULE_module
try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
int _alt;
int _alt
int
_alt
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
State = 99;
State = 99
State
99
Match(Module);
Match(Module)
Match
(Module)
Module
Module
State = 100;
State = 100
State
100
Match(Identifier);
Match(Identifier)
Match
(Identifier)
Identifier
Identifier
State = 104;
State = 104
State
104
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
_alt = Interpreter.AdaptivePredict(TokenStream,8,Context)
_alt
Interpreter.AdaptivePredict(TokenStream,8,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,8,Context)
TokenStream
TokenStream
8
8
Context
Context
while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
_alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
_alt!=2
_alt
2
_alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
_alt
global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
global::Antlr4.Runtime.Atn.ATN
global::Antlr4.Runtime.Atn
global::Antlr4.Runtime
global::Antlr4
global
Antlr4
Runtime
Atn
ATN
INVALID_ALT_NUMBER
{
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
_alt==1
_alt
1
{
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
{
					{
					State = 101;
					moduleExpr();
					}
					}
{
					State = 101;
					moduleExpr();
					}
State = 101;
State = 101
State
101
moduleExpr();
moduleExpr()
moduleExpr
()
State = 106;
State = 106
State
106
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
_alt = Interpreter.AdaptivePredict(TokenStream,8,Context)
_alt
Interpreter.AdaptivePredict(TokenStream,8,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,8,Context)
TokenStream
TokenStream
8
8
Context
Context
State = 107;
State = 107
State
107
endExpr();
endExpr()
endExpr
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class ModuleExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleExprContext
()
{
			return GetRuleContext<ModuleExprContext>(0);
		}
return GetRuleContext<ModuleExprContext>(0);
GetRuleContext<ModuleExprContext>(0)
GetRuleContext<ModuleExprContext>
<ModuleExprContext>
ModuleExprContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Termination, 0); }
return GetToken(JuliaParser.Termination, 0);
GetToken(JuliaParser.Termination, 0)
GetToken
(JuliaParser.Termination, 0)
JuliaParser.Termination
JuliaParser.Termination
JuliaParser
Termination
0
0
public ModuleExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_moduleExprStatement; } }
int
{ get { return RULE_moduleExprStatement; } }
get { return RULE_moduleExprStatement; }
{ return RULE_moduleExprStatement; }
return RULE_moduleExprStatement;
RULE_moduleExprStatement
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterModuleExprStatement(this);
typedListener != null
typedListener
null
typedListener.EnterModuleExprStatement(this);
typedListener.EnterModuleExprStatement(this)
typedListener.EnterModuleExprStatement
typedListener
EnterModuleExprStatement
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitModuleExprStatement(this);
typedListener != null
typedListener
null
typedListener.ExitModuleExprStatement(this);
typedListener.ExitModuleExprStatement(this)
typedListener.ExitModuleExprStatement
typedListener
ExitModuleExprStatement
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitModuleExprStatement(this);
typedVisitor.VisitModuleExprStatement(this)
typedVisitor.VisitModuleExprStatement
typedVisitor
VisitModuleExprStatement
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public ModuleExprStatementContext moduleExprStatement() {
		ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_moduleExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
ModuleExprStatementContext
()
{
		ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_moduleExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);
ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State)
ModuleExprStatementContext
_localctx = new ModuleExprStatementContext(Context, State)
= new ModuleExprStatementContext(Context, State)
new ModuleExprStatementContext(Context, State)
ModuleExprStatementContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 8, RULE_moduleExprStatement);
EnterRule(_localctx, 8, RULE_moduleExprStatement)
EnterRule
(_localctx, 8, RULE_moduleExprStatement)
_localctx
_localctx
8
8
RULE_moduleExprStatement
RULE_moduleExprStatement
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
State = 109;
State = 109
State
109
moduleExpr();
moduleExpr()
moduleExpr
()
State = 110;
State = 110
State
110
Match(Termination);
Match(Termination)
Match
(Termination)
Termination
Termination
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class UsingModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Using() { return GetToken(JuliaParser.Using, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		public UsingModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingModule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Using() { return GetToken(JuliaParser.Using, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Using, 0); }
return GetToken(JuliaParser.Using, 0);
GetToken(JuliaParser.Using, 0)
GetToken
(JuliaParser.Using, 0)
JuliaParser.Using
JuliaParser.Using
JuliaParser
Using
0
0
[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleRefContext
()
{
			return GetRuleContext<ModuleRefContext>(0);
		}
return GetRuleContext<ModuleRefContext>(0);
GetRuleContext<ModuleRefContext>(0)
GetRuleContext<ModuleRefContext>
<ModuleRefContext>
ModuleRefContext
(0)
0
0
public UsingModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_usingModule; } }
int
{ get { return RULE_usingModule; } }
get { return RULE_usingModule; }
{ return RULE_usingModule; }
return RULE_usingModule;
RULE_usingModule
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterUsingModule(this);
typedListener != null
typedListener
null
typedListener.EnterUsingModule(this);
typedListener.EnterUsingModule(this)
typedListener.EnterUsingModule
typedListener
EnterUsingModule
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitUsingModule(this);
typedListener != null
typedListener
null
typedListener.ExitUsingModule(this);
typedListener.ExitUsingModule(this)
typedListener.ExitUsingModule
typedListener
ExitUsingModule
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitUsingModule(this);
typedVisitor.VisitUsingModule(this)
typedVisitor.VisitUsingModule
typedVisitor
VisitUsingModule
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public UsingModuleContext usingModule() {
		UsingModuleContext _localctx = new UsingModuleContext(Context, State);
		EnterRule(_localctx, 10, RULE_usingModule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
UsingModuleContext
()
{
		UsingModuleContext _localctx = new UsingModuleContext(Context, State);
		EnterRule(_localctx, 10, RULE_usingModule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
UsingModuleContext _localctx = new UsingModuleContext(Context, State);
UsingModuleContext _localctx = new UsingModuleContext(Context, State)
UsingModuleContext
_localctx = new UsingModuleContext(Context, State)
= new UsingModuleContext(Context, State)
new UsingModuleContext(Context, State)
UsingModuleContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 10, RULE_usingModule);
EnterRule(_localctx, 10, RULE_usingModule)
EnterRule
(_localctx, 10, RULE_usingModule)
_localctx
_localctx
10
10
RULE_usingModule
RULE_usingModule
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
State = 112;
State = 112
State
112
Match(Using);
Match(Using)
Match
(Using)
Using
Using
State = 113;
State = 113
State
113
moduleRef();
moduleRef()
moduleRef
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class ModuleRefContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(JuliaParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(JuliaParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(JuliaParser.Dot); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(JuliaParser.Dot, i);
		}
		public ModuleRefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleRef; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(JuliaParser.Identifier); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode[]
ITerminalNode
[]

()
{ return GetTokens(JuliaParser.Identifier); }
return GetTokens(JuliaParser.Identifier);
GetTokens(JuliaParser.Identifier)
GetTokens
(JuliaParser.Identifier)
JuliaParser.Identifier
JuliaParser.Identifier
JuliaParser
Identifier
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(JuliaParser.Identifier, i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
(int i)
int i
int
{
			return GetToken(JuliaParser.Identifier, i);
		}
return GetToken(JuliaParser.Identifier, i);
GetToken(JuliaParser.Identifier, i)
GetToken
(JuliaParser.Identifier, i)
JuliaParser.Identifier
JuliaParser.Identifier
JuliaParser
Identifier
i
i
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(JuliaParser.Dot); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode[]
ITerminalNode
[]

()
{ return GetTokens(JuliaParser.Dot); }
return GetTokens(JuliaParser.Dot);
GetTokens(JuliaParser.Dot)
GetTokens
(JuliaParser.Dot)
JuliaParser.Dot
JuliaParser.Dot
JuliaParser
Dot
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(JuliaParser.Dot, i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
(int i)
int i
int
{
			return GetToken(JuliaParser.Dot, i);
		}
return GetToken(JuliaParser.Dot, i);
GetToken(JuliaParser.Dot, i)
GetToken
(JuliaParser.Dot, i)
JuliaParser.Dot
JuliaParser.Dot
JuliaParser
Dot
i
i
public ModuleRefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_moduleRef; } }
int
{ get { return RULE_moduleRef; } }
get { return RULE_moduleRef; }
{ return RULE_moduleRef; }
return RULE_moduleRef;
RULE_moduleRef
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterModuleRef(this);
typedListener != null
typedListener
null
typedListener.EnterModuleRef(this);
typedListener.EnterModuleRef(this)
typedListener.EnterModuleRef
typedListener
EnterModuleRef
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitModuleRef(this);
typedListener != null
typedListener
null
typedListener.ExitModuleRef(this);
typedListener.ExitModuleRef(this)
typedListener.ExitModuleRef
typedListener
ExitModuleRef
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitModuleRef(this);
typedVisitor.VisitModuleRef(this)
typedVisitor.VisitModuleRef
typedVisitor
VisitModuleRef
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public ModuleRefContext moduleRef() {
		ModuleRefContext _localctx = new ModuleRefContext(Context, State);
		EnterRule(_localctx, 12, RULE_moduleRef);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
ModuleRefContext
()
{
		ModuleRefContext _localctx = new ModuleRefContext(Context, State);
		EnterRule(_localctx, 12, RULE_moduleRef);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
ModuleRefContext _localctx = new ModuleRefContext(Context, State);
ModuleRefContext _localctx = new ModuleRefContext(Context, State)
ModuleRefContext
_localctx = new ModuleRefContext(Context, State)
= new ModuleRefContext(Context, State)
new ModuleRefContext(Context, State)
ModuleRefContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 12, RULE_moduleRef);
EnterRule(_localctx, 12, RULE_moduleRef)
EnterRule
(_localctx, 12, RULE_moduleRef)
_localctx
_localctx
12
12
RULE_moduleRef
RULE_moduleRef
try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
int _alt;
int _alt
int
_alt
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
State = 119;
State = 119
State
119
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
_alt = Interpreter.AdaptivePredict(TokenStream,9,Context)
_alt
Interpreter.AdaptivePredict(TokenStream,9,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,9,Context)
TokenStream
TokenStream
9
9
Context
Context
while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
_alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
_alt!=2
_alt
2
_alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
_alt
global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
global::Antlr4.Runtime.Atn.ATN
global::Antlr4.Runtime.Atn
global::Antlr4.Runtime
global::Antlr4
global
Antlr4
Runtime
Atn
ATN
INVALID_ALT_NUMBER
{
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
_alt==1
_alt
1
{
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					}
{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
State = 115;
State = 115
State
115
Match(Identifier);
Match(Identifier)
Match
(Identifier)
Identifier
Identifier
State = 116;
State = 116
State
116
Match(Dot);
Match(Dot)
Match
(Dot)
Dot
Dot
State = 121;
State = 121
State
121
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
_alt = Interpreter.AdaptivePredict(TokenStream,9,Context)
_alt
Interpreter.AdaptivePredict(TokenStream,9,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,9,Context)
TokenStream
TokenStream
9
9
Context
Context
State = 122;
State = 122
State
122
Match(Identifier);
Match(Identifier)
Match
(Identifier)
Identifier
Identifier
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class ModuleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(JuliaParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public ModuleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleRefContext
()
{
			return GetRuleContext<ModuleRefContext>(0);
		}
return GetRuleContext<ModuleRefContext>(0);
GetRuleContext<ModuleRefContext>(0)
GetRuleContext<ModuleRefContext>
<ModuleRefContext>
ModuleRefContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(JuliaParser.Dot, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Dot, 0); }
return GetToken(JuliaParser.Dot, 0);
GetToken(JuliaParser.Dot, 0)
GetToken
(JuliaParser.Dot, 0)
JuliaParser.Dot
JuliaParser.Dot
JuliaParser
Dot
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Identifier, 0); }
return GetToken(JuliaParser.Identifier, 0);
GetToken(JuliaParser.Identifier, 0)
GetToken
(JuliaParser.Identifier, 0)
JuliaParser.Identifier
JuliaParser.Identifier
JuliaParser
Identifier
0
0
public ModuleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_moduleIdentifier; } }
int
{ get { return RULE_moduleIdentifier; } }
get { return RULE_moduleIdentifier; }
{ return RULE_moduleIdentifier; }
return RULE_moduleIdentifier;
RULE_moduleIdentifier
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterModuleIdentifier(this);
typedListener != null
typedListener
null
typedListener.EnterModuleIdentifier(this);
typedListener.EnterModuleIdentifier(this)
typedListener.EnterModuleIdentifier
typedListener
EnterModuleIdentifier
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitModuleIdentifier(this);
typedListener != null
typedListener
null
typedListener.ExitModuleIdentifier(this);
typedListener.ExitModuleIdentifier(this)
typedListener.ExitModuleIdentifier
typedListener
ExitModuleIdentifier
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitModuleIdentifier(this);
typedVisitor.VisitModuleIdentifier(this)
typedVisitor.VisitModuleIdentifier
typedVisitor
VisitModuleIdentifier
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public ModuleIdentifierContext moduleIdentifier() {
		ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);
		EnterRule(_localctx, 14, RULE_moduleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
ModuleIdentifierContext
()
{
		ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);
		EnterRule(_localctx, 14, RULE_moduleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);
ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State)
ModuleIdentifierContext
_localctx = new ModuleIdentifierContext(Context, State)
= new ModuleIdentifierContext(Context, State)
new ModuleIdentifierContext(Context, State)
ModuleIdentifierContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 14, RULE_moduleIdentifier);
EnterRule(_localctx, 14, RULE_moduleIdentifier)
EnterRule
(_localctx, 14, RULE_moduleIdentifier)
_localctx
_localctx
14
14
RULE_moduleIdentifier
RULE_moduleIdentifier
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
State = 124;
State = 124
State
124
moduleRef();
moduleRef()
moduleRef
()
State = 125;
State = 125
State
125
Match(Dot);
Match(Dot)
Match
(Dot)
Dot
Dot
State = 126;
State = 126
State
126
Match(Identifier);
Match(Identifier)
Match
(Identifier)
Identifier
Identifier
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class SymbolIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleIdentifierContext moduleIdentifier() {
			return GetRuleContext<ModuleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public SymbolIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ModuleIdentifierContext moduleIdentifier() {
			return GetRuleContext<ModuleIdentifierContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleIdentifierContext
()
{
			return GetRuleContext<ModuleIdentifierContext>(0);
		}
return GetRuleContext<ModuleIdentifierContext>(0);
GetRuleContext<ModuleIdentifierContext>(0)
GetRuleContext<ModuleIdentifierContext>
<ModuleIdentifierContext>
ModuleIdentifierContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Identifier, 0); }
return GetToken(JuliaParser.Identifier, 0);
GetToken(JuliaParser.Identifier, 0)
GetToken
(JuliaParser.Identifier, 0)
JuliaParser.Identifier
JuliaParser.Identifier
JuliaParser
Identifier
0
0
public SymbolIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_symbolIdentifier; } }
int
{ get { return RULE_symbolIdentifier; } }
get { return RULE_symbolIdentifier; }
{ return RULE_symbolIdentifier; }
return RULE_symbolIdentifier;
RULE_symbolIdentifier
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
typedListener != null
typedListener
null
typedListener.EnterSymbolIdentifier(this);
typedListener.EnterSymbolIdentifier(this)
typedListener.EnterSymbolIdentifier
typedListener
EnterSymbolIdentifier
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
typedListener != null
typedListener
null
typedListener.ExitSymbolIdentifier(this);
typedListener.ExitSymbolIdentifier(this)
typedListener.ExitSymbolIdentifier
typedListener
ExitSymbolIdentifier
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitSymbolIdentifier(this);
typedVisitor.VisitSymbolIdentifier(this)
typedVisitor.VisitSymbolIdentifier
typedVisitor
VisitSymbolIdentifier
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public SymbolIdentifierContext symbolIdentifier() {
		SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);
		EnterRule(_localctx, 16, RULE_symbolIdentifier);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
SymbolIdentifierContext
()
{
		SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);
		EnterRule(_localctx, 16, RULE_symbolIdentifier);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);
SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State)
SymbolIdentifierContext
_localctx = new SymbolIdentifierContext(Context, State)
= new SymbolIdentifierContext(Context, State)
new SymbolIdentifierContext(Context, State)
SymbolIdentifierContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 16, RULE_symbolIdentifier);
EnterRule(_localctx, 16, RULE_symbolIdentifier)
EnterRule
(_localctx, 16, RULE_symbolIdentifier)
_localctx
_localctx
16
16
RULE_symbolIdentifier
RULE_symbolIdentifier
try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
State = 130;
State = 130
State
130
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
Interpreter.AdaptivePredict(TokenStream,10,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,10,Context)
TokenStream
TokenStream
10
10
Context
Context
case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
case 1:
1
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
				State = 128;
				moduleIdentifier();
				}
State = 128;
State = 128
State
128
moduleIdentifier();
moduleIdentifier()
moduleIdentifier
()
break;
case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
case 2:
2
EnterOuterAlt(_localctx, 2);
EnterOuterAlt(_localctx, 2)
EnterOuterAlt
(_localctx, 2)
_localctx
_localctx
2
2
{
				State = 129;
				Match(Identifier);
				}
State = 129;
State = 129
State
129
Match(Identifier);
Match(Identifier)
Match
(Identifier)
Identifier
Identifier
break;
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class AbstractStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AbstractType() { return GetToken(JuliaParser.AbstractType, 0); }
		public AbstractStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abstractStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AbstractType() { return GetToken(JuliaParser.AbstractType, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.AbstractType, 0); }
return GetToken(JuliaParser.AbstractType, 0);
GetToken(JuliaParser.AbstractType, 0)
GetToken
(JuliaParser.AbstractType, 0)
JuliaParser.AbstractType
JuliaParser.AbstractType
JuliaParser
AbstractType
0
0
public AbstractStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_abstractStructure; } }
int
{ get { return RULE_abstractStructure; } }
get { return RULE_abstractStructure; }
{ return RULE_abstractStructure; }
return RULE_abstractStructure;
RULE_abstractStructure
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterAbstractStructure(this);
typedListener != null
typedListener
null
typedListener.EnterAbstractStructure(this);
typedListener.EnterAbstractStructure(this)
typedListener.EnterAbstractStructure
typedListener
EnterAbstractStructure
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitAbstractStructure(this);
typedListener != null
typedListener
null
typedListener.ExitAbstractStructure(this);
typedListener.ExitAbstractStructure(this)
typedListener.ExitAbstractStructure
typedListener
ExitAbstractStructure
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitAbstractStructure(this);
typedVisitor.VisitAbstractStructure(this)
typedVisitor.VisitAbstractStructure
typedVisitor
VisitAbstractStructure
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public AbstractStructureContext abstractStructure() {
		AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);
		EnterRule(_localctx, 18, RULE_abstractStructure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
AbstractStructureContext
()
{
		AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);
		EnterRule(_localctx, 18, RULE_abstractStructure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);
AbstractStructureContext _localctx = new AbstractStructureContext(Context, State)
AbstractStructureContext
_localctx = new AbstractStructureContext(Context, State)
= new AbstractStructureContext(Context, State)
new AbstractStructureContext(Context, State)
AbstractStructureContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 18, RULE_abstractStructure);
EnterRule(_localctx, 18, RULE_abstractStructure)
EnterRule
(_localctx, 18, RULE_abstractStructure)
_localctx
_localctx
18
18
RULE_abstractStructure
RULE_abstractStructure
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 132;
			Match(AbstractType);
			}
State = 132;
State = 132
State
132
Match(AbstractType);
Match(AbstractType)
Match
(AbstractType)
AbstractType
AbstractType
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class CompositeStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(JuliaParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mutable() { return GetToken(JuliaParser.Mutable, 0); }
		public CompositeStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compositeStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(JuliaParser.Struct, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Struct, 0); }
return GetToken(JuliaParser.Struct, 0);
GetToken(JuliaParser.Struct, 0)
GetToken
(JuliaParser.Struct, 0)
JuliaParser.Struct
JuliaParser.Struct
JuliaParser
Struct
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mutable() { return GetToken(JuliaParser.Mutable, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Mutable, 0); }
return GetToken(JuliaParser.Mutable, 0);
GetToken(JuliaParser.Mutable, 0)
GetToken
(JuliaParser.Mutable, 0)
JuliaParser.Mutable
JuliaParser.Mutable
JuliaParser
Mutable
0
0
public CompositeStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_compositeStructure; } }
int
{ get { return RULE_compositeStructure; } }
get { return RULE_compositeStructure; }
{ return RULE_compositeStructure; }
return RULE_compositeStructure;
RULE_compositeStructure
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterCompositeStructure(this);
typedListener != null
typedListener
null
typedListener.EnterCompositeStructure(this);
typedListener.EnterCompositeStructure(this)
typedListener.EnterCompositeStructure
typedListener
EnterCompositeStructure
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitCompositeStructure(this);
typedListener != null
typedListener
null
typedListener.ExitCompositeStructure(this);
typedListener.ExitCompositeStructure(this)
typedListener.ExitCompositeStructure
typedListener
ExitCompositeStructure
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitCompositeStructure(this);
typedVisitor.VisitCompositeStructure(this)
typedVisitor.VisitCompositeStructure
typedVisitor
VisitCompositeStructure
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public CompositeStructureContext compositeStructure() {
		CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);
		EnterRule(_localctx, 20, RULE_compositeStructure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
CompositeStructureContext
()
{
		CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);
		EnterRule(_localctx, 20, RULE_compositeStructure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);
CompositeStructureContext _localctx = new CompositeStructureContext(Context, State)
CompositeStructureContext
_localctx = new CompositeStructureContext(Context, State)
= new CompositeStructureContext(Context, State)
new CompositeStructureContext(Context, State)
CompositeStructureContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 20, RULE_compositeStructure);
EnterRule(_localctx, 20, RULE_compositeStructure)
EnterRule
(_localctx, 20, RULE_compositeStructure)
_localctx
_localctx
20
20
RULE_compositeStructure
RULE_compositeStructure
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
State = 135;
State = 135
State
135
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}
_la==Mutable
_la
Mutable
{
				{
				State = 134;
				Match(Mutable);
				}
			}
{
				State = 134;
				Match(Mutable);
				}
State = 134;
State = 134
State
134
Match(Mutable);
Match(Mutable)
Match
(Mutable)
Mutable
Mutable
State = 137;
State = 137
State
137
Match(Struct);
Match(Struct)
Match
(Struct)
Struct
Struct
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class StructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractStructureContext abstractStructure() {
			return GetRuleContext<AbstractStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompositeStructureContext compositeStructure() {
			return GetRuleContext<CompositeStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext[] structItem() {
			return GetRuleContexts<StructItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext structItem(int i) {
			return GetRuleContext<StructItemContext>(i);
		}
		public StructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TypeNameContext
()
{
			return GetRuleContext<TypeNameContext>(0);
		}
return GetRuleContext<TypeNameContext>(0);
GetRuleContext<TypeNameContext>(0)
GetRuleContext<TypeNameContext>
<TypeNameContext>
TypeNameContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
EndExprContext
()
{
			return GetRuleContext<EndExprContext>(0);
		}
return GetRuleContext<EndExprContext>(0);
GetRuleContext<EndExprContext>(0)
GetRuleContext<EndExprContext>
<EndExprContext>
EndExprContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public AbstractStructureContext abstractStructure() {
			return GetRuleContext<AbstractStructureContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
AbstractStructureContext
()
{
			return GetRuleContext<AbstractStructureContext>(0);
		}
return GetRuleContext<AbstractStructureContext>(0);
GetRuleContext<AbstractStructureContext>(0)
GetRuleContext<AbstractStructureContext>
<AbstractStructureContext>
AbstractStructureContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public CompositeStructureContext compositeStructure() {
			return GetRuleContext<CompositeStructureContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
CompositeStructureContext
()
{
			return GetRuleContext<CompositeStructureContext>(0);
		}
return GetRuleContext<CompositeStructureContext>(0);
GetRuleContext<CompositeStructureContext>(0)
GetRuleContext<CompositeStructureContext>
<CompositeStructureContext>
CompositeStructureContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public StructItemContext[] structItem() {
			return GetRuleContexts<StructItemContext>();
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
StructItemContext[]
StructItemContext
[]

()
{
			return GetRuleContexts<StructItemContext>();
		}
return GetRuleContexts<StructItemContext>();
GetRuleContexts<StructItemContext>()
GetRuleContexts<StructItemContext>
<StructItemContext>
StructItemContext
()
[System.Diagnostics.DebuggerNonUserCode] public StructItemContext structItem(int i) {
			return GetRuleContext<StructItemContext>(i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
StructItemContext
(int i)
int i
int
{
			return GetRuleContext<StructItemContext>(i);
		}
return GetRuleContext<StructItemContext>(i);
GetRuleContext<StructItemContext>(i)
GetRuleContext<StructItemContext>
<StructItemContext>
StructItemContext
(i)
i
i
public StructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_structure; } }
int
{ get { return RULE_structure; } }
get { return RULE_structure; }
{ return RULE_structure; }
return RULE_structure;
RULE_structure
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterStructure(this);
typedListener != null
typedListener
null
typedListener.EnterStructure(this);
typedListener.EnterStructure(this)
typedListener.EnterStructure
typedListener
EnterStructure
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitStructure(this);
typedListener != null
typedListener
null
typedListener.ExitStructure(this);
typedListener.ExitStructure(this)
typedListener.ExitStructure
typedListener
ExitStructure
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitStructure(this);
typedVisitor.VisitStructure(this)
typedVisitor.VisitStructure
typedVisitor
VisitStructure
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public StructureContext structure() {
		StructureContext _localctx = new StructureContext(Context, State);
		EnterRule(_localctx, 22, RULE_structure);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
StructureContext
()
{
		StructureContext _localctx = new StructureContext(Context, State);
		EnterRule(_localctx, 22, RULE_structure);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
StructureContext _localctx = new StructureContext(Context, State);
StructureContext _localctx = new StructureContext(Context, State)
StructureContext
_localctx = new StructureContext(Context, State)
= new StructureContext(Context, State)
new StructureContext(Context, State)
StructureContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 22, RULE_structure);
EnterRule(_localctx, 22, RULE_structure)
EnterRule
(_localctx, 22, RULE_structure)
_localctx
_localctx
22
22
RULE_structure
RULE_structure
try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
int _alt;
int _alt
int
_alt
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
State = 141;
State = 141
State
141
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
case AbstractType:
AbstractType
{
				State = 139;
				abstractStructure();
				}
State = 139;
State = 139
State
139
abstractStructure();
abstractStructure()
abstractStructure
()
break;
case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
case Mutable:
Mutable
case Struct:
Struct
{
				State = 140;
				compositeStructure();
				}
State = 140;
State = 140
State
140
compositeStructure();
compositeStructure()
compositeStructure
()
break;
default:
				throw new NoViableAltException(this);
default:
throw new NoViableAltException(this);
new NoViableAltException(this)
NoViableAltException
(this)
this
this
State = 143;
State = 143
State
143
typeName();
typeName()
typeName
()
State = 147;
State = 147
State
147
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
_alt = Interpreter.AdaptivePredict(TokenStream,13,Context)
_alt
Interpreter.AdaptivePredict(TokenStream,13,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,13,Context)
TokenStream
TokenStream
13
13
Context
Context
while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
_alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
_alt!=2
_alt
2
_alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
_alt
global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
global::Antlr4.Runtime.Atn.ATN
global::Antlr4.Runtime.Atn
global::Antlr4.Runtime
global::Antlr4
global
Antlr4
Runtime
Atn
ATN
INVALID_ALT_NUMBER
{
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
_alt==1
_alt
1
{
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
{
					{
					State = 144;
					structItem();
					}
					}
{
					State = 144;
					structItem();
					}
State = 144;
State = 144
State
144
structItem();
structItem()
structItem
()
State = 149;
State = 149
State
149
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
_alt = Interpreter.AdaptivePredict(TokenStream,13,Context)
_alt
Interpreter.AdaptivePredict(TokenStream,13,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,13,Context)
TokenStream
TokenStream
13
13
Context
Context
State = 150;
State = 150
State
150
endExpr();
endExpr()
endExpr
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class StructFieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structField; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockArgContext
()
{
			return GetRuleContext<BlockArgContext>(0);
		}
return GetRuleContext<BlockArgContext>(0);
GetRuleContext<BlockArgContext>(0)
GetRuleContext<BlockArgContext>
<BlockArgContext>
BlockArgContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Const, 0); }
return GetToken(JuliaParser.Const, 0);
GetToken(JuliaParser.Const, 0)
GetToken
(JuliaParser.Const, 0)
JuliaParser.Const
JuliaParser.Const
JuliaParser
Const
0
0
public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_structField; } }
int
{ get { return RULE_structField; } }
get { return RULE_structField; }
{ return RULE_structField; }
return RULE_structField;
RULE_structField
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterStructField(this);
typedListener != null
typedListener
null
typedListener.EnterStructField(this);
typedListener.EnterStructField(this)
typedListener.EnterStructField
typedListener
EnterStructField
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitStructField(this);
typedListener != null
typedListener
null
typedListener.ExitStructField(this);
typedListener.ExitStructField(this)
typedListener.ExitStructField
typedListener
ExitStructField
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitStructField(this);
typedVisitor.VisitStructField(this)
typedVisitor.VisitStructField
typedVisitor
VisitStructField
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public StructFieldContext structField() {
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 24, RULE_structField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
StructFieldContext
()
{
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 24, RULE_structField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
StructFieldContext _localctx = new StructFieldContext(Context, State);
StructFieldContext _localctx = new StructFieldContext(Context, State)
StructFieldContext
_localctx = new StructFieldContext(Context, State)
= new StructFieldContext(Context, State)
new StructFieldContext(Context, State)
StructFieldContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 24, RULE_structField);
EnterRule(_localctx, 24, RULE_structField)
EnterRule
(_localctx, 24, RULE_structField)
_localctx
_localctx
24
24
RULE_structField
RULE_structField
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
State = 153;
State = 153
State
153
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}
_la==Const
_la
Const
{
				{
				State = 152;
				Match(Const);
				}
			}
{
				State = 152;
				Match(Const);
				}
State = 152;
State = 152
State
152
Match(Const);
Match(Const)
Match
(Const)
Const
Const
State = 155;
State = 155
State
155
blockArg();
blockArg()
blockArg
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class StructItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Termination() { return GetTokens(JuliaParser.Termination); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination(int i) {
			return GetToken(JuliaParser.Termination, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext structField() {
			return GetRuleContext<StructFieldContext>(0);
		}
		public StructItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Termination() { return GetTokens(JuliaParser.Termination); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode[]
ITerminalNode
[]

()
{ return GetTokens(JuliaParser.Termination); }
return GetTokens(JuliaParser.Termination);
GetTokens(JuliaParser.Termination)
GetTokens
(JuliaParser.Termination)
JuliaParser.Termination
JuliaParser.Termination
JuliaParser
Termination
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination(int i) {
			return GetToken(JuliaParser.Termination, i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
(int i)
int i
int
{
			return GetToken(JuliaParser.Termination, i);
		}
return GetToken(JuliaParser.Termination, i);
GetToken(JuliaParser.Termination, i)
GetToken
(JuliaParser.Termination, i)
JuliaParser.Termination
JuliaParser.Termination
JuliaParser
Termination
i
i
[System.Diagnostics.DebuggerNonUserCode] public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
FunctionContext
()
{
			return GetRuleContext<FunctionContext>(0);
		}
return GetRuleContext<FunctionContext>(0);
GetRuleContext<FunctionContext>(0)
GetRuleContext<FunctionContext>
<FunctionContext>
FunctionContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext structField() {
			return GetRuleContext<StructFieldContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
StructFieldContext
()
{
			return GetRuleContext<StructFieldContext>(0);
		}
return GetRuleContext<StructFieldContext>(0);
GetRuleContext<StructFieldContext>(0)
GetRuleContext<StructFieldContext>
<StructFieldContext>
StructFieldContext
(0)
0
0
public StructItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_structItem; } }
int
{ get { return RULE_structItem; } }
get { return RULE_structItem; }
{ return RULE_structItem; }
return RULE_structItem;
RULE_structItem
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterStructItem(this);
typedListener != null
typedListener
null
typedListener.EnterStructItem(this);
typedListener.EnterStructItem(this)
typedListener.EnterStructItem
typedListener
EnterStructItem
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitStructItem(this);
typedListener != null
typedListener
null
typedListener.ExitStructItem(this);
typedListener.ExitStructItem(this)
typedListener.ExitStructItem
typedListener
ExitStructItem
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitStructItem(this);
typedVisitor.VisitStructItem(this)
typedVisitor.VisitStructItem
typedVisitor
VisitStructItem
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public StructItemContext structItem() {
		StructItemContext _localctx = new StructItemContext(Context, State);
		EnterRule(_localctx, 26, RULE_structItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
StructItemContext
()
{
		StructItemContext _localctx = new StructItemContext(Context, State);
		EnterRule(_localctx, 26, RULE_structItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
StructItemContext _localctx = new StructItemContext(Context, State);
StructItemContext _localctx = new StructItemContext(Context, State)
StructItemContext
_localctx = new StructItemContext(Context, State)
= new StructItemContext(Context, State)
new StructItemContext(Context, State)
StructItemContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 26, RULE_structItem);
EnterRule(_localctx, 26, RULE_structItem)
EnterRule
(_localctx, 26, RULE_structItem)
_localctx
_localctx
26
26
RULE_structItem
RULE_structItem
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
State = 158;
State = 158
State
158
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}
_la==Termination
_la
Termination
{
				{
				State = 157;
				Match(Termination);
				}
			}
{
				State = 157;
				Match(Termination);
				}
State = 157;
State = 157
State
157
Match(Termination);
Match(Termination)
Match
(Termination)
Termination
Termination
State = 162;
State = 162
State
162
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
Interpreter.AdaptivePredict(TokenStream,16,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,16,Context)
TokenStream
TokenStream
16
16
Context
Context
case 1:
				{
				State = 160;
				function();
				}
				break;
case 1:
1
{
				State = 160;
				function();
				}
State = 160;
State = 160
State
160
function();
function()
function
()
break;
case 2:
				{
				State = 161;
				structField();
				}
				break;
case 2:
2
{
				State = 161;
				structField();
				}
State = 161;
State = 161
State
161
structField();
structField()
structField
()
break;
State = 164;
State = 164
State
164
Match(Termination);
Match(Termination)
Match
(Termination)
Termination
Termination
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class BlockExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableDeclarationContext blockVariableDeclaration() {
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}
		public BlockExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
FunctionCallContext
()
{
			return GetRuleContext<FunctionCallContext>(0);
		}
return GetRuleContext<FunctionCallContext>(0);
GetRuleContext<FunctionCallContext>(0)
GetRuleContext<FunctionCallContext>
<FunctionCallContext>
FunctionCallContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public BlockVariableDeclarationContext blockVariableDeclaration() {
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockVariableDeclarationContext
()
{
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}
return GetRuleContext<BlockVariableDeclarationContext>(0);
GetRuleContext<BlockVariableDeclarationContext>(0)
GetRuleContext<BlockVariableDeclarationContext>
<BlockVariableDeclarationContext>
BlockVariableDeclarationContext
(0)
0
0
public BlockExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_blockExpr; } }
int
{ get { return RULE_blockExpr; } }
get { return RULE_blockExpr; }
{ return RULE_blockExpr; }
return RULE_blockExpr;
RULE_blockExpr
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterBlockExpr(this);
typedListener != null
typedListener
null
typedListener.EnterBlockExpr(this);
typedListener.EnterBlockExpr(this)
typedListener.EnterBlockExpr
typedListener
EnterBlockExpr
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitBlockExpr(this);
typedListener != null
typedListener
null
typedListener.ExitBlockExpr(this);
typedListener.ExitBlockExpr(this)
typedListener.ExitBlockExpr
typedListener
ExitBlockExpr
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitBlockExpr(this);
typedVisitor.VisitBlockExpr(this)
typedVisitor.VisitBlockExpr
typedVisitor
VisitBlockExpr
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public BlockExprContext blockExpr() {
		BlockExprContext _localctx = new BlockExprContext(Context, State);
		EnterRule(_localctx, 28, RULE_blockExpr);
		try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
BlockExprContext
()
{
		BlockExprContext _localctx = new BlockExprContext(Context, State);
		EnterRule(_localctx, 28, RULE_blockExpr);
		try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
BlockExprContext _localctx = new BlockExprContext(Context, State);
BlockExprContext _localctx = new BlockExprContext(Context, State)
BlockExprContext
_localctx = new BlockExprContext(Context, State)
= new BlockExprContext(Context, State)
new BlockExprContext(Context, State)
BlockExprContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 28, RULE_blockExpr);
EnterRule(_localctx, 28, RULE_blockExpr)
EnterRule
(_localctx, 28, RULE_blockExpr)
_localctx
_localctx
28
28
RULE_blockExpr
RULE_blockExpr
try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
State = 168;
State = 168
State
168
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
Interpreter.AdaptivePredict(TokenStream,17,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,17,Context)
TokenStream
TokenStream
17
17
Context
Context
case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
case 1:
1
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
				State = 166;
				functionCall();
				}
State = 166;
State = 166
State
166
functionCall();
functionCall()
functionCall
()
break;
case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
case 2:
2
EnterOuterAlt(_localctx, 2);
EnterOuterAlt(_localctx, 2)
EnterOuterAlt
(_localctx, 2)
_localctx
_localctx
2
2
{
				State = 167;
				blockVariableDeclaration();
				}
State = 167;
State = 167
State
167
blockVariableDeclaration();
blockVariableDeclaration()
blockVariableDeclaration
()
break;
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class BlockExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public BlockExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockExprContext
()
{
			return GetRuleContext<BlockExprContext>(0);
		}
return GetRuleContext<BlockExprContext>(0);
GetRuleContext<BlockExprContext>(0)
GetRuleContext<BlockExprContext>
<BlockExprContext>
BlockExprContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Termination, 0); }
return GetToken(JuliaParser.Termination, 0);
GetToken(JuliaParser.Termination, 0)
GetToken
(JuliaParser.Termination, 0)
JuliaParser.Termination
JuliaParser.Termination
JuliaParser
Termination
0
0
public BlockExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_blockExprStatement; } }
int
{ get { return RULE_blockExprStatement; } }
get { return RULE_blockExprStatement; }
{ return RULE_blockExprStatement; }
return RULE_blockExprStatement;
RULE_blockExprStatement
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterBlockExprStatement(this);
typedListener != null
typedListener
null
typedListener.EnterBlockExprStatement(this);
typedListener.EnterBlockExprStatement(this)
typedListener.EnterBlockExprStatement
typedListener
EnterBlockExprStatement
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitBlockExprStatement(this);
typedListener != null
typedListener
null
typedListener.ExitBlockExprStatement(this);
typedListener.ExitBlockExprStatement(this)
typedListener.ExitBlockExprStatement
typedListener
ExitBlockExprStatement
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitBlockExprStatement(this);
typedVisitor.VisitBlockExprStatement(this)
typedVisitor.VisitBlockExprStatement
typedVisitor
VisitBlockExprStatement
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public BlockExprStatementContext blockExprStatement() {
		BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_blockExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
BlockExprStatementContext
()
{
		BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_blockExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);
BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State)
BlockExprStatementContext
_localctx = new BlockExprStatementContext(Context, State)
= new BlockExprStatementContext(Context, State)
new BlockExprStatementContext(Context, State)
BlockExprStatementContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 30, RULE_blockExprStatement);
EnterRule(_localctx, 30, RULE_blockExprStatement)
EnterRule
(_localctx, 30, RULE_blockExprStatement)
_localctx
_localctx
30
30
RULE_blockExprStatement
RULE_blockExprStatement
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
State = 170;
State = 170
State
170
blockExpr();
blockExpr()
blockExpr
()
State = 171;
State = 171
State
171
Match(Termination);
Match(Termination)
Match
(Termination)
Termination
Termination
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class BlockVariableInstatiationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assignment() { return GetToken(JuliaParser.Assignment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		public BlockVariableInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableInstatiation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assignment() { return GetToken(JuliaParser.Assignment, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Assignment, 0); }
return GetToken(JuliaParser.Assignment, 0);
GetToken(JuliaParser.Assignment, 0)
GetToken
(JuliaParser.Assignment, 0)
JuliaParser.Assignment
JuliaParser.Assignment
JuliaParser
Assignment
0
0
[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockExprContext
()
{
			return GetRuleContext<BlockExprContext>(0);
		}
return GetRuleContext<BlockExprContext>(0);
GetRuleContext<BlockExprContext>(0)
GetRuleContext<BlockExprContext>
<BlockExprContext>
BlockExprContext
(0)
0
0
public BlockVariableInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_blockVariableInstatiation; } }
int
{ get { return RULE_blockVariableInstatiation; } }
get { return RULE_blockVariableInstatiation; }
{ return RULE_blockVariableInstatiation; }
return RULE_blockVariableInstatiation;
RULE_blockVariableInstatiation
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
typedListener != null
typedListener
null
typedListener.EnterBlockVariableInstatiation(this);
typedListener.EnterBlockVariableInstatiation(this)
typedListener.EnterBlockVariableInstatiation
typedListener
EnterBlockVariableInstatiation
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
typedListener != null
typedListener
null
typedListener.ExitBlockVariableInstatiation(this);
typedListener.ExitBlockVariableInstatiation(this)
typedListener.ExitBlockVariableInstatiation
typedListener
ExitBlockVariableInstatiation
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitBlockVariableInstatiation(this);
typedVisitor.VisitBlockVariableInstatiation(this)
typedVisitor.VisitBlockVariableInstatiation
typedVisitor
VisitBlockVariableInstatiation
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public BlockVariableInstatiationContext blockVariableInstatiation() {
		BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);
		EnterRule(_localctx, 32, RULE_blockVariableInstatiation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
BlockVariableInstatiationContext
()
{
		BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);
		EnterRule(_localctx, 32, RULE_blockVariableInstatiation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);
BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State)
BlockVariableInstatiationContext
_localctx = new BlockVariableInstatiationContext(Context, State)
= new BlockVariableInstatiationContext(Context, State)
new BlockVariableInstatiationContext(Context, State)
BlockVariableInstatiationContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 32, RULE_blockVariableInstatiation);
EnterRule(_localctx, 32, RULE_blockVariableInstatiation)
EnterRule
(_localctx, 32, RULE_blockVariableInstatiation)
_localctx
_localctx
32
32
RULE_blockVariableInstatiation
RULE_blockVariableInstatiation
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
State = 173;
State = 173
State
173
Match(Assignment);
Match(Assignment)
Match
(Assignment)
Assignment
Assignment
State = 174;
State = 174
State
174
blockExpr();
blockExpr()
blockExpr
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class BlockArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ValueType() { return GetToken(JuliaParser.ValueType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public BlockArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Identifier, 0); }
return GetToken(JuliaParser.Identifier, 0);
GetToken(JuliaParser.Identifier, 0)
GetToken
(JuliaParser.Identifier, 0)
JuliaParser.Identifier
JuliaParser.Identifier
JuliaParser
Identifier
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ValueType() { return GetToken(JuliaParser.ValueType, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.ValueType, 0); }
return GetToken(JuliaParser.ValueType, 0);
GetToken(JuliaParser.ValueType, 0)
GetToken
(JuliaParser.ValueType, 0)
JuliaParser.ValueType
JuliaParser.ValueType
JuliaParser
ValueType
0
0
[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TypeContext
()
{
			return GetRuleContext<TypeContext>(0);
		}
return GetRuleContext<TypeContext>(0);
GetRuleContext<TypeContext>(0)
GetRuleContext<TypeContext>
<TypeContext>
TypeContext
(0)
0
0
public BlockArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_blockArg; } }
int
{ get { return RULE_blockArg; } }
get { return RULE_blockArg; }
{ return RULE_blockArg; }
return RULE_blockArg;
RULE_blockArg
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterBlockArg(this);
typedListener != null
typedListener
null
typedListener.EnterBlockArg(this);
typedListener.EnterBlockArg(this)
typedListener.EnterBlockArg
typedListener
EnterBlockArg
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitBlockArg(this);
typedListener != null
typedListener
null
typedListener.ExitBlockArg(this);
typedListener.ExitBlockArg(this)
typedListener.ExitBlockArg
typedListener
ExitBlockArg
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitBlockArg(this);
typedVisitor.VisitBlockArg(this)
typedVisitor.VisitBlockArg
typedVisitor
VisitBlockArg
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public BlockArgContext blockArg() {
		BlockArgContext _localctx = new BlockArgContext(Context, State);
		EnterRule(_localctx, 34, RULE_blockArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
BlockArgContext
()
{
		BlockArgContext _localctx = new BlockArgContext(Context, State);
		EnterRule(_localctx, 34, RULE_blockArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
BlockArgContext _localctx = new BlockArgContext(Context, State);
BlockArgContext _localctx = new BlockArgContext(Context, State)
BlockArgContext
_localctx = new BlockArgContext(Context, State)
= new BlockArgContext(Context, State)
new BlockArgContext(Context, State)
BlockArgContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 34, RULE_blockArg);
EnterRule(_localctx, 34, RULE_blockArg)
EnterRule
(_localctx, 34, RULE_blockArg)
_localctx
_localctx
34
34
RULE_blockArg
RULE_blockArg
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
State = 176;
State = 176
State
176
Match(Identifier);
Match(Identifier)
Match
(Identifier)
Identifier
Identifier
State = 179;
State = 179
State
179
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}
_la==ValueType
_la
ValueType
{
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}
{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
State = 177;
State = 177
State
177
Match(ValueType);
Match(ValueType)
Match
(ValueType)
ValueType
ValueType
State = 178;
State = 178
State
178
type();
type()
type
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class BlockVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Global() { return GetToken(JuliaParser.Global, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		public BlockVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockArgContext
()
{
			return GetRuleContext<BlockArgContext>(0);
		}
return GetRuleContext<BlockArgContext>(0);
GetRuleContext<BlockArgContext>(0)
GetRuleContext<BlockArgContext>
<BlockArgContext>
BlockArgContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Const, 0); }
return GetToken(JuliaParser.Const, 0);
GetToken(JuliaParser.Const, 0)
GetToken
(JuliaParser.Const, 0)
JuliaParser.Const
JuliaParser.Const
JuliaParser
Const
0
0
[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockVariableInstatiationContext
()
{
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
return GetRuleContext<BlockVariableInstatiationContext>(0);
GetRuleContext<BlockVariableInstatiationContext>(0)
GetRuleContext<BlockVariableInstatiationContext>
<BlockVariableInstatiationContext>
BlockVariableInstatiationContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Global() { return GetToken(JuliaParser.Global, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Global, 0); }
return GetToken(JuliaParser.Global, 0);
GetToken(JuliaParser.Global, 0)
GetToken
(JuliaParser.Global, 0)
JuliaParser.Global
JuliaParser.Global
JuliaParser
Global
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Local, 0); }
return GetToken(JuliaParser.Local, 0);
GetToken(JuliaParser.Local, 0)
GetToken
(JuliaParser.Local, 0)
JuliaParser.Local
JuliaParser.Local
JuliaParser
Local
0
0
public BlockVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_blockVariableDeclaration; } }
int
{ get { return RULE_blockVariableDeclaration; } }
get { return RULE_blockVariableDeclaration; }
{ return RULE_blockVariableDeclaration; }
return RULE_blockVariableDeclaration;
RULE_blockVariableDeclaration
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
typedListener != null
typedListener
null
typedListener.EnterBlockVariableDeclaration(this);
typedListener.EnterBlockVariableDeclaration(this)
typedListener.EnterBlockVariableDeclaration
typedListener
EnterBlockVariableDeclaration
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
typedListener != null
typedListener
null
typedListener.ExitBlockVariableDeclaration(this);
typedListener.ExitBlockVariableDeclaration(this)
typedListener.ExitBlockVariableDeclaration
typedListener
ExitBlockVariableDeclaration
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitBlockVariableDeclaration(this);
typedVisitor.VisitBlockVariableDeclaration(this)
typedVisitor.VisitBlockVariableDeclaration
typedVisitor
VisitBlockVariableDeclaration
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public BlockVariableDeclarationContext blockVariableDeclaration() {
		BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 36, RULE_blockVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
BlockVariableDeclarationContext
()
{
		BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 36, RULE_blockVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);
BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State)
BlockVariableDeclarationContext
_localctx = new BlockVariableDeclarationContext(Context, State)
= new BlockVariableDeclarationContext(Context, State)
new BlockVariableDeclarationContext(Context, State)
BlockVariableDeclarationContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 36, RULE_blockVariableDeclaration);
EnterRule(_localctx, 36, RULE_blockVariableDeclaration)
EnterRule
(_localctx, 36, RULE_blockVariableDeclaration)
_localctx
_localctx
36
36
RULE_blockVariableDeclaration
RULE_blockVariableDeclaration
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
State = 182;
State = 182
State
182
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}
_la==Const
_la
Const
{
				{
				State = 181;
				Match(Const);
				}
			}
{
				State = 181;
				Match(Const);
				}
State = 181;
State = 181
State
181
Match(Const);
Match(Const)
Match
(Const)
Const
Const
State = 185;
State = 185
State
185
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}
_la==Global || _la==Local
_la==Global
_la
Global
_la==Local
_la
Local
{
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}
{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
State = 184;
State = 184
State
184
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
!(_la==Global || _la==Local)
(_la==Global || _la==Local)
_la==Global || _la==Local
_la==Global
_la
Global
_la==Local
_la
Local
{
				ErrorHandler.RecoverInline(this);
				}
ErrorHandler.RecoverInline(this);
ErrorHandler.RecoverInline(this)
ErrorHandler.RecoverInline
ErrorHandler
RecoverInline
(this)
this
this
else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
{
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
ErrorHandler.ReportMatch(this);
ErrorHandler.ReportMatch(this)
ErrorHandler.ReportMatch
ErrorHandler
ReportMatch
(this)
this
this
Consume();
Consume()
Consume
()
State = 187;
State = 187
State
187
blockArg();
blockArg()
blockArg
()
State = 189;
State = 189
State
189
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}
_la==Assignment
_la
Assignment
{
				{
				State = 188;
				blockVariableInstatiation();
				}
			}
{
				State = 188;
				blockVariableInstatiation();
				}
State = 188;
State = 188
State
188
blockVariableInstatiation();
blockVariableInstatiation()
blockVariableInstatiation
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class FunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShortFunctionContext shortFunction() {
			return GetRuleContext<ShortFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LongFunctionContext longFunction() {
			return GetRuleContext<LongFunctionContext>(0);
		}
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ShortFunctionContext shortFunction() {
			return GetRuleContext<ShortFunctionContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ShortFunctionContext
()
{
			return GetRuleContext<ShortFunctionContext>(0);
		}
return GetRuleContext<ShortFunctionContext>(0);
GetRuleContext<ShortFunctionContext>(0)
GetRuleContext<ShortFunctionContext>
<ShortFunctionContext>
ShortFunctionContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public LongFunctionContext longFunction() {
			return GetRuleContext<LongFunctionContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
LongFunctionContext
()
{
			return GetRuleContext<LongFunctionContext>(0);
		}
return GetRuleContext<LongFunctionContext>(0);
GetRuleContext<LongFunctionContext>(0)
GetRuleContext<LongFunctionContext>
<LongFunctionContext>
LongFunctionContext
(0)
0
0
public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_function; } }
int
{ get { return RULE_function; } }
get { return RULE_function; }
{ return RULE_function; }
return RULE_function;
RULE_function
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterFunction(this);
typedListener != null
typedListener
null
typedListener.EnterFunction(this);
typedListener.EnterFunction(this)
typedListener.EnterFunction
typedListener
EnterFunction
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitFunction(this);
typedListener != null
typedListener
null
typedListener.ExitFunction(this);
typedListener.ExitFunction(this)
typedListener.ExitFunction
typedListener
ExitFunction
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitFunction(this);
typedVisitor.VisitFunction(this)
typedVisitor.VisitFunction
typedVisitor
VisitFunction
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 38, RULE_function);
		try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
FunctionContext
()
{
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 38, RULE_function);
		try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
FunctionContext _localctx = new FunctionContext(Context, State);
FunctionContext _localctx = new FunctionContext(Context, State)
FunctionContext
_localctx = new FunctionContext(Context, State)
= new FunctionContext(Context, State)
new FunctionContext(Context, State)
FunctionContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 38, RULE_function);
EnterRule(_localctx, 38, RULE_function)
EnterRule
(_localctx, 38, RULE_function)
_localctx
_localctx
38
38
RULE_function
RULE_function
try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
State = 193;
State = 193
State
193
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
case Identifier:
Identifier
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
				State = 191;
				shortFunction();
				}
State = 191;
State = 191
State
191
shortFunction();
shortFunction()
shortFunction
()
break;
case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
case Function:
Function
EnterOuterAlt(_localctx, 2);
EnterOuterAlt(_localctx, 2)
EnterOuterAlt
(_localctx, 2)
_localctx
_localctx
2
2
{
				State = 192;
				longFunction();
				}
State = 192;
State = 192
State
192
longFunction();
longFunction()
longFunction
()
break;
default:
				throw new NoViableAltException(this);
default:
throw new NoViableAltException(this);
new NoViableAltException(this)
NoViableAltException
(this)
this
this
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class FunctionHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NamedTupleContext namedTuple() {
			return GetRuleContext<NamedTupleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public NamedTupleContext namedTuple() {
			return GetRuleContext<NamedTupleContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
NamedTupleContext
()
{
			return GetRuleContext<NamedTupleContext>(0);
		}
return GetRuleContext<NamedTupleContext>(0);
GetRuleContext<NamedTupleContext>(0)
GetRuleContext<NamedTupleContext>
<NamedTupleContext>
NamedTupleContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ModuleRefContext
()
{
			return GetRuleContext<ModuleRefContext>(0);
		}
return GetRuleContext<ModuleRefContext>(0);
GetRuleContext<ModuleRefContext>(0)
GetRuleContext<ModuleRefContext>
<ModuleRefContext>
ModuleRefContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Identifier, 0); }
return GetToken(JuliaParser.Identifier, 0);
GetToken(JuliaParser.Identifier, 0)
GetToken
(JuliaParser.Identifier, 0)
JuliaParser.Identifier
JuliaParser.Identifier
JuliaParser
Identifier
0
0
public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_functionHeader; } }
int
{ get { return RULE_functionHeader; } }
get { return RULE_functionHeader; }
{ return RULE_functionHeader; }
return RULE_functionHeader;
RULE_functionHeader
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterFunctionHeader(this);
typedListener != null
typedListener
null
typedListener.EnterFunctionHeader(this);
typedListener.EnterFunctionHeader(this)
typedListener.EnterFunctionHeader
typedListener
EnterFunctionHeader
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitFunctionHeader(this);
typedListener != null
typedListener
null
typedListener.ExitFunctionHeader(this);
typedListener.ExitFunctionHeader(this)
typedListener.ExitFunctionHeader
typedListener
ExitFunctionHeader
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitFunctionHeader(this);
typedVisitor.VisitFunctionHeader(this)
typedVisitor.VisitFunctionHeader
typedVisitor
VisitFunctionHeader
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public FunctionHeaderContext functionHeader() {
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 40, RULE_functionHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
FunctionHeaderContext
()
{
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 40, RULE_functionHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State)
FunctionHeaderContext
_localctx = new FunctionHeaderContext(Context, State)
= new FunctionHeaderContext(Context, State)
new FunctionHeaderContext(Context, State)
FunctionHeaderContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 40, RULE_functionHeader);
EnterRule(_localctx, 40, RULE_functionHeader)
EnterRule
(_localctx, 40, RULE_functionHeader)
_localctx
_localctx
40
40
RULE_functionHeader
RULE_functionHeader
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
State = 197;
State = 197
State
197
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
Interpreter.AdaptivePredict(TokenStream,23,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,23,Context)
TokenStream
TokenStream
23
23
Context
Context
case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
case 1:
1
{
				State = 195;
				moduleRef();
				}
State = 195;
State = 195
State
195
moduleRef();
moduleRef()
moduleRef
()
break;
case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
case 2:
2
{
				State = 196;
				Match(Identifier);
				}
State = 196;
State = 196
State
196
Match(Identifier);
Match(Identifier)
Match
(Identifier)
Identifier
Identifier
break;
State = 199;
State = 199
State
199
namedTuple();
namedTuple()
namedTuple
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class FunctionItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprStatementContext blockExprStatement() {
			return GetRuleContext<BlockExprStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public FunctionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public BlockExprStatementContext blockExprStatement() {
			return GetRuleContext<BlockExprStatementContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockExprStatementContext
()
{
			return GetRuleContext<BlockExprStatementContext>(0);
		}
return GetRuleContext<BlockExprStatementContext>(0);
GetRuleContext<BlockExprStatementContext>(0)
GetRuleContext<BlockExprStatementContext>
<BlockExprStatementContext>
BlockExprStatementContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Termination, 0); }
return GetToken(JuliaParser.Termination, 0);
GetToken(JuliaParser.Termination, 0)
GetToken
(JuliaParser.Termination, 0)
JuliaParser.Termination
JuliaParser.Termination
JuliaParser
Termination
0
0
public FunctionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_functionItem; } }
int
{ get { return RULE_functionItem; } }
get { return RULE_functionItem; }
{ return RULE_functionItem; }
return RULE_functionItem;
RULE_functionItem
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterFunctionItem(this);
typedListener != null
typedListener
null
typedListener.EnterFunctionItem(this);
typedListener.EnterFunctionItem(this)
typedListener.EnterFunctionItem
typedListener
EnterFunctionItem
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitFunctionItem(this);
typedListener != null
typedListener
null
typedListener.ExitFunctionItem(this);
typedListener.ExitFunctionItem(this)
typedListener.ExitFunctionItem
typedListener
ExitFunctionItem
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitFunctionItem(this);
typedVisitor.VisitFunctionItem(this)
typedVisitor.VisitFunctionItem
typedVisitor
VisitFunctionItem
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public FunctionItemContext functionItem() {
		FunctionItemContext _localctx = new FunctionItemContext(Context, State);
		EnterRule(_localctx, 42, RULE_functionItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
FunctionItemContext
()
{
		FunctionItemContext _localctx = new FunctionItemContext(Context, State);
		EnterRule(_localctx, 42, RULE_functionItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
FunctionItemContext _localctx = new FunctionItemContext(Context, State);
FunctionItemContext _localctx = new FunctionItemContext(Context, State)
FunctionItemContext
_localctx = new FunctionItemContext(Context, State)
= new FunctionItemContext(Context, State)
new FunctionItemContext(Context, State)
FunctionItemContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 42, RULE_functionItem);
EnterRule(_localctx, 42, RULE_functionItem)
EnterRule
(_localctx, 42, RULE_functionItem)
_localctx
_localctx
42
42
RULE_functionItem
RULE_functionItem
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
State = 201;
State = 201
State
201
blockExprStatement();
blockExprStatement()
blockExprStatement
()
State = 202;
State = 202
State
202
Match(Termination);
Match(Termination)
Match
(Termination)
Termination
Termination
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolIdentifierContext symbolIdentifier() {
			return GetRuleContext<SymbolIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TupleContext tuple() {
			return GetRuleContext<TupleContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public SymbolIdentifierContext symbolIdentifier() {
			return GetRuleContext<SymbolIdentifierContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
SymbolIdentifierContext
()
{
			return GetRuleContext<SymbolIdentifierContext>(0);
		}
return GetRuleContext<SymbolIdentifierContext>(0);
GetRuleContext<SymbolIdentifierContext>(0)
GetRuleContext<SymbolIdentifierContext>
<SymbolIdentifierContext>
SymbolIdentifierContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public TupleContext tuple() {
			return GetRuleContext<TupleContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TupleContext
()
{
			return GetRuleContext<TupleContext>(0);
		}
return GetRuleContext<TupleContext>(0);
GetRuleContext<TupleContext>(0)
GetRuleContext<TupleContext>
<TupleContext>
TupleContext
(0)
0
0
public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_functionCall; } }
int
{ get { return RULE_functionCall; } }
get { return RULE_functionCall; }
{ return RULE_functionCall; }
return RULE_functionCall;
RULE_functionCall
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterFunctionCall(this);
typedListener != null
typedListener
null
typedListener.EnterFunctionCall(this);
typedListener.EnterFunctionCall(this)
typedListener.EnterFunctionCall
typedListener
EnterFunctionCall
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitFunctionCall(this);
typedListener != null
typedListener
null
typedListener.ExitFunctionCall(this);
typedListener.ExitFunctionCall(this)
typedListener.ExitFunctionCall
typedListener
ExitFunctionCall
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitFunctionCall(this);
typedVisitor.VisitFunctionCall(this)
typedVisitor.VisitFunctionCall
typedVisitor
VisitFunctionCall
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 44, RULE_functionCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
FunctionCallContext
()
{
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 44, RULE_functionCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
FunctionCallContext _localctx = new FunctionCallContext(Context, State);
FunctionCallContext _localctx = new FunctionCallContext(Context, State)
FunctionCallContext
_localctx = new FunctionCallContext(Context, State)
= new FunctionCallContext(Context, State)
new FunctionCallContext(Context, State)
FunctionCallContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 44, RULE_functionCall);
EnterRule(_localctx, 44, RULE_functionCall)
EnterRule
(_localctx, 44, RULE_functionCall)
_localctx
_localctx
44
44
RULE_functionCall
RULE_functionCall
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
State = 204;
State = 204
State
204
symbolIdentifier();
symbolIdentifier()
symbolIdentifier
()
State = 205;
State = 205
State
205
tuple();
tuple()
tuple
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class ShortFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(JuliaParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem() {
			return GetRuleContext<FunctionItemContext>(0);
		}
		public ShortFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shortFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
FunctionHeaderContext
()
{
			return GetRuleContext<FunctionHeaderContext>(0);
		}
return GetRuleContext<FunctionHeaderContext>(0);
GetRuleContext<FunctionHeaderContext>(0)
GetRuleContext<FunctionHeaderContext>
<FunctionHeaderContext>
FunctionHeaderContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(JuliaParser.Assign, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Assign, 0); }
return GetToken(JuliaParser.Assign, 0);
GetToken(JuliaParser.Assign, 0)
GetToken
(JuliaParser.Assign, 0)
JuliaParser.Assign
JuliaParser.Assign
JuliaParser
Assign
0
0
[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem() {
			return GetRuleContext<FunctionItemContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
FunctionItemContext
()
{
			return GetRuleContext<FunctionItemContext>(0);
		}
return GetRuleContext<FunctionItemContext>(0);
GetRuleContext<FunctionItemContext>(0)
GetRuleContext<FunctionItemContext>
<FunctionItemContext>
FunctionItemContext
(0)
0
0
public ShortFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_shortFunction; } }
int
{ get { return RULE_shortFunction; } }
get { return RULE_shortFunction; }
{ return RULE_shortFunction; }
return RULE_shortFunction;
RULE_shortFunction
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterShortFunction(this);
typedListener != null
typedListener
null
typedListener.EnterShortFunction(this);
typedListener.EnterShortFunction(this)
typedListener.EnterShortFunction
typedListener
EnterShortFunction
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitShortFunction(this);
typedListener != null
typedListener
null
typedListener.ExitShortFunction(this);
typedListener.ExitShortFunction(this)
typedListener.ExitShortFunction
typedListener
ExitShortFunction
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitShortFunction(this);
typedVisitor.VisitShortFunction(this)
typedVisitor.VisitShortFunction
typedVisitor
VisitShortFunction
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public ShortFunctionContext shortFunction() {
		ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);
		EnterRule(_localctx, 46, RULE_shortFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
ShortFunctionContext
()
{
		ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);
		EnterRule(_localctx, 46, RULE_shortFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);
ShortFunctionContext _localctx = new ShortFunctionContext(Context, State)
ShortFunctionContext
_localctx = new ShortFunctionContext(Context, State)
= new ShortFunctionContext(Context, State)
new ShortFunctionContext(Context, State)
ShortFunctionContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 46, RULE_shortFunction);
EnterRule(_localctx, 46, RULE_shortFunction)
EnterRule
(_localctx, 46, RULE_shortFunction)
_localctx
_localctx
46
46
RULE_shortFunction
RULE_shortFunction
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
State = 207;
State = 207
State
207
functionHeader();
functionHeader()
functionHeader
()
State = 208;
State = 208
State
208
Match(Assign);
Match(Assign)
Match
(Assign)
Assign
Assign
State = 209;
State = 209
State
209
functionItem();
functionItem()
functionItem
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class LongFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(JuliaParser.Function, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext[] functionItem() {
			return GetRuleContexts<FunctionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem(int i) {
			return GetRuleContext<FunctionItemContext>(i);
		}
		public LongFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_longFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(JuliaParser.Function, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Function, 0); }
return GetToken(JuliaParser.Function, 0);
GetToken(JuliaParser.Function, 0)
GetToken
(JuliaParser.Function, 0)
JuliaParser.Function
JuliaParser.Function
JuliaParser
Function
0
0
[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
FunctionHeaderContext
()
{
			return GetRuleContext<FunctionHeaderContext>(0);
		}
return GetRuleContext<FunctionHeaderContext>(0);
GetRuleContext<FunctionHeaderContext>(0)
GetRuleContext<FunctionHeaderContext>
<FunctionHeaderContext>
FunctionHeaderContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Termination, 0); }
return GetToken(JuliaParser.Termination, 0);
GetToken(JuliaParser.Termination, 0)
GetToken
(JuliaParser.Termination, 0)
JuliaParser.Termination
JuliaParser.Termination
JuliaParser
Termination
0
0
[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
EndExprContext
()
{
			return GetRuleContext<EndExprContext>(0);
		}
return GetRuleContext<EndExprContext>(0);
GetRuleContext<EndExprContext>(0)
GetRuleContext<EndExprContext>
<EndExprContext>
EndExprContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext[] functionItem() {
			return GetRuleContexts<FunctionItemContext>();
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
FunctionItemContext[]
FunctionItemContext
[]

()
{
			return GetRuleContexts<FunctionItemContext>();
		}
return GetRuleContexts<FunctionItemContext>();
GetRuleContexts<FunctionItemContext>()
GetRuleContexts<FunctionItemContext>
<FunctionItemContext>
FunctionItemContext
()
[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem(int i) {
			return GetRuleContext<FunctionItemContext>(i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
FunctionItemContext
(int i)
int i
int
{
			return GetRuleContext<FunctionItemContext>(i);
		}
return GetRuleContext<FunctionItemContext>(i);
GetRuleContext<FunctionItemContext>(i)
GetRuleContext<FunctionItemContext>
<FunctionItemContext>
FunctionItemContext
(i)
i
i
public LongFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_longFunction; } }
int
{ get { return RULE_longFunction; } }
get { return RULE_longFunction; }
{ return RULE_longFunction; }
return RULE_longFunction;
RULE_longFunction
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterLongFunction(this);
typedListener != null
typedListener
null
typedListener.EnterLongFunction(this);
typedListener.EnterLongFunction(this)
typedListener.EnterLongFunction
typedListener
EnterLongFunction
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitLongFunction(this);
typedListener != null
typedListener
null
typedListener.ExitLongFunction(this);
typedListener.ExitLongFunction(this)
typedListener.ExitLongFunction
typedListener
ExitLongFunction
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitLongFunction(this);
typedVisitor.VisitLongFunction(this)
typedVisitor.VisitLongFunction
typedVisitor
VisitLongFunction
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public LongFunctionContext longFunction() {
		LongFunctionContext _localctx = new LongFunctionContext(Context, State);
		EnterRule(_localctx, 48, RULE_longFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
LongFunctionContext
()
{
		LongFunctionContext _localctx = new LongFunctionContext(Context, State);
		EnterRule(_localctx, 48, RULE_longFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
LongFunctionContext _localctx = new LongFunctionContext(Context, State);
LongFunctionContext _localctx = new LongFunctionContext(Context, State)
LongFunctionContext
_localctx = new LongFunctionContext(Context, State)
= new LongFunctionContext(Context, State)
new LongFunctionContext(Context, State)
LongFunctionContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 48, RULE_longFunction);
EnterRule(_localctx, 48, RULE_longFunction)
EnterRule
(_localctx, 48, RULE_longFunction)
_localctx
_localctx
48
48
RULE_longFunction
RULE_longFunction
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
State = 211;
State = 211
State
211
Match(Function);
Match(Function)
Match
(Function)
Function
Function
State = 212;
State = 212
State
212
functionHeader();
functionHeader()
functionHeader
()
State = 213;
State = 213
State
213
Match(Termination);
Match(Termination)
Match
(Termination)
Termination
Termination
State = 217;
State = 217
State
217
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
(((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)
((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0
((_la) & ~0x3f) == 0
((_la) & ~0x3f)
(_la) & ~0x3f
(_la)
_la
~0x3f
0x3f
0
((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0
((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier)))
(1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))
(1L << _la)
1L << _la
1L
_la
((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))
(1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier)
(1L << Global) | (1L << Const) | (1L << Local)
(1L << Global) | (1L << Const)
(1L << Global)
1L << Global
1L
Global
(1L << Const)
1L << Const
1L
Const
(1L << Local)
1L << Local
1L
Local
(1L << Identifier)
1L << Identifier
1L
Identifier
0
{
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
{
				{
				State = 214;
				functionItem();
				}
				}
{
				State = 214;
				functionItem();
				}
State = 214;
State = 214
State
214
functionItem();
functionItem()
functionItem
()
State = 219;
State = 219
State
219
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
State = 220;
State = 220
State
220
endExpr();
endExpr()
endExpr
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class TupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.RightParen, 0); }
return GetToken(JuliaParser.RightParen, 0);
GetToken(JuliaParser.RightParen, 0)
GetToken
(JuliaParser.RightParen, 0)
JuliaParser.RightParen
JuliaParser.RightParen
JuliaParser
RightParen
0
0
[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TupleListContext
()
{
			return GetRuleContext<TupleListContext>(0);
		}
return GetRuleContext<TupleListContext>(0);
GetRuleContext<TupleListContext>(0)
GetRuleContext<TupleListContext>
<TupleListContext>
TupleListContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.LeftParen, 0); }
return GetToken(JuliaParser.LeftParen, 0);
GetToken(JuliaParser.LeftParen, 0)
GetToken
(JuliaParser.LeftParen, 0)
JuliaParser.LeftParen
JuliaParser.LeftParen
JuliaParser
LeftParen
0
0
public TupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_tuple; } }
int
{ get { return RULE_tuple; } }
get { return RULE_tuple; }
{ return RULE_tuple; }
return RULE_tuple;
RULE_tuple
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterTuple(this);
typedListener != null
typedListener
null
typedListener.EnterTuple(this);
typedListener.EnterTuple(this)
typedListener.EnterTuple
typedListener
EnterTuple
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitTuple(this);
typedListener != null
typedListener
null
typedListener.ExitTuple(this);
typedListener.ExitTuple(this)
typedListener.ExitTuple
typedListener
ExitTuple
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitTuple(this);
typedVisitor.VisitTuple(this)
typedVisitor.VisitTuple
typedVisitor
VisitTuple
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public TupleContext tuple() {
		TupleContext _localctx = new TupleContext(Context, State);
		EnterRule(_localctx, 50, RULE_tuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
TupleContext
()
{
		TupleContext _localctx = new TupleContext(Context, State);
		EnterRule(_localctx, 50, RULE_tuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
TupleContext _localctx = new TupleContext(Context, State);
TupleContext _localctx = new TupleContext(Context, State)
TupleContext
_localctx = new TupleContext(Context, State)
= new TupleContext(Context, State)
new TupleContext(Context, State)
TupleContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 50, RULE_tuple);
EnterRule(_localctx, 50, RULE_tuple)
EnterRule
(_localctx, 50, RULE_tuple)
_localctx
_localctx
50
50
RULE_tuple
RULE_tuple
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
State = 222;
State = 222
State
222
Match(RightParen);
Match(RightParen)
Match
(RightParen)
RightParen
RightParen
State = 223;
State = 223
State
223
tupleList();
tupleList()
tupleList
()
State = 224;
State = 224
State
224
Match(LeftParen);
Match(LeftParen)
Match
(LeftParen)
LeftParen
LeftParen
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class NamedTupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext[] blockArg() {
			return GetRuleContexts<BlockArgContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg(int i) {
			return GetRuleContext<BlockArgContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		public NamedTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedTuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.RightParen, 0); }
return GetToken(JuliaParser.RightParen, 0);
GetToken(JuliaParser.RightParen, 0)
GetToken
(JuliaParser.RightParen, 0)
JuliaParser.RightParen
JuliaParser.RightParen
JuliaParser
RightParen
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.LeftParen, 0); }
return GetToken(JuliaParser.LeftParen, 0);
GetToken(JuliaParser.LeftParen, 0)
GetToken
(JuliaParser.LeftParen, 0)
JuliaParser.LeftParen
JuliaParser.LeftParen
JuliaParser
LeftParen
0
0
[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext[] blockArg() {
			return GetRuleContexts<BlockArgContext>();
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockArgContext[]
BlockArgContext
[]

()
{
			return GetRuleContexts<BlockArgContext>();
		}
return GetRuleContexts<BlockArgContext>();
GetRuleContexts<BlockArgContext>()
GetRuleContexts<BlockArgContext>
<BlockArgContext>
BlockArgContext
()
[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg(int i) {
			return GetRuleContext<BlockArgContext>(i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockArgContext
(int i)
int i
int
{
			return GetRuleContext<BlockArgContext>(i);
		}
return GetRuleContext<BlockArgContext>(i);
GetRuleContext<BlockArgContext>(i)
GetRuleContext<BlockArgContext>
<BlockArgContext>
BlockArgContext
(i)
i
i
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode[]
ITerminalNode
[]

()
{ return GetTokens(JuliaParser.Comma); }
return GetTokens(JuliaParser.Comma);
GetTokens(JuliaParser.Comma)
GetTokens
(JuliaParser.Comma)
JuliaParser.Comma
JuliaParser.Comma
JuliaParser
Comma
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
(int i)
int i
int
{
			return GetToken(JuliaParser.Comma, i);
		}
return GetToken(JuliaParser.Comma, i);
GetToken(JuliaParser.Comma, i)
GetToken
(JuliaParser.Comma, i)
JuliaParser.Comma
JuliaParser.Comma
JuliaParser
Comma
i
i
public NamedTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_namedTuple; } }
int
{ get { return RULE_namedTuple; } }
get { return RULE_namedTuple; }
{ return RULE_namedTuple; }
return RULE_namedTuple;
RULE_namedTuple
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterNamedTuple(this);
typedListener != null
typedListener
null
typedListener.EnterNamedTuple(this);
typedListener.EnterNamedTuple(this)
typedListener.EnterNamedTuple
typedListener
EnterNamedTuple
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitNamedTuple(this);
typedListener != null
typedListener
null
typedListener.ExitNamedTuple(this);
typedListener.ExitNamedTuple(this)
typedListener.ExitNamedTuple
typedListener
ExitNamedTuple
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitNamedTuple(this);
typedVisitor.VisitNamedTuple(this)
typedVisitor.VisitNamedTuple
typedVisitor
VisitNamedTuple
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public NamedTupleContext namedTuple() {
		NamedTupleContext _localctx = new NamedTupleContext(Context, State);
		EnterRule(_localctx, 52, RULE_namedTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
NamedTupleContext
()
{
		NamedTupleContext _localctx = new NamedTupleContext(Context, State);
		EnterRule(_localctx, 52, RULE_namedTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
NamedTupleContext _localctx = new NamedTupleContext(Context, State);
NamedTupleContext _localctx = new NamedTupleContext(Context, State)
NamedTupleContext
_localctx = new NamedTupleContext(Context, State)
= new NamedTupleContext(Context, State)
new NamedTupleContext(Context, State)
NamedTupleContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 52, RULE_namedTuple);
EnterRule(_localctx, 52, RULE_namedTuple)
EnterRule
(_localctx, 52, RULE_namedTuple)
_localctx
_localctx
52
52
RULE_namedTuple
RULE_namedTuple
int _la;
int _la
int
_la
try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
int _alt;
int _alt
int
_alt
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
State = 226;
State = 226
State
226
Match(RightParen);
Match(RightParen)
Match
(RightParen)
RightParen
RightParen
State = 236;
State = 236
State
236
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}
_la==Identifier
_la
Identifier
{
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}
{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
State = 232;
State = 232
State
232
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
_alt = Interpreter.AdaptivePredict(TokenStream,25,Context)
_alt
Interpreter.AdaptivePredict(TokenStream,25,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,25,Context)
TokenStream
TokenStream
25
25
Context
Context
while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
_alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
_alt!=2
_alt
2
_alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
_alt
global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER
global::Antlr4.Runtime.Atn.ATN
global::Antlr4.Runtime.Atn
global::Antlr4.Runtime
global::Antlr4
global
Antlr4
Runtime
Atn
ATN
INVALID_ALT_NUMBER
{
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
_alt==1
_alt
1
{
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						}
{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
State = 227;
State = 227
State
227
blockArg();
blockArg()
blockArg
()
State = 228;
State = 228
State
228
Match(Comma);
Match(Comma)
Match
(Comma)
Comma
Comma
State = 234;
State = 234
State
234
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
_alt = Interpreter.AdaptivePredict(TokenStream,25,Context)
_alt
Interpreter.AdaptivePredict(TokenStream,25,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,25,Context)
TokenStream
TokenStream
25
25
Context
Context
State = 235;
State = 235
State
235
blockArg();
blockArg()
blockArg
()
State = 238;
State = 238
State
238
Match(LeftParen);
Match(LeftParen)
Match
(LeftParen)
LeftParen
LeftParen
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class TypetupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(JuliaParser.Comma, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TypetupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typetuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.RightParen, 0); }
return GetToken(JuliaParser.RightParen, 0);
GetToken(JuliaParser.RightParen, 0)
GetToken
(JuliaParser.RightParen, 0)
JuliaParser.RightParen
JuliaParser.RightParen
JuliaParser
RightParen
0
0
[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TupleListContext
()
{
			return GetRuleContext<TupleListContext>(0);
		}
return GetRuleContext<TupleListContext>(0);
GetRuleContext<TupleListContext>(0)
GetRuleContext<TupleListContext>
<TupleListContext>
TupleListContext
(0)
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(JuliaParser.Comma, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Comma, 0); }
return GetToken(JuliaParser.Comma, 0);
GetToken(JuliaParser.Comma, 0)
GetToken
(JuliaParser.Comma, 0)
JuliaParser.Comma
JuliaParser.Comma
JuliaParser
Comma
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.LeftParen, 0); }
return GetToken(JuliaParser.LeftParen, 0);
GetToken(JuliaParser.LeftParen, 0)
GetToken
(JuliaParser.LeftParen, 0)
JuliaParser.LeftParen
JuliaParser.LeftParen
JuliaParser
LeftParen
0
0
public TypetupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_typetuple; } }
int
{ get { return RULE_typetuple; } }
get { return RULE_typetuple; }
{ return RULE_typetuple; }
return RULE_typetuple;
RULE_typetuple
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterTypetuple(this);
typedListener != null
typedListener
null
typedListener.EnterTypetuple(this);
typedListener.EnterTypetuple(this)
typedListener.EnterTypetuple
typedListener
EnterTypetuple
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitTypetuple(this);
typedListener != null
typedListener
null
typedListener.ExitTypetuple(this);
typedListener.ExitTypetuple(this)
typedListener.ExitTypetuple
typedListener
ExitTypetuple
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitTypetuple(this);
typedVisitor.VisitTypetuple(this)
typedVisitor.VisitTypetuple
typedVisitor
VisitTypetuple
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public TypetupleContext typetuple() {
		TypetupleContext _localctx = new TypetupleContext(Context, State);
		EnterRule(_localctx, 54, RULE_typetuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
TypetupleContext
()
{
		TypetupleContext _localctx = new TypetupleContext(Context, State);
		EnterRule(_localctx, 54, RULE_typetuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
TypetupleContext _localctx = new TypetupleContext(Context, State);
TypetupleContext _localctx = new TypetupleContext(Context, State)
TypetupleContext
_localctx = new TypetupleContext(Context, State)
= new TypetupleContext(Context, State)
new TypetupleContext(Context, State)
TypetupleContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 54, RULE_typetuple);
EnterRule(_localctx, 54, RULE_typetuple)
EnterRule
(_localctx, 54, RULE_typetuple)
_localctx
_localctx
54
54
RULE_typetuple
RULE_typetuple
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
State = 240;
State = 240
State
240
Match(RightParen);
Match(RightParen)
Match
(RightParen)
RightParen
RightParen
State = 241;
State = 241
State
241
tupleList();
tupleList()
tupleList
()
State = 242;
State = 242
State
242
Match(Comma);
Match(Comma)
Match
(Comma)
Comma
Comma
State = 243;
State = 243
State
243
Match(LeftParen);
Match(LeftParen)
Match
(LeftParen)
LeftParen
LeftParen
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class TupleListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext[] blockExpr() {
			return GetRuleContexts<BlockExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr(int i) {
			return GetRuleContext<BlockExprContext>(i);
		}
		public TupleListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode[]
ITerminalNode
[]

()
{ return GetTokens(JuliaParser.Comma); }
return GetTokens(JuliaParser.Comma);
GetTokens(JuliaParser.Comma)
GetTokens
(JuliaParser.Comma)
JuliaParser.Comma
JuliaParser.Comma
JuliaParser
Comma
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
(int i)
int i
int
{
			return GetToken(JuliaParser.Comma, i);
		}
return GetToken(JuliaParser.Comma, i);
GetToken(JuliaParser.Comma, i)
GetToken
(JuliaParser.Comma, i)
JuliaParser.Comma
JuliaParser.Comma
JuliaParser
Comma
i
i
[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext[] blockExpr() {
			return GetRuleContexts<BlockExprContext>();
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockExprContext[]
BlockExprContext
[]

()
{
			return GetRuleContexts<BlockExprContext>();
		}
return GetRuleContexts<BlockExprContext>();
GetRuleContexts<BlockExprContext>()
GetRuleContexts<BlockExprContext>
<BlockExprContext>
BlockExprContext
()
[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr(int i) {
			return GetRuleContext<BlockExprContext>(i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
BlockExprContext
(int i)
int i
int
{
			return GetRuleContext<BlockExprContext>(i);
		}
return GetRuleContext<BlockExprContext>(i);
GetRuleContext<BlockExprContext>(i)
GetRuleContext<BlockExprContext>
<BlockExprContext>
BlockExprContext
(i)
i
i
public TupleListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_tupleList; } }
int
{ get { return RULE_tupleList; } }
get { return RULE_tupleList; }
{ return RULE_tupleList; }
return RULE_tupleList;
RULE_tupleList
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterTupleList(this);
typedListener != null
typedListener
null
typedListener.EnterTupleList(this);
typedListener.EnterTupleList(this)
typedListener.EnterTupleList
typedListener
EnterTupleList
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitTupleList(this);
typedListener != null
typedListener
null
typedListener.ExitTupleList(this);
typedListener.ExitTupleList(this)
typedListener.ExitTupleList
typedListener
ExitTupleList
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitTupleList(this);
typedVisitor.VisitTupleList(this)
typedVisitor.VisitTupleList
typedVisitor
VisitTupleList
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public TupleListContext tupleList() {
		TupleListContext _localctx = new TupleListContext(Context, State);
		EnterRule(_localctx, 56, RULE_tupleList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
TupleListContext
()
{
		TupleListContext _localctx = new TupleListContext(Context, State);
		EnterRule(_localctx, 56, RULE_tupleList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
TupleListContext _localctx = new TupleListContext(Context, State);
TupleListContext _localctx = new TupleListContext(Context, State)
TupleListContext
_localctx = new TupleListContext(Context, State)
= new TupleListContext(Context, State)
new TupleListContext(Context, State)
TupleListContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 56, RULE_tupleList);
EnterRule(_localctx, 56, RULE_tupleList)
EnterRule
(_localctx, 56, RULE_tupleList)
_localctx
_localctx
56
56
RULE_tupleList
RULE_tupleList
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
State = 250;
State = 250
State
250
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
(((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)
((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0
((_la) & ~0x3f) == 0
((_la) & ~0x3f)
(_la) & ~0x3f
(_la)
_la
~0x3f
0x3f
0
((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0
((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier)))
(1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))
(1L << _la)
1L << _la
1L
_la
((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))
(1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier)
(1L << Global) | (1L << Const) | (1L << Local)
(1L << Global) | (1L << Const)
(1L << Global)
1L << Global
1L
Global
(1L << Const)
1L << Const
1L
Const
(1L << Local)
1L << Local
1L
Local
(1L << Identifier)
1L << Identifier
1L
Identifier
0
{
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
State = 245;
State = 245
State
245
blockExpr();
blockExpr()
blockExpr
()
State = 246;
State = 246
State
246
Match(Comma);
Match(Comma)
Match
(Comma)
Comma
Comma
State = 252;
State = 252
State
252
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
State = 253;
State = 253
State
253
Match(Comma);
Match(Comma)
Match
(Comma)
Comma
Comma
State = 254;
State = 254
State
254
blockExpr();
blockExpr()
blockExpr
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extend() { return GetToken(JuliaParser.Extend, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Identifier, 0); }
return GetToken(JuliaParser.Identifier, 0);
GetToken(JuliaParser.Identifier, 0)
GetToken
(JuliaParser.Identifier, 0)
JuliaParser.Identifier
JuliaParser.Identifier
JuliaParser
Identifier
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extend() { return GetToken(JuliaParser.Extend, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Extend, 0); }
return GetToken(JuliaParser.Extend, 0);
GetToken(JuliaParser.Extend, 0)
GetToken
(JuliaParser.Extend, 0)
JuliaParser.Extend
JuliaParser.Extend
JuliaParser
Extend
0
0
[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TypeContext
()
{
			return GetRuleContext<TypeContext>(0);
		}
return GetRuleContext<TypeContext>(0);
GetRuleContext<TypeContext>(0)
GetRuleContext<TypeContext>
<TypeContext>
TypeContext
(0)
0
0
public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_typeName; } }
int
{ get { return RULE_typeName; } }
get { return RULE_typeName; }
{ return RULE_typeName; }
return RULE_typeName;
RULE_typeName
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterTypeName(this);
typedListener != null
typedListener
null
typedListener.EnterTypeName(this);
typedListener.EnterTypeName(this)
typedListener.EnterTypeName
typedListener
EnterTypeName
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitTypeName(this);
typedListener != null
typedListener
null
typedListener.ExitTypeName(this);
typedListener.ExitTypeName(this)
typedListener.ExitTypeName
typedListener
ExitTypeName
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitTypeName(this);
typedVisitor.VisitTypeName(this)
typedVisitor.VisitTypeName
typedVisitor
VisitTypeName
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 58, RULE_typeName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
TypeNameContext
()
{
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 58, RULE_typeName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
TypeNameContext _localctx = new TypeNameContext(Context, State);
TypeNameContext _localctx = new TypeNameContext(Context, State)
TypeNameContext
_localctx = new TypeNameContext(Context, State)
= new TypeNameContext(Context, State)
new TypeNameContext(Context, State)
TypeNameContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 58, RULE_typeName);
EnterRule(_localctx, 58, RULE_typeName)
EnterRule
(_localctx, 58, RULE_typeName)
_localctx
_localctx
58
58
RULE_typeName
RULE_typeName
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
State = 256;
State = 256
State
256
Match(Identifier);
Match(Identifier)
Match
(Identifier)
Identifier
Identifier
State = 259;
State = 259
State
259
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}
_la==Extend
_la
Extend
{
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}
{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
State = 257;
State = 257
State
257
Match(Extend);
Match(Extend)
Match
(Extend)
Extend
Extend
State = 258;
State = 258
State
258
type();
type()
type
()
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class ParameterizedTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RightBrace() { return GetTokens(JuliaParser.RightBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace(int i) {
			return GetToken(JuliaParser.RightBrace, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LeftBrace() { return GetTokens(JuliaParser.LeftBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace(int i) {
			return GetToken(JuliaParser.LeftBrace, i);
		}
		public ParameterizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterizedType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Identifier, 0); }
return GetToken(JuliaParser.Identifier, 0);
GetToken(JuliaParser.Identifier, 0)
GetToken
(JuliaParser.Identifier, 0)
JuliaParser.Identifier
JuliaParser.Identifier
JuliaParser
Identifier
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RightBrace() { return GetTokens(JuliaParser.RightBrace); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode[]
ITerminalNode
[]

()
{ return GetTokens(JuliaParser.RightBrace); }
return GetTokens(JuliaParser.RightBrace);
GetTokens(JuliaParser.RightBrace)
GetTokens
(JuliaParser.RightBrace)
JuliaParser.RightBrace
JuliaParser.RightBrace
JuliaParser
RightBrace
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace(int i) {
			return GetToken(JuliaParser.RightBrace, i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
(int i)
int i
int
{
			return GetToken(JuliaParser.RightBrace, i);
		}
return GetToken(JuliaParser.RightBrace, i);
GetToken(JuliaParser.RightBrace, i)
GetToken
(JuliaParser.RightBrace, i)
JuliaParser.RightBrace
JuliaParser.RightBrace
JuliaParser
RightBrace
i
i
[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TypeContext[]
TypeContext
[]

()
{
			return GetRuleContexts<TypeContext>();
		}
return GetRuleContexts<TypeContext>();
GetRuleContexts<TypeContext>()
GetRuleContexts<TypeContext>
<TypeContext>
TypeContext
()
[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TypeContext
(int i)
int i
int
{
			return GetRuleContext<TypeContext>(i);
		}
return GetRuleContext<TypeContext>(i);
GetRuleContext<TypeContext>(i)
GetRuleContext<TypeContext>
<TypeContext>
TypeContext
(i)
i
i
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LeftBrace() { return GetTokens(JuliaParser.LeftBrace); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode[]
ITerminalNode
[]

()
{ return GetTokens(JuliaParser.LeftBrace); }
return GetTokens(JuliaParser.LeftBrace);
GetTokens(JuliaParser.LeftBrace)
GetTokens
(JuliaParser.LeftBrace)
JuliaParser.LeftBrace
JuliaParser.LeftBrace
JuliaParser
LeftBrace
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace(int i) {
			return GetToken(JuliaParser.LeftBrace, i);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
(int i)
int i
int
{
			return GetToken(JuliaParser.LeftBrace, i);
		}
return GetToken(JuliaParser.LeftBrace, i);
GetToken(JuliaParser.LeftBrace, i)
GetToken
(JuliaParser.LeftBrace, i)
JuliaParser.LeftBrace
JuliaParser.LeftBrace
JuliaParser
LeftBrace
i
i
public ParameterizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_parameterizedType; } }
int
{ get { return RULE_parameterizedType; } }
get { return RULE_parameterizedType; }
{ return RULE_parameterizedType; }
return RULE_parameterizedType;
RULE_parameterizedType
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterParameterizedType(this);
typedListener != null
typedListener
null
typedListener.EnterParameterizedType(this);
typedListener.EnterParameterizedType(this)
typedListener.EnterParameterizedType
typedListener
EnterParameterizedType
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitParameterizedType(this);
typedListener != null
typedListener
null
typedListener.ExitParameterizedType(this);
typedListener.ExitParameterizedType(this)
typedListener.ExitParameterizedType
typedListener
ExitParameterizedType
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitParameterizedType(this);
typedVisitor.VisitParameterizedType(this)
typedVisitor.VisitParameterizedType
typedVisitor
VisitParameterizedType
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public ParameterizedTypeContext parameterizedType() {
		ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_parameterizedType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
ParameterizedTypeContext
()
{
		ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_parameterizedType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State)
ParameterizedTypeContext
_localctx = new ParameterizedTypeContext(Context, State)
= new ParameterizedTypeContext(Context, State)
new ParameterizedTypeContext(Context, State)
ParameterizedTypeContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 60, RULE_parameterizedType);
EnterRule(_localctx, 60, RULE_parameterizedType)
EnterRule
(_localctx, 60, RULE_parameterizedType)
_localctx
_localctx
60
60
RULE_parameterizedType
RULE_parameterizedType
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
State = 261;
State = 261
State
261
Match(Identifier);
Match(Identifier)
Match
(Identifier)
Identifier
Identifier
State = 266;
State = 266
State
266
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
{
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
State = 262;
State = 262
State
262
Match(RightBrace);
Match(RightBrace)
Match
(RightBrace)
RightBrace
RightBrace
State = 263;
State = 263
State
263
type();
type()
type
()
State = 264;
State = 264
State
264
Match(LeftBrace);
Match(LeftBrace)
Match
(LeftBrace)
LeftBrace
LeftBrace
State = 268;
State = 268
State
268
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
_la==RightBrace
_la
RightBrace
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterizedTypeContext parameterizedType() {
			return GetRuleContext<ParameterizedTypeContext>(0);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Identifier, 0); }
return GetToken(JuliaParser.Identifier, 0);
GetToken(JuliaParser.Identifier, 0)
GetToken
(JuliaParser.Identifier, 0)
JuliaParser.Identifier
JuliaParser.Identifier
JuliaParser
Identifier
0
0
[System.Diagnostics.DebuggerNonUserCode] public ParameterizedTypeContext parameterizedType() {
			return GetRuleContext<ParameterizedTypeContext>(0);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ParameterizedTypeContext
()
{
			return GetRuleContext<ParameterizedTypeContext>(0);
		}
return GetRuleContext<ParameterizedTypeContext>(0);
GetRuleContext<ParameterizedTypeContext>(0)
GetRuleContext<ParameterizedTypeContext>
<ParameterizedTypeContext>
ParameterizedTypeContext
(0)
0
0
public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_type; } }
int
{ get { return RULE_type; } }
get { return RULE_type; }
{ return RULE_type; }
return RULE_type;
RULE_type
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterType(this);
typedListener != null
typedListener
null
typedListener.EnterType(this);
typedListener.EnterType(this)
typedListener.EnterType
typedListener
EnterType
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitType(this);
typedListener != null
typedListener
null
typedListener.ExitType(this);
typedListener.ExitType(this)
typedListener.ExitType
typedListener
ExitType
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitType(this);
typedVisitor.VisitType(this)
typedVisitor.VisitType
typedVisitor
VisitType
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_type);
		try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
TypeContext
()
{
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_type);
		try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
TypeContext _localctx = new TypeContext(Context, State);
TypeContext _localctx = new TypeContext(Context, State)
TypeContext
_localctx = new TypeContext(Context, State)
= new TypeContext(Context, State)
new TypeContext(Context, State)
TypeContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 62, RULE_type);
EnterRule(_localctx, 62, RULE_type)
EnterRule
(_localctx, 62, RULE_type)
_localctx
_localctx
62
62
RULE_type
RULE_type
try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
State = 272;
State = 272
State
272
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
Interpreter.AdaptivePredict(TokenStream,30,Context)
Interpreter.AdaptivePredict
Interpreter
AdaptivePredict
(TokenStream,30,Context)
TokenStream
TokenStream
30
30
Context
Context
case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
case 1:
1
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
				State = 270;
				Match(Identifier);
				}
State = 270;
State = 270
State
270
Match(Identifier);
Match(Identifier)
Match
(Identifier)
Identifier
Identifier
break;
case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
case 2:
2
EnterOuterAlt(_localctx, 2);
EnterOuterAlt(_localctx, 2)
EnterOuterAlt
(_localctx, 2)
_localctx
_localctx
2
2
{
				State = 271;
				parameterizedType();
				}
State = 271;
State = 271
State
271
parameterizedType();
parameterizedType()
parameterizedType
()
break;
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
public partial class EndExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(JuliaParser.End, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public EndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
: ParserRuleContext
ParserRuleContext
ParserRuleContext
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(JuliaParser.End, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.End, 0); }
return GetToken(JuliaParser.End, 0);
GetToken(JuliaParser.End, 0)
GetToken
(JuliaParser.End, 0)
JuliaParser.End
JuliaParser.End
JuliaParser
End
0
0
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
ITerminalNode
()
{ return GetToken(JuliaParser.Termination, 0); }
return GetToken(JuliaParser.Termination, 0);
GetToken(JuliaParser.Termination, 0)
GetToken
(JuliaParser.Termination, 0)
JuliaParser.Termination
JuliaParser.Termination
JuliaParser
Termination
0
0
public EndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
(ParserRuleContext parent, int invokingState)
ParserRuleContext parent
ParserRuleContext
int invokingState
int
: base(parent, invokingState)
(parent, invokingState)
parent
parent
invokingState
invokingState
{
		}
public override int RuleIndex { get { return RULE_endExpr; } }
int
{ get { return RULE_endExpr; } }
get { return RULE_endExpr; }
{ return RULE_endExpr; }
return RULE_endExpr;
RULE_endExpr
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.EnterEndExpr(this);
typedListener != null
typedListener
null
typedListener.EnterEndExpr(this);
typedListener.EnterEndExpr(this)
typedListener.EnterEndExpr
typedListener
EnterEndExpr
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
void
(IParseTreeListener listener)
IParseTreeListener listener
IParseTreeListener
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}
IJuliaListener typedListener = listener as IJuliaListener;
IJuliaListener typedListener = listener as IJuliaListener
IJuliaListener
typedListener = listener as IJuliaListener
= listener as IJuliaListener
listener as IJuliaListener
listener
IJuliaListener
if (typedListener != null) typedListener.ExitEndExpr(this);
typedListener != null
typedListener
null
typedListener.ExitEndExpr(this);
typedListener.ExitEndExpr(this)
typedListener.ExitEndExpr
typedListener
ExitEndExpr
(this)
this
this
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}
[System.Diagnostics.DebuggerNonUserCode]
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics.DebuggerNonUserCode
System.Diagnostics
System
Diagnostics
DebuggerNonUserCode
TResult
<TResult>
TResult
(IParseTreeVisitor<TResult> visitor)
IParseTreeVisitor<TResult> visitor
IParseTreeVisitor<TResult>
<TResult>
TResult
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>
IJuliaVisitor<TResult>
<TResult>
TResult
typedVisitor = visitor as IJuliaVisitor<TResult>
= visitor as IJuliaVisitor<TResult>
visitor as IJuliaVisitor<TResult>
visitor
IJuliaVisitor<TResult>
<TResult>
TResult
if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
typedVisitor != null
typedVisitor
null
return typedVisitor.VisitEndExpr(this);
typedVisitor.VisitEndExpr(this)
typedVisitor.VisitEndExpr
typedVisitor
VisitEndExpr
(this)
this
this
else return visitor.VisitChildren(this);
return visitor.VisitChildren(this);
visitor.VisitChildren(this)
visitor.VisitChildren
visitor
VisitChildren
(this)
this
this
[RuleVersion(0)]
	public EndExprContext endExpr() {
		EndExprContext _localctx = new EndExprContext(Context, State);
		EnterRule(_localctx, 64, RULE_endExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
[RuleVersion(0)]
RuleVersion(0)
RuleVersion
(0)
0
0
EndExprContext
()
{
		EndExprContext _localctx = new EndExprContext(Context, State);
		EnterRule(_localctx, 64, RULE_endExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}
EndExprContext _localctx = new EndExprContext(Context, State);
EndExprContext _localctx = new EndExprContext(Context, State)
EndExprContext
_localctx = new EndExprContext(Context, State)
= new EndExprContext(Context, State)
new EndExprContext(Context, State)
EndExprContext
(Context, State)
Context
Context
State
State
EnterRule(_localctx, 64, RULE_endExpr);
EnterRule(_localctx, 64, RULE_endExpr)
EnterRule
(_localctx, 64, RULE_endExpr)
_localctx
_localctx
64
64
RULE_endExpr
RULE_endExpr
int _la;
int _la
int
_la
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
EnterOuterAlt(_localctx, 1);
EnterOuterAlt(_localctx, 1)
EnterOuterAlt
(_localctx, 1)
_localctx
_localctx
1
1
{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
State = 275;
State = 275
State
275
ErrorHandler.Sync(this);
ErrorHandler.Sync(this)
ErrorHandler.Sync
ErrorHandler
Sync
(this)
this
this
_la = TokenStream.LA(1);
_la = TokenStream.LA(1)
_la
TokenStream.LA(1)
TokenStream.LA
TokenStream
LA
(1)
1
1
if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}
_la==Termination
_la
Termination
{
				{
				State = 274;
				Match(Termination);
				}
			}
{
				State = 274;
				Match(Termination);
				}
State = 274;
State = 274
State
274
Match(Termination);
Match(Termination)
Match
(Termination)
Termination
Termination
State = 277;
State = 277
State
277
Match(End);
Match(End)
Match
(End)
End
End
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
(RecognitionException re)
RecognitionException
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
_localctx.exception = re;
_localctx.exception = re
_localctx.exception
_localctx
exception
re
ErrorHandler.ReportError(this, re);
ErrorHandler.ReportError(this, re)
ErrorHandler.ReportError
ErrorHandler
ReportError
(this, re)
this
this
re
re
ErrorHandler.Recover(this, re);
ErrorHandler.Recover(this, re)
ErrorHandler.Recover
ErrorHandler
Recover
(this, re)
this
this
re
re
finally {
			ExitRule();
		}
{
			ExitRule();
		}
ExitRule();
ExitRule()
ExitRule
()
return _localctx;
_localctx
private static int[] _serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	};
int[] _serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	}
int[]
int
[]

_serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	}
= {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	}
{
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	}
4
1
67
280
2
0
7
0
2
1
7
1
2
2
7
2
2
3
7
3
2
4
7
4
2
5
7
5
2
6
7
6
2
7
7
7
2
8
7
8
2
9
7
9
2
10
7
10
2
11
7
11
2
12
7
12
2
13
7
13
2
14
7
14
2
15
7
15
2
16
7
16
2
17
7
17
2
18
7
18
2
19
7
19
2
20
7
20
2
21
7
21
2
22
7
22
2
23
7
23
2
24
7
24
2
25
7
25
2
26
7
26
2
27
7
27
2
28
7
28
2
29
7
29
2
30
7
30
2
31
7
31
2
32
7
32
1
0
1
0
1
0
4
0
70
8
0
11
0
12
0
71
3
0
74
8
0
1
0
1
0
3
0
78
8
0
1
1
3
1
81
8
1
1
1
1
1
1
1
1
1
1
1
3
1
88
8
1
1
2
3
2
91
8
2
1
2
3
2
94
8
2
1
2
1
2
3
2
98
8
2
1
3
1
3
1
3
5
3
103
8
3
10
3
12
3
106
9
3
1
3
1
3
1
4
1
4
1
4
1
5
1
5
1
5
1
6
1
6
5
6
118
8
6
10
6
12
6
121
9
6
1
6
1
6
1
7
1
7
1
7
1
7
1
8
1
8
3
8
131
8
8
1
9
1
9
1
10
3
10
136
8
10
1
10
1
10
1
11
1
11
3
11
142
8
11
1
11
1
11
5
11
146
8
11
10
11
12
11
149
9
11
1
11
1
11
1
12
3
12
154
8
12
1
12
1
12
1
13
3
13
159
8
13
1
13
1
13
3
13
163
8
13
1
13
1
13
1
14
1
14
3
14
169
8
14
1
15
1
15
1
15
1
16
1
16
1
16
1
17
1
17
1
17
3
17
180
8
17
1
18
3
18
183
8
18
1
18
3
18
186
8
18
1
18
1
18
3
18
190
8
18
1
19
1
19
3
19
194
8
19
1
20
1
20
3
20
198
8
20
1
20
1
20
1
21
1
21
1
21
1
22
1
22
1
22
1
23
1
23
1
23
1
23
1
24
1
24
1
24
1
24
5
24
216
8
24
10
24
12
24
219
9
24
1
24
1
24
1
25
1
25
1
25
1
25
1
26
1
26
1
26
1
26
5
26
231
8
26
10
26
12
26
234
9
26
1
26
3
26
237
8
26
1
26
1
26
1
27
1
27
1
27
1
27
1
27
1
28
1
28
1
28
5
28
249
8
28
10
28
12
28
252
9
28
1
28
1
28
1
28
1
29
1
29
1
29
3
29
260
8
29
1
30
1
30
1
30
1
30
1
30
4
30
267
8
30
11
30
12
30
268
1
31
1
31
3
31
273
8
31
1
32
3
32
276
8
32
1
32
1
32
1
32
0
0
33
0
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
42
44
46
48
50
52
54
56
58
60
62
64
0
1
2
0
5
5
7
7
281
0
77
1
0
0
0
2
80
1
0
0
0
4
90
1
0
0
0
6
99
1
0
0
0
8
109
1
0
0
0
10
112
1
0
0
0
12
119
1
0
0
0
14
124
1
0
0
0
16
130
1
0
0
0
18
132
1
0
0
0
20
135
1
0
0
0
22
141
1
0
0
0
24
153
1
0
0
0
26
158
1
0
0
0
28
168
1
0
0
0
30
170
1
0
0
0
32
173
1
0
0
0
34
176
1
0
0
0
36
182
1
0
0
0
38
193
1
0
0
0
40
197
1
0
0
0
42
201
1
0
0
0
44
204
1
0
0
0
46
207
1
0
0
0
48
211
1
0
0
0
50
222
1
0
0
0
52
226
1
0
0
0
54
240
1
0
0
0
56
250
1
0
0
0
58
256
1
0
0
0
60
261
1
0
0
0
62
272
1
0
0
0
64
275
1
0
0
0
66
78
5
0
0
1
67
74
3
2
1
0
68
70
3
8
4
0
69
68
1
0
0
0
70
71
1
0
0
0
71
69
1
0
0
0
71
72
1
0
0
0
72
74
1
0
0
0
73
67
1
0
0
0
73
69
1
0
0
0
74
75
1
0
0
0
75
76
5
0
0
1
76
78
1
0
0
0
77
66
1
0
0
0
77
73
1
0
0
0
78
1
1
0
0
0
79
81
5
57
0
0
80
79
1
0
0
0
80
81
1
0
0
0
81
87
1
0
0
0
82
88
3
22
11
0
83
88
3
4
2
0
84
88
3
6
3
0
85
88
3
10
5
0
86
88
3
28
14
0
87
82
1
0
0
0
87
83
1
0
0
0
87
84
1
0
0
0
87
85
1
0
0
0
87
86
1
0
0
0
88
3
1
0
0
0
89
91
5
6
0
0
90
89
1
0
0
0
90
91
1
0
0
0
91
93
1
0
0
0
92
94
5
7
0
0
93
92
1
0
0
0
93
94
1
0
0
0
94
95
1
0
0
0
95
97
3
34
17
0
96
98
3
32
16
0
97
96
1
0
0
0
97
98
1
0
0
0
98
5
1
0
0
0
99
100
5
10
0
0
100
104
5
61
0
0
101
103
3
2
1
0
102
101
1
0
0
0
103
106
1
0
0
0
104
102
1
0
0
0
104
105
1
0
0
0
105
107
1
0
0
0
106
104
1
0
0
0
107
108
3
64
32
0
108
7
1
0
0
0
109
110
3
2
1
0
110
111
5
57
0
0
111
9
1
0
0
0
112
113
5
3
0
0
113
114
3
12
6
0
114
11
1
0
0
0
115
116
5
61
0
0
116
118
5
55
0
0
117
115
1
0
0
0
118
121
1
0
0
0
119
117
1
0
0
0
119
120
1
0
0
0
120
122
1
0
0
0
121
119
1
0
0
0
122
123
5
61
0
0
123
13
1
0
0
0
124
125
3
12
6
0
125
126
5
55
0
0
126
127
5
61
0
0
127
15
1
0
0
0
128
131
3
14
7
0
129
131
5
61
0
0
130
128
1
0
0
0
130
129
1
0
0
0
131
17
1
0
0
0
132
133
5
2
0
0
133
19
1
0
0
0
134
136
5
8
0
0
135
134
1
0
0
0
135
136
1
0
0
0
136
137
1
0
0
0
137
138
5
11
0
0
138
21
1
0
0
0
139
142
3
18
9
0
140
142
3
20
10
0
141
139
1
0
0
0
141
140
1
0
0
0
142
143
1
0
0
0
143
147
3
58
29
0
144
146
3
26
13
0
145
144
1
0
0
0
146
149
1
0
0
0
147
145
1
0
0
0
147
148
1
0
0
0
148
150
1
0
0
0
149
147
1
0
0
0
150
151
3
64
32
0
151
23
1
0
0
0
152
154
5
6
0
0
153
152
1
0
0
0
153
154
1
0
0
0
154
155
1
0
0
0
155
156
3
34
17
0
156
25
1
0
0
0
157
159
5
57
0
0
158
157
1
0
0
0
158
159
1
0
0
0
159
162
1
0
0
0
160
163
3
38
19
0
161
163
3
24
12
0
162
160
1
0
0
0
162
161
1
0
0
0
163
164
1
0
0
0
164
165
5
57
0
0
165
27
1
0
0
0
166
169
3
44
22
0
167
169
3
36
18
0
168
166
1
0
0
0
168
167
1
0
0
0
169
29
1
0
0
0
170
171
3
28
14
0
171
172
5
57
0
0
172
31
1
0
0
0
173
174
5
59
0
0
174
175
3
28
14
0
175
33
1
0
0
0
176
179
5
61
0
0
177
178
5
50
0
0
178
180
3
62
31
0
179
177
1
0
0
0
179
180
1
0
0
0
180
35
1
0
0
0
181
183
5
6
0
0
182
181
1
0
0
0
182
183
1
0
0
0
183
185
1
0
0
0
184
186
7
0
0
0
185
184
1
0
0
0
185
186
1
0
0
0
186
187
1
0
0
0
187
189
3
34
17
0
188
190
3
32
16
0
189
188
1
0
0
0
189
190
1
0
0
0
190
37
1
0
0
0
191
194
3
46
23
0
192
194
3
48
24
0
193
191
1
0
0
0
193
192
1
0
0
0
194
39
1
0
0
0
195
198
3
12
6
0
196
198
5
61
0
0
197
195
1
0
0
0
197
196
1
0
0
0
198
199
1
0
0
0
199
200
3
52
26
0
200
41
1
0
0
0
201
202
3
30
15
0
202
203
5
57
0
0
203
43
1
0
0
0
204
205
3
16
8
0
205
206
3
50
25
0
206
45
1
0
0
0
207
208
3
40
20
0
208
209
5
53
0
0
209
210
3
42
21
0
210
47
1
0
0
0
211
212
5
9
0
0
212
213
3
40
20
0
213
217
5
57
0
0
214
216
3
42
21
0
215
214
1
0
0
0
216
219
1
0
0
0
217
215
1
0
0
0
217
218
1
0
0
0
218
220
1
0
0
0
219
217
1
0
0
0
220
221
3
64
32
0
221
49
1
0
0
0
222
223
5
22
0
0
223
224
3
56
28
0
224
225
5
21
0
0
225
51
1
0
0
0
226
236
5
22
0
0
227
228
3
34
17
0
228
229
5
52
0
0
229
231
1
0
0
0
230
227
1
0
0
0
231
234
1
0
0
0
232
230
1
0
0
0
232
233
1
0
0
0
233
235
1
0
0
0
234
232
1
0
0
0
235
237
3
34
17
0
236
232
1
0
0
0
236
237
1
0
0
0
237
238
1
0
0
0
238
239
5
21
0
0
239
53
1
0
0
0
240
241
5
22
0
0
241
242
3
56
28
0
242
243
5
52
0
0
243
244
5
21
0
0
244
55
1
0
0
0
245
246
3
28
14
0
246
247
5
52
0
0
247
249
1
0
0
0
248
245
1
0
0
0
249
252
1
0
0
0
250
248
1
0
0
0
250
251
1
0
0
0
251
253
1
0
0
0
252
250
1
0
0
0
253
254
5
52
0
0
254
255
3
28
14
0
255
57
1
0
0
0
256
259
5
61
0
0
257
258
5
4
0
0
258
260
3
62
31
0
259
257
1
0
0
0
259
260
1
0
0
0
260
59
1
0
0
0
261
266
5
61
0
0
262
263
5
26
0
0
263
264
3
62
31
0
264
265
5
25
0
0
265
267
1
0
0
0
266
262
1
0
0
0
267
268
1
0
0
0
268
266
1
0
0
0
268
269
1
0
0
0
269
61
1
0
0
0
270
273
5
61
0
0
271
273
3
60
30
0
272
270
1
0
0
0
272
271
1
0
0
0
273
63
1
0
0
0
274
276
5
57
0
0
275
274
1
0
0
0
275
276
1
0
0
0
276
277
1
0
0
0
277
278
5
20
0
0
278
65
1
0
0
0
32
71
73
77
80
87
90
93
97
104
119
130
135
141
147
153
158
162
168
179
182
185
189
193
197
217
232
236
250
259
268
272
275
public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);
ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN)
ATN
_ATN =
		new ATNDeserializer().Deserialize(_serializedATN)
=
		new ATNDeserializer().Deserialize(_serializedATN)
new ATNDeserializer().Deserialize(_serializedATN)
new ATNDeserializer().Deserialize
new ATNDeserializer()
ATNDeserializer
()
Deserialize
(_serializedATN)
_serializedATN
_serializedATN
namespace HyperSphere {
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using IToken = Antlr4.Runtime.IToken;

/// <summary>
/// This interface defines a complete generic visitor for a parse tree produced
/// by <see cref="JuliaParser"/>.
/// </summary>
/// <typeparam name="Result">The return type of the visit operation.</typeparam>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaVisitor<Result> : IParseTreeVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context);
}
} // namespace HyperSphere

namespace HyperSphere {
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using IToken = Antlr4.Runtime.IToken;

/// <summary>
/// This interface defines a complete generic visitor for a parse tree produced
/// by <see cref="JuliaParser"/>.
/// </summary>
/// <typeparam name="Result">The return type of the visit operation.</typeparam>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaVisitor<Result> : IParseTreeVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context);
}
}
HyperSphere
using Antlr4.Runtime.Misc;
Antlr4.Runtime.Misc
Antlr4.Runtime
Antlr4
Runtime
Misc
using Antlr4.Runtime.Tree;
Antlr4.Runtime.Tree
Antlr4.Runtime
Antlr4
Runtime
Tree
using IToken = Antlr4.Runtime.IToken;
IToken =
IToken
Antlr4.Runtime.IToken
Antlr4.Runtime
Antlr4
Runtime
IToken
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaVisitor<Result> : IParseTreeVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context);
}
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")
System.CodeDom.Compiler.GeneratedCode
System.CodeDom.Compiler
System.CodeDom
System
CodeDom
Compiler
GeneratedCode
("ANTLR", "4.10.1")
"ANTLR"
"ANTLR"
"4.10.1"
"4.10.1"
[System.CLSCompliant(false)]
System.CLSCompliant(false)
System.CLSCompliant
System
CLSCompliant
(false)
false
false
<Result>
Result
: IParseTreeVisitor<Result>
IParseTreeVisitor<Result>
IParseTreeVisitor<Result>
<Result>
Result
Result VisitScript([NotNull] JuliaParser.ScriptContext context);
Result
([NotNull] JuliaParser.ScriptContext context)
[NotNull] JuliaParser.ScriptContext context
[NotNull]
NotNull
NotNull
JuliaParser.ScriptContext
JuliaParser
ScriptContext
Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
Result
([NotNull] JuliaParser.ModuleExprContext context)
[NotNull] JuliaParser.ModuleExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprContext
JuliaParser
ModuleExprContext
Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
Result
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)
[NotNull] JuliaParser.ModuleVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleVariableDeclarationContext
JuliaParser
ModuleVariableDeclarationContext
Result VisitModule([NotNull] JuliaParser.ModuleContext context);
Result
([NotNull] JuliaParser.ModuleContext context)
[NotNull] JuliaParser.ModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleContext
JuliaParser
ModuleContext
Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
Result
([NotNull] JuliaParser.ModuleExprStatementContext context)
[NotNull] JuliaParser.ModuleExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleExprStatementContext
JuliaParser
ModuleExprStatementContext
Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
Result
([NotNull] JuliaParser.UsingModuleContext context)
[NotNull] JuliaParser.UsingModuleContext context
[NotNull]
NotNull
NotNull
JuliaParser.UsingModuleContext
JuliaParser
UsingModuleContext
Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
Result
([NotNull] JuliaParser.ModuleRefContext context)
[NotNull] JuliaParser.ModuleRefContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleRefContext
JuliaParser
ModuleRefContext
Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
Result
([NotNull] JuliaParser.ModuleIdentifierContext context)
[NotNull] JuliaParser.ModuleIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.ModuleIdentifierContext
JuliaParser
ModuleIdentifierContext
Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
Result
([NotNull] JuliaParser.SymbolIdentifierContext context)
[NotNull] JuliaParser.SymbolIdentifierContext context
[NotNull]
NotNull
NotNull
JuliaParser.SymbolIdentifierContext
JuliaParser
SymbolIdentifierContext
Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
Result
([NotNull] JuliaParser.AbstractStructureContext context)
[NotNull] JuliaParser.AbstractStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.AbstractStructureContext
JuliaParser
AbstractStructureContext
Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
Result
([NotNull] JuliaParser.CompositeStructureContext context)
[NotNull] JuliaParser.CompositeStructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.CompositeStructureContext
JuliaParser
CompositeStructureContext
Result VisitStructure([NotNull] JuliaParser.StructureContext context);
Result
([NotNull] JuliaParser.StructureContext context)
[NotNull] JuliaParser.StructureContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructureContext
JuliaParser
StructureContext
Result VisitStructField([NotNull] JuliaParser.StructFieldContext context);
Result
([NotNull] JuliaParser.StructFieldContext context)
[NotNull] JuliaParser.StructFieldContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructFieldContext
JuliaParser
StructFieldContext
Result VisitStructItem([NotNull] JuliaParser.StructItemContext context);
Result
([NotNull] JuliaParser.StructItemContext context)
[NotNull] JuliaParser.StructItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.StructItemContext
JuliaParser
StructItemContext
Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
Result
([NotNull] JuliaParser.BlockExprContext context)
[NotNull] JuliaParser.BlockExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprContext
JuliaParser
BlockExprContext
Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
Result
([NotNull] JuliaParser.BlockExprStatementContext context)
[NotNull] JuliaParser.BlockExprStatementContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockExprStatementContext
JuliaParser
BlockExprStatementContext
Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
Result
([NotNull] JuliaParser.BlockVariableInstatiationContext context)
[NotNull] JuliaParser.BlockVariableInstatiationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableInstatiationContext
JuliaParser
BlockVariableInstatiationContext
Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context);
Result
([NotNull] JuliaParser.BlockArgContext context)
[NotNull] JuliaParser.BlockArgContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockArgContext
JuliaParser
BlockArgContext
Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
Result
([NotNull] JuliaParser.BlockVariableDeclarationContext context)
[NotNull] JuliaParser.BlockVariableDeclarationContext context
[NotNull]
NotNull
NotNull
JuliaParser.BlockVariableDeclarationContext
JuliaParser
BlockVariableDeclarationContext
Result VisitFunction([NotNull] JuliaParser.FunctionContext context);
Result
([NotNull] JuliaParser.FunctionContext context)
[NotNull] JuliaParser.FunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionContext
JuliaParser
FunctionContext
Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
Result
([NotNull] JuliaParser.FunctionHeaderContext context)
[NotNull] JuliaParser.FunctionHeaderContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionHeaderContext
JuliaParser
FunctionHeaderContext
Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
Result
([NotNull] JuliaParser.FunctionItemContext context)
[NotNull] JuliaParser.FunctionItemContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionItemContext
JuliaParser
FunctionItemContext
Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
Result
([NotNull] JuliaParser.FunctionCallContext context)
[NotNull] JuliaParser.FunctionCallContext context
[NotNull]
NotNull
NotNull
JuliaParser.FunctionCallContext
JuliaParser
FunctionCallContext
Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
Result
([NotNull] JuliaParser.ShortFunctionContext context)
[NotNull] JuliaParser.ShortFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.ShortFunctionContext
JuliaParser
ShortFunctionContext
Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
Result
([NotNull] JuliaParser.LongFunctionContext context)
[NotNull] JuliaParser.LongFunctionContext context
[NotNull]
NotNull
NotNull
JuliaParser.LongFunctionContext
JuliaParser
LongFunctionContext
Result VisitTuple([NotNull] JuliaParser.TupleContext context);
Result
([NotNull] JuliaParser.TupleContext context)
[NotNull] JuliaParser.TupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleContext
JuliaParser
TupleContext
Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
Result
([NotNull] JuliaParser.NamedTupleContext context)
[NotNull] JuliaParser.NamedTupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.NamedTupleContext
JuliaParser
NamedTupleContext
Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context);
Result
([NotNull] JuliaParser.TypetupleContext context)
[NotNull] JuliaParser.TypetupleContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypetupleContext
JuliaParser
TypetupleContext
Result VisitTupleList([NotNull] JuliaParser.TupleListContext context);
Result
([NotNull] JuliaParser.TupleListContext context)
[NotNull] JuliaParser.TupleListContext context
[NotNull]
NotNull
NotNull
JuliaParser.TupleListContext
JuliaParser
TupleListContext
Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context);
Result
([NotNull] JuliaParser.TypeNameContext context)
[NotNull] JuliaParser.TypeNameContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeNameContext
JuliaParser
TypeNameContext
Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
Result
([NotNull] JuliaParser.ParameterizedTypeContext context)
[NotNull] JuliaParser.ParameterizedTypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.ParameterizedTypeContext
JuliaParser
ParameterizedTypeContext
Result VisitType([NotNull] JuliaParser.TypeContext context);
Result
([NotNull] JuliaParser.TypeContext context)
[NotNull] JuliaParser.TypeContext context
[NotNull]
NotNull
NotNull
JuliaParser.TypeContext
JuliaParser
TypeContext
Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context);
Result
([NotNull] JuliaParser.EndExprContext context)
[NotNull] JuliaParser.EndExprContext context
[NotNull]
NotNull
NotNull
JuliaParser.EndExprContext
JuliaParser
EndExprContext
using System;
using System.IO;
using System.Text;
using Antlr4.Runtime;
using Antlr4.Runtime.Tree;
using HyperSphere;
using runtime.core;

namespace runtime.parse
{
    public class JuliaParserErrorListener<Symbol> : IAntlrErrorListener<Symbol>
    {
        private bool EncounteredError;
        private int err_count = 0;

        public void SyntaxError(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine,
            string msg, RecognitionException e) {
            if (err_count++ == 3) 
                Finish();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);
            Console.ResetColor();
        }

        public void Finish() {
            if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");
        }
    }

    public class JuliappParser
    {
        private readonly BaseInputCharStream _stream;
        private readonly JuliaLexer _lexer;
        private readonly JuliaParser _parser;
        private readonly CommonTokenStream _token_stream;
        public readonly JuliaParser.ScriptContext script;

        public JuliappParser(string s) : this(new AntlrInputStream(s)){}
        public JuliappParser(FileInfo file) : this(new AntlrFileStream(file.Name)){}

        public JuliappParser(BaseInputCharStream stream) {
            _stream = stream;
            _lexer = new JuliaLexer(stream);
            _token_stream = new CommonTokenStream(_lexer);
            _parser = new JuliaParser(_token_stream);
            var listener = new JuliaParserErrorListener<IToken>();
            _parser.RemoveErrorListeners();
            _parser.AddErrorListener(listener);
            script = _parser.script();
            listener.Finish();
        }

        public override string ToString() => PrintSyntaxTree(_parser, script);
        
        public static string PrintSyntaxTree(Parser parser, IParseTree root) {
            StringBuilder buf = new StringBuilder();
            Recursive(root, buf, 0,  parser.RuleNames);
            return buf.ToString();
        }

        private static void Recursive(IParseTree aRoot, StringBuilder buf, int offset, string[] ruleNames) {
            for (int i = 0; i < offset; i++) buf.Append("  ");
            buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");
            if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
        }
    }
}
using System;
System
using System.IO;
System.IO
System
IO
using System.Text;
System.Text
System
Text
using Antlr4.Runtime;
Antlr4.Runtime
Antlr4
Runtime
using Antlr4.Runtime.Tree;
Antlr4.Runtime.Tree
Antlr4.Runtime
Antlr4
Runtime
Tree
using HyperSphere;
HyperSphere
using runtime.core;
runtime.core
runtime
core
namespace runtime.parse
{
    public class JuliaParserErrorListener<Symbol> : IAntlrErrorListener<Symbol>
    {
        private bool EncounteredError;
        private int err_count = 0;

        public void SyntaxError(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine,
            string msg, RecognitionException e) {
            if (err_count++ == 3) 
                Finish();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);
            Console.ResetColor();
        }

        public void Finish() {
            if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");
        }
    }

    public class JuliappParser
    {
        private readonly BaseInputCharStream _stream;
        private readonly JuliaLexer _lexer;
        private readonly JuliaParser _parser;
        private readonly CommonTokenStream _token_stream;
        public readonly JuliaParser.ScriptContext script;

        public JuliappParser(string s) : this(new AntlrInputStream(s)){}
        public JuliappParser(FileInfo file) : this(new AntlrFileStream(file.Name)){}

        public JuliappParser(BaseInputCharStream stream) {
            _stream = stream;
            _lexer = new JuliaLexer(stream);
            _token_stream = new CommonTokenStream(_lexer);
            _parser = new JuliaParser(_token_stream);
            var listener = new JuliaParserErrorListener<IToken>();
            _parser.RemoveErrorListeners();
            _parser.AddErrorListener(listener);
            script = _parser.script();
            listener.Finish();
        }

        public override string ToString() => PrintSyntaxTree(_parser, script);
        
        public static string PrintSyntaxTree(Parser parser, IParseTree root) {
            StringBuilder buf = new StringBuilder();
            Recursive(root, buf, 0,  parser.RuleNames);
            return buf.ToString();
        }

        private static void Recursive(IParseTree aRoot, StringBuilder buf, int offset, string[] ruleNames) {
            for (int i = 0; i < offset; i++) buf.Append("  ");
            buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");
            if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
        }
    }
}
runtime.parse
runtime
parse
public class JuliaParserErrorListener<Symbol> : IAntlrErrorListener<Symbol>
    {
        private bool EncounteredError;
        private int err_count = 0;

        public void SyntaxError(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine,
            string msg, RecognitionException e) {
            if (err_count++ == 3) 
                Finish();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);
            Console.ResetColor();
        }

        public void Finish() {
            if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");
        }
    }
<Symbol>
Symbol
: IAntlrErrorListener<Symbol>
IAntlrErrorListener<Symbol>
IAntlrErrorListener<Symbol>
<Symbol>
Symbol
private bool EncounteredError;
bool EncounteredError
bool
EncounteredError
private int err_count = 0;
int err_count = 0
int
err_count = 0
= 0
0
public void SyntaxError(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine,
            string msg, RecognitionException e) {
            if (err_count++ == 3) 
                Finish();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);
            Console.ResetColor();
        }
void
(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine,
            string msg, RecognitionException e)
TextWriter output
TextWriter
IRecognizer recognizer
IRecognizer
Symbol offendingSymbol
Symbol
int line
int
int charPositionInLine
int
string msg
string
RecognitionException e
RecognitionException
{
            if (err_count++ == 3) 
                Finish();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);
            Console.ResetColor();
        }
if (err_count++ == 3) 
                Finish();
err_count++ == 3
err_count++
err_count
3
Finish();
Finish()
Finish
()
Console.ForegroundColor = ConsoleColor.Red;
Console.ForegroundColor = ConsoleColor.Red
Console.ForegroundColor
Console
ForegroundColor
ConsoleColor.Red
ConsoleColor
Red
Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);
Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg)
Console.Error.WriteLine
Console.Error
Console
Error
WriteLine
("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg)
"Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg
"Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg
"Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t"
"Parsing Error @ Line:" + line + ":" + charPositionInLine
"Parsing Error @ Line:" + line + ":"
"Parsing Error @ Line:" + line
"Parsing Error @ Line:"
line
":"
charPositionInLine
"\t"
msg
Console.ResetColor();
Console.ResetColor()
Console.ResetColor
Console
ResetColor
()
public void Finish() {
            if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");
        }
void
()
{
            if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");
        }
if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");
err_count > 0
err_count
0
throw new JuliaException("Encountered " + err_count + " Parser Failures!");
new JuliaException("Encountered " + err_count + " Parser Failures!")
JuliaException
("Encountered " + err_count + " Parser Failures!")
"Encountered " + err_count + " Parser Failures!"
"Encountered " + err_count + " Parser Failures!"
"Encountered " + err_count
"Encountered "
err_count
" Parser Failures!"
public class JuliappParser
    {
        private readonly BaseInputCharStream _stream;
        private readonly JuliaLexer _lexer;
        private readonly JuliaParser _parser;
        private readonly CommonTokenStream _token_stream;
        public readonly JuliaParser.ScriptContext script;

        public JuliappParser(string s) : this(new AntlrInputStream(s)){}
        public JuliappParser(FileInfo file) : this(new AntlrFileStream(file.Name)){}

        public JuliappParser(BaseInputCharStream stream) {
            _stream = stream;
            _lexer = new JuliaLexer(stream);
            _token_stream = new CommonTokenStream(_lexer);
            _parser = new JuliaParser(_token_stream);
            var listener = new JuliaParserErrorListener<IToken>();
            _parser.RemoveErrorListeners();
            _parser.AddErrorListener(listener);
            script = _parser.script();
            listener.Finish();
        }

        public override string ToString() => PrintSyntaxTree(_parser, script);
        
        public static string PrintSyntaxTree(Parser parser, IParseTree root) {
            StringBuilder buf = new StringBuilder();
            Recursive(root, buf, 0,  parser.RuleNames);
            return buf.ToString();
        }

        private static void Recursive(IParseTree aRoot, StringBuilder buf, int offset, string[] ruleNames) {
            for (int i = 0; i < offset; i++) buf.Append("  ");
            buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");
            if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
        }
    }
private readonly BaseInputCharStream _stream;
BaseInputCharStream _stream
BaseInputCharStream
_stream
private readonly JuliaLexer _lexer;
JuliaLexer _lexer
JuliaLexer
_lexer
private readonly JuliaParser _parser;
JuliaParser _parser
JuliaParser
_parser
private readonly CommonTokenStream _token_stream;
CommonTokenStream _token_stream
CommonTokenStream
_token_stream
public readonly JuliaParser.ScriptContext script;
JuliaParser.ScriptContext script
JuliaParser.ScriptContext
JuliaParser
ScriptContext
script
public JuliappParser(string s) : this(new AntlrInputStream(s)){}
(string s)
string s
string
: this(new AntlrInputStream(s))
(new AntlrInputStream(s))
new AntlrInputStream(s)
new AntlrInputStream(s)
AntlrInputStream
(s)
s
s
{}
public JuliappParser(FileInfo file) : this(new AntlrFileStream(file.Name)){}
(FileInfo file)
FileInfo file
FileInfo
: this(new AntlrFileStream(file.Name))
(new AntlrFileStream(file.Name))
new AntlrFileStream(file.Name)
new AntlrFileStream(file.Name)
AntlrFileStream
(file.Name)
file.Name
file.Name
file
Name
{}
public JuliappParser(BaseInputCharStream stream) {
            _stream = stream;
            _lexer = new JuliaLexer(stream);
            _token_stream = new CommonTokenStream(_lexer);
            _parser = new JuliaParser(_token_stream);
            var listener = new JuliaParserErrorListener<IToken>();
            _parser.RemoveErrorListeners();
            _parser.AddErrorListener(listener);
            script = _parser.script();
            listener.Finish();
        }
(BaseInputCharStream stream)
BaseInputCharStream stream
BaseInputCharStream
{
            _stream = stream;
            _lexer = new JuliaLexer(stream);
            _token_stream = new CommonTokenStream(_lexer);
            _parser = new JuliaParser(_token_stream);
            var listener = new JuliaParserErrorListener<IToken>();
            _parser.RemoveErrorListeners();
            _parser.AddErrorListener(listener);
            script = _parser.script();
            listener.Finish();
        }
_stream = stream;
_stream = stream
_stream
stream
_lexer = new JuliaLexer(stream);
_lexer = new JuliaLexer(stream)
_lexer
new JuliaLexer(stream)
JuliaLexer
(stream)
stream
stream
_token_stream = new CommonTokenStream(_lexer);
_token_stream = new CommonTokenStream(_lexer)
_token_stream
new CommonTokenStream(_lexer)
CommonTokenStream
(_lexer)
_lexer
_lexer
_parser = new JuliaParser(_token_stream);
_parser = new JuliaParser(_token_stream)
_parser
new JuliaParser(_token_stream)
JuliaParser
(_token_stream)
_token_stream
_token_stream
var listener = new JuliaParserErrorListener<IToken>();
var listener = new JuliaParserErrorListener<IToken>()
var
listener = new JuliaParserErrorListener<IToken>()
= new JuliaParserErrorListener<IToken>()
new JuliaParserErrorListener<IToken>()
JuliaParserErrorListener<IToken>
<IToken>
IToken
()
_parser.RemoveErrorListeners();
_parser.RemoveErrorListeners()
_parser.RemoveErrorListeners
_parser
RemoveErrorListeners
()
_parser.AddErrorListener(listener);
_parser.AddErrorListener(listener)
_parser.AddErrorListener
_parser
AddErrorListener
(listener)
listener
listener
script = _parser.script();
script = _parser.script()
script
_parser.script()
_parser.script
_parser
script
()
listener.Finish();
listener.Finish()
listener.Finish
listener
Finish
()
public override string ToString() => PrintSyntaxTree(_parser, script);
string
()
=> PrintSyntaxTree(_parser, script)
PrintSyntaxTree(_parser, script)
PrintSyntaxTree
(_parser, script)
_parser
_parser
script
script
public static string PrintSyntaxTree(Parser parser, IParseTree root) {
            StringBuilder buf = new StringBuilder();
            Recursive(root, buf, 0,  parser.RuleNames);
            return buf.ToString();
        }
string
(Parser parser, IParseTree root)
Parser parser
Parser
IParseTree root
IParseTree
{
            StringBuilder buf = new StringBuilder();
            Recursive(root, buf, 0,  parser.RuleNames);
            return buf.ToString();
        }
StringBuilder buf = new StringBuilder();
StringBuilder buf = new StringBuilder()
StringBuilder
buf = new StringBuilder()
= new StringBuilder()
new StringBuilder()
StringBuilder
()
Recursive(root, buf, 0,  parser.RuleNames);
Recursive(root, buf, 0,  parser.RuleNames)
Recursive
(root, buf, 0,  parser.RuleNames)
root
root
buf
buf
0
0
parser.RuleNames
parser.RuleNames
parser
RuleNames
return buf.ToString();
buf.ToString()
buf.ToString
buf
ToString
()
private static void Recursive(IParseTree aRoot, StringBuilder buf, int offset, string[] ruleNames) {
            for (int i = 0; i < offset; i++) buf.Append("  ");
            buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");
            if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
        }
void
(IParseTree aRoot, StringBuilder buf, int offset, string[] ruleNames)
IParseTree aRoot
IParseTree
StringBuilder buf
StringBuilder
int offset
int
string[] ruleNames
string[]
string
[]

{
            for (int i = 0; i < offset; i++) buf.Append("  ");
            buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");
            if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
        }
for (int i = 0; i < offset; i++) buf.Append("  ");
int i = 0
int
i = 0
= 0
0
i < offset
i
offset
i++
i
buf.Append("  ");
buf.Append("  ")
buf.Append
buf
Append
("  ")
"  "
"  "
buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");
buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n")
buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append
buf.Append(Trees.GetNodeText(aRoot, ruleNames))
buf.Append
buf
Append
(Trees.GetNodeText(aRoot, ruleNames))
Trees.GetNodeText(aRoot, ruleNames)
Trees.GetNodeText(aRoot, ruleNames)
Trees.GetNodeText
Trees
GetNodeText
(aRoot, ruleNames)
aRoot
aRoot
ruleNames
ruleNames
Append
("\n")
"\n"
"\n"
if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
aRoot is ParserRuleContext
aRoot
ParserRuleContext
{
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
ParserRuleContext prc = (ParserRuleContext) aRoot;
ParserRuleContext prc = (ParserRuleContext) aRoot
ParserRuleContext
prc = (ParserRuleContext) aRoot
= (ParserRuleContext) aRoot
(ParserRuleContext) aRoot
ParserRuleContext
aRoot
if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
prc.children != null
prc.children
prc
children
null
{
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
IParseTree
prc.children
prc
children
{
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
Recursive(child, buf, offset + 1, ruleNames);
Recursive(child, buf, offset + 1, ruleNames)
Recursive
(child, buf, offset + 1, ruleNames)
child
child
buf
buf
offset + 1
offset + 1
offset
1
ruleNames
ruleNames
using System;
using Antlr4.Runtime.Tree;
using HyperSphere;
using runtime.core;
using runtime.core.JIL;
using runtime.core.Runtime;

namespace runtime.parse
{
    internal class ExprFrame {
        public JILTypeBuilder Type;
        public JILModuleBuilder Module;
        public JILExprBuilder Expr;

        internal ExprFrame(JILTypeBuilder type, JILModuleBuilder module, JILExprBuilder expr) {
            Module = module;
            Expr = expr;
            Type = type;
        }
    }

    internal struct JuliaStaticCompiler {
        private JuliappParser _p;

        public JRuntimeExpr Compile(JuliappParser p, JRuntimeModule evaluationModule) {
            _p = p;
            Console.WriteLine(_p.ToString());
            return Compile(_p.script, evaluationModule);
        }
        
        public JILFieldBuilder CompileField(ITerminalNode nameID, JuliaParser.TypeContext type, ExprFrame frame, bool isConst, bool isGlobal) {
            var f = new JILFieldBuilder(Compile(nameID), frame.Expr);
            f.IsConst = isConst;
            f.IsGlobal = isGlobal;

            var ty = type != null ? Compile(type.Identifier()) : "Any";
            f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);

            return f;
        }

        public void Compile(JuliaParser.BlockExprContext ctx, ExprFrame frame) {
            if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
        }

        public void Compile(JuliaParser.ModuleContext ctx, ExprFrame frame)
        {
            var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));
            if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
            mod.Create();
        }

        public void Compile(JuliaParser.FunctionContext ctx, ExprFrame frame) {
            
        }

        public string Compile(ITerminalNode n) => n.GetText();

        public void Compile(JuliaParser.TypeNameContext ctx, out string TypeName, out IJType ExtendedTypeName) {
            TypeName = ctx.Identifier().GetText();
            if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;
        }
        
        public void Compile(JuliaParser.StructureContext ctx, ExprFrame frame)
        {
            string name = Compile(ctx.typeName().Identifier());
            JTypeType typetype = JTypeType.None;

            if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;

            var tb = frame.Module.DefineType(name);
            tb.Type = typetype;
            frame.Type = tb;
            foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }

            frame.Expr.Code.InstantiateType(tb);
            
            frame.Type = null;
        }
        
        public void Compile(JuliaParser.UsingModuleContext ctx, ExprFrame frame) {
            var ids = ctx.moduleRef().Identifier();
            var str = ctx.moduleRef().GetText().Substring(5);
            frame.Module.AddName(str, true, false);
        }
        
        public object Compile(JuliaParser.FunctionCallContext ctx, ExprFrame frame) => null;
        public void Compile(JuliaParser.ModuleExprContext ctx, ExprFrame frame) {
            if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
        }
        
        public JRuntimeExpr Compile(JuliaParser.ScriptContext ctx, JRuntimeModule evaluationModule) {
            JILBuilder eb = new(evaluationModule);
            ExprFrame frame = new(null, eb, eb);
            
            if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }

            return eb.CreateExpression();
        }
    }
}
using System;
System
using Antlr4.Runtime.Tree;
Antlr4.Runtime.Tree
Antlr4.Runtime
Antlr4
Runtime
Tree
using HyperSphere;
HyperSphere
using runtime.core;
runtime.core
runtime
core
using runtime.core.JIL;
runtime.core.JIL
runtime.core
runtime
core
JIL
using runtime.core.Runtime;
runtime.core.Runtime
runtime.core
runtime
core
Runtime
namespace runtime.parse
{
    internal class ExprFrame {
        public JILTypeBuilder Type;
        public JILModuleBuilder Module;
        public JILExprBuilder Expr;

        internal ExprFrame(JILTypeBuilder type, JILModuleBuilder module, JILExprBuilder expr) {
            Module = module;
            Expr = expr;
            Type = type;
        }
    }

    internal struct JuliaStaticCompiler {
        private JuliappParser _p;

        public JRuntimeExpr Compile(JuliappParser p, JRuntimeModule evaluationModule) {
            _p = p;
            Console.WriteLine(_p.ToString());
            return Compile(_p.script, evaluationModule);
        }
        
        public JILFieldBuilder CompileField(ITerminalNode nameID, JuliaParser.TypeContext type, ExprFrame frame, bool isConst, bool isGlobal) {
            var f = new JILFieldBuilder(Compile(nameID), frame.Expr);
            f.IsConst = isConst;
            f.IsGlobal = isGlobal;

            var ty = type != null ? Compile(type.Identifier()) : "Any";
            f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);

            return f;
        }

        public void Compile(JuliaParser.BlockExprContext ctx, ExprFrame frame) {
            if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
        }

        public void Compile(JuliaParser.ModuleContext ctx, ExprFrame frame)
        {
            var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));
            if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
            mod.Create();
        }

        public void Compile(JuliaParser.FunctionContext ctx, ExprFrame frame) {
            
        }

        public string Compile(ITerminalNode n) => n.GetText();

        public void Compile(JuliaParser.TypeNameContext ctx, out string TypeName, out IJType ExtendedTypeName) {
            TypeName = ctx.Identifier().GetText();
            if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;
        }
        
        public void Compile(JuliaParser.StructureContext ctx, ExprFrame frame)
        {
            string name = Compile(ctx.typeName().Identifier());
            JTypeType typetype = JTypeType.None;

            if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;

            var tb = frame.Module.DefineType(name);
            tb.Type = typetype;
            frame.Type = tb;
            foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }

            frame.Expr.Code.InstantiateType(tb);
            
            frame.Type = null;
        }
        
        public void Compile(JuliaParser.UsingModuleContext ctx, ExprFrame frame) {
            var ids = ctx.moduleRef().Identifier();
            var str = ctx.moduleRef().GetText().Substring(5);
            frame.Module.AddName(str, true, false);
        }
        
        public object Compile(JuliaParser.FunctionCallContext ctx, ExprFrame frame) => null;
        public void Compile(JuliaParser.ModuleExprContext ctx, ExprFrame frame) {
            if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
        }
        
        public JRuntimeExpr Compile(JuliaParser.ScriptContext ctx, JRuntimeModule evaluationModule) {
            JILBuilder eb = new(evaluationModule);
            ExprFrame frame = new(null, eb, eb);
            
            if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }

            return eb.CreateExpression();
        }
    }
}
runtime.parse
runtime
parse
internal class ExprFrame {
        public JILTypeBuilder Type;
        public JILModuleBuilder Module;
        public JILExprBuilder Expr;

        internal ExprFrame(JILTypeBuilder type, JILModuleBuilder module, JILExprBuilder expr) {
            Module = module;
            Expr = expr;
            Type = type;
        }
    }
public JILTypeBuilder Type;
JILTypeBuilder Type
JILTypeBuilder
Type
public JILModuleBuilder Module;
JILModuleBuilder Module
JILModuleBuilder
Module
public JILExprBuilder Expr;
JILExprBuilder Expr
JILExprBuilder
Expr
internal ExprFrame(JILTypeBuilder type, JILModuleBuilder module, JILExprBuilder expr) {
            Module = module;
            Expr = expr;
            Type = type;
        }
(JILTypeBuilder type, JILModuleBuilder module, JILExprBuilder expr)
JILTypeBuilder type
JILTypeBuilder
JILModuleBuilder module
JILModuleBuilder
JILExprBuilder expr
JILExprBuilder
{
            Module = module;
            Expr = expr;
            Type = type;
        }
Module = module;
Module = module
Module
module
Expr = expr;
Expr = expr
Expr
expr
Type = type;
Type = type
Type
type
internal struct JuliaStaticCompiler {
        private JuliappParser _p;

        public JRuntimeExpr Compile(JuliappParser p, JRuntimeModule evaluationModule) {
            _p = p;
            Console.WriteLine(_p.ToString());
            return Compile(_p.script, evaluationModule);
        }
        
        public JILFieldBuilder CompileField(ITerminalNode nameID, JuliaParser.TypeContext type, ExprFrame frame, bool isConst, bool isGlobal) {
            var f = new JILFieldBuilder(Compile(nameID), frame.Expr);
            f.IsConst = isConst;
            f.IsGlobal = isGlobal;

            var ty = type != null ? Compile(type.Identifier()) : "Any";
            f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);

            return f;
        }

        public void Compile(JuliaParser.BlockExprContext ctx, ExprFrame frame) {
            if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
        }

        public void Compile(JuliaParser.ModuleContext ctx, ExprFrame frame)
        {
            var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));
            if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
            mod.Create();
        }

        public void Compile(JuliaParser.FunctionContext ctx, ExprFrame frame) {
            
        }

        public string Compile(ITerminalNode n) => n.GetText();

        public void Compile(JuliaParser.TypeNameContext ctx, out string TypeName, out IJType ExtendedTypeName) {
            TypeName = ctx.Identifier().GetText();
            if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;
        }
        
        public void Compile(JuliaParser.StructureContext ctx, ExprFrame frame)
        {
            string name = Compile(ctx.typeName().Identifier());
            JTypeType typetype = JTypeType.None;

            if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;

            var tb = frame.Module.DefineType(name);
            tb.Type = typetype;
            frame.Type = tb;
            foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }

            frame.Expr.Code.InstantiateType(tb);
            
            frame.Type = null;
        }
        
        public void Compile(JuliaParser.UsingModuleContext ctx, ExprFrame frame) {
            var ids = ctx.moduleRef().Identifier();
            var str = ctx.moduleRef().GetText().Substring(5);
            frame.Module.AddName(str, true, false);
        }
        
        public object Compile(JuliaParser.FunctionCallContext ctx, ExprFrame frame) => null;
        public void Compile(JuliaParser.ModuleExprContext ctx, ExprFrame frame) {
            if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
        }
        
        public JRuntimeExpr Compile(JuliaParser.ScriptContext ctx, JRuntimeModule evaluationModule) {
            JILBuilder eb = new(evaluationModule);
            ExprFrame frame = new(null, eb, eb);
            
            if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }

            return eb.CreateExpression();
        }
    }
private JuliappParser _p;
JuliappParser _p
JuliappParser
_p
public JRuntimeExpr Compile(JuliappParser p, JRuntimeModule evaluationModule) {
            _p = p;
            Console.WriteLine(_p.ToString());
            return Compile(_p.script, evaluationModule);
        }
JRuntimeExpr
(JuliappParser p, JRuntimeModule evaluationModule)
JuliappParser p
JuliappParser
JRuntimeModule evaluationModule
JRuntimeModule
{
            _p = p;
            Console.WriteLine(_p.ToString());
            return Compile(_p.script, evaluationModule);
        }
_p = p;
_p = p
_p
p
Console.WriteLine(_p.ToString());
Console.WriteLine(_p.ToString())
Console.WriteLine
Console
WriteLine
(_p.ToString())
_p.ToString()
_p.ToString()
_p.ToString
_p
ToString
()
return Compile(_p.script, evaluationModule);
Compile(_p.script, evaluationModule)
Compile
(_p.script, evaluationModule)
_p.script
_p.script
_p
script
evaluationModule
evaluationModule
public JILFieldBuilder CompileField(ITerminalNode nameID, JuliaParser.TypeContext type, ExprFrame frame, bool isConst, bool isGlobal) {
            var f = new JILFieldBuilder(Compile(nameID), frame.Expr);
            f.IsConst = isConst;
            f.IsGlobal = isGlobal;

            var ty = type != null ? Compile(type.Identifier()) : "Any";
            f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);

            return f;
        }
JILFieldBuilder
(ITerminalNode nameID, JuliaParser.TypeContext type, ExprFrame frame, bool isConst, bool isGlobal)
ITerminalNode nameID
ITerminalNode
JuliaParser.TypeContext type
JuliaParser.TypeContext
JuliaParser
TypeContext
ExprFrame frame
ExprFrame
bool isConst
bool
bool isGlobal
bool
{
            var f = new JILFieldBuilder(Compile(nameID), frame.Expr);
            f.IsConst = isConst;
            f.IsGlobal = isGlobal;

            var ty = type != null ? Compile(type.Identifier()) : "Any";
            f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);

            return f;
        }
var f = new JILFieldBuilder(Compile(nameID), frame.Expr);
var f = new JILFieldBuilder(Compile(nameID), frame.Expr)
var
f = new JILFieldBuilder(Compile(nameID), frame.Expr)
= new JILFieldBuilder(Compile(nameID), frame.Expr)
new JILFieldBuilder(Compile(nameID), frame.Expr)
JILFieldBuilder
(Compile(nameID), frame.Expr)
Compile(nameID)
Compile(nameID)
Compile
(nameID)
nameID
nameID
frame.Expr
frame.Expr
frame
Expr
f.IsConst = isConst;
f.IsConst = isConst
f.IsConst
f
IsConst
isConst
f.IsGlobal = isGlobal;
f.IsGlobal = isGlobal
f.IsGlobal
f
IsGlobal
isGlobal
var ty = type != null ? Compile(type.Identifier()) : "Any";
var ty = type != null ? Compile(type.Identifier()) : "Any"
var
ty = type != null ? Compile(type.Identifier()) : "Any"
= type != null ? Compile(type.Identifier()) : "Any"
type != null ? Compile(type.Identifier()) : "Any"
type != null
type
null
Compile(type.Identifier())
Compile
(type.Identifier())
type.Identifier()
type.Identifier()
type.Identifier
type
Identifier
()
"Any"
f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);
f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty)
f.TypeRef
f
TypeRef
(frame.Expr as IJExpr).GetNameRef(ty)
(frame.Expr as IJExpr).GetNameRef
(frame.Expr as IJExpr)
frame.Expr as IJExpr
frame.Expr
frame
Expr
IJExpr
GetNameRef
(ty)
ty
ty
return f;
f
public void Compile(JuliaParser.BlockExprContext ctx, ExprFrame frame) {
            if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
        }
void
(JuliaParser.BlockExprContext ctx, ExprFrame frame)
JuliaParser.BlockExprContext ctx
JuliaParser.BlockExprContext
JuliaParser
BlockExprContext
ExprFrame frame
ExprFrame
{
            if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
        }
if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
ctx.blockVariableDeclaration() != null
ctx.blockVariableDeclaration()
ctx.blockVariableDeclaration
ctx
blockVariableDeclaration
()
null
{
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            }
var bctx = ctx.blockVariableDeclaration();
var bctx = ctx.blockVariableDeclaration()
var
bctx = ctx.blockVariableDeclaration()
= ctx.blockVariableDeclaration()
ctx.blockVariableDeclaration()
ctx.blockVariableDeclaration
ctx
blockVariableDeclaration
()
CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null)
CompileField
(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null)
bctx.blockArg().Identifier()
bctx.blockArg().Identifier()
bctx.blockArg().Identifier
bctx.blockArg()
bctx.blockArg
bctx
blockArg
()
Identifier
()
bctx.blockArg().type()
bctx.blockArg().type()
bctx.blockArg().type
bctx.blockArg()
bctx.blockArg
bctx
blockArg
()
type
()
frame
frame
bctx.Const() != null
bctx.Const() != null
bctx.Const()
bctx.Const
bctx
Const
()
null
bctx.Local() == null
bctx.Local() == null
bctx.Local()
bctx.Local
bctx
Local
()
null
else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
ctx.functionCall() != null
ctx.functionCall()
ctx.functionCall
ctx
functionCall
()
null
Compile(ctx.functionCall(), frame);
Compile(ctx.functionCall(), frame)
Compile
(ctx.functionCall(), frame)
ctx.functionCall()
ctx.functionCall()
ctx.functionCall
ctx
functionCall
()
frame
frame
public void Compile(JuliaParser.ModuleContext ctx, ExprFrame frame)
        {
            var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));
            if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
            mod.Create();
        }
void
(JuliaParser.ModuleContext ctx, ExprFrame frame)
JuliaParser.ModuleContext ctx
JuliaParser.ModuleContext
JuliaParser
ModuleContext
ExprFrame frame
ExprFrame
{
            var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));
            if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
            mod.Create();
        }
var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));
var mod = frame.Module.DefineModule(Compile(ctx.Identifier()))
var
mod = frame.Module.DefineModule(Compile(ctx.Identifier()))
= frame.Module.DefineModule(Compile(ctx.Identifier()))
frame.Module.DefineModule(Compile(ctx.Identifier()))
frame.Module.DefineModule
frame.Module
frame
Module
DefineModule
(Compile(ctx.Identifier()))
Compile(ctx.Identifier())
Compile(ctx.Identifier())
Compile
(ctx.Identifier())
ctx.Identifier()
ctx.Identifier()
ctx.Identifier
ctx
Identifier
()
if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
ctx.moduleExpr() != null
ctx.moduleExpr()
ctx.moduleExpr
ctx
moduleExpr
()
null
{
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
ExprFrame frame2 = new(null, mod, mod);
ExprFrame frame2 = new(null, mod, mod)
ExprFrame
frame2 = new(null, mod, mod)
= new(null, mod, mod)
new(null, mod, mod)
(null, mod, mod)
null
null
mod
mod
mod
mod
foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
var
ctx.moduleExpr()
ctx.moduleExpr
ctx
moduleExpr
()
Compile(v, frame2);
Compile(v, frame2)
Compile
(v, frame2)
v
v
frame2
frame2
mod.Create();
mod.Create()
mod.Create
mod
Create
()
public void Compile(JuliaParser.FunctionContext ctx, ExprFrame frame) {
            
        }
void
(JuliaParser.FunctionContext ctx, ExprFrame frame)
JuliaParser.FunctionContext ctx
JuliaParser.FunctionContext
JuliaParser
FunctionContext
ExprFrame frame
ExprFrame
{
            
        }
public string Compile(ITerminalNode n) => n.GetText();
string
(ITerminalNode n)
ITerminalNode n
ITerminalNode
=> n.GetText()
n.GetText()
n.GetText
n
GetText
()
public void Compile(JuliaParser.TypeNameContext ctx, out string TypeName, out IJType ExtendedTypeName) {
            TypeName = ctx.Identifier().GetText();
            if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;
        }
void
(JuliaParser.TypeNameContext ctx, out string TypeName, out IJType ExtendedTypeName)
JuliaParser.TypeNameContext ctx
JuliaParser.TypeNameContext
JuliaParser
TypeNameContext
out string TypeName
string
out IJType ExtendedTypeName
IJType
{
            TypeName = ctx.Identifier().GetText();
            if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;
        }
TypeName = ctx.Identifier().GetText();
TypeName = ctx.Identifier().GetText()
TypeName
ctx.Identifier().GetText()
ctx.Identifier().GetText
ctx.Identifier()
ctx.Identifier
ctx
Identifier
()
GetText
()
if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;
ctx.type() != null
ctx.type()
ctx.type
ctx
type
()
null
{
                ExtendedTypeName = null;
            }
ExtendedTypeName = null;
ExtendedTypeName = null
ExtendedTypeName
null
else ExtendedTypeName = null;
ExtendedTypeName = null;
ExtendedTypeName = null
ExtendedTypeName
null
public void Compile(JuliaParser.StructureContext ctx, ExprFrame frame)
        {
            string name = Compile(ctx.typeName().Identifier());
            JTypeType typetype = JTypeType.None;

            if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;

            var tb = frame.Module.DefineType(name);
            tb.Type = typetype;
            frame.Type = tb;
            foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }

            frame.Expr.Code.InstantiateType(tb);
            
            frame.Type = null;
        }
void
(JuliaParser.StructureContext ctx, ExprFrame frame)
JuliaParser.StructureContext ctx
JuliaParser.StructureContext
JuliaParser
StructureContext
ExprFrame frame
ExprFrame
{
            string name = Compile(ctx.typeName().Identifier());
            JTypeType typetype = JTypeType.None;

            if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;

            var tb = frame.Module.DefineType(name);
            tb.Type = typetype;
            frame.Type = tb;
            foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }

            frame.Expr.Code.InstantiateType(tb);
            
            frame.Type = null;
        }
string name = Compile(ctx.typeName().Identifier());
string name = Compile(ctx.typeName().Identifier())
string
name = Compile(ctx.typeName().Identifier())
= Compile(ctx.typeName().Identifier())
Compile(ctx.typeName().Identifier())
Compile
(ctx.typeName().Identifier())
ctx.typeName().Identifier()
ctx.typeName().Identifier()
ctx.typeName().Identifier
ctx.typeName()
ctx.typeName
ctx
typeName
()
Identifier
()
JTypeType typetype = JTypeType.None;
JTypeType typetype = JTypeType.None
JTypeType
typetype = JTypeType.None
= JTypeType.None
JTypeType.None
JTypeType
None
if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;
ctx.abstractStructure() != null
ctx.abstractStructure()
ctx.abstractStructure
ctx
abstractStructure
()
null
typetype = JTypeType.Abstract;
typetype = JTypeType.Abstract
typetype
JTypeType.Abstract
JTypeType
Abstract
else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;
if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;
ctx.compositeStructure() != null
ctx.compositeStructure()
ctx.compositeStructure
ctx
compositeStructure
()
null
typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;
typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct
typetype
ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct
ctx.compositeStructure().Mutable() != null
ctx.compositeStructure().Mutable()
ctx.compositeStructure().Mutable
ctx.compositeStructure()
ctx.compositeStructure
ctx
compositeStructure
()
Mutable
()
null
JTypeType.Mutable
JTypeType
Mutable
JTypeType.Struct
JTypeType
Struct
var tb = frame.Module.DefineType(name);
var tb = frame.Module.DefineType(name)
var
tb = frame.Module.DefineType(name)
= frame.Module.DefineType(name)
frame.Module.DefineType(name)
frame.Module.DefineType
frame.Module
frame
Module
DefineType
(name)
name
name
tb.Type = typetype;
tb.Type = typetype
tb.Type
tb
Type
typetype
frame.Type = tb;
frame.Type = tb
frame.Type
frame
Type
tb
foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }
var
ctx.structItem()
ctx.structItem
ctx
structItem
()
{
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }
if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
item.function() != null
item.function()
item.function
item
function
()
null
{
                    Compile(item.function(), frame);
                }
Compile(item.function(), frame);
Compile(item.function(), frame)
Compile
(item.function(), frame)
item.function()
item.function()
item.function
item
function
()
frame
frame
else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
{
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
var sctx = item.structField();
var sctx = item.structField()
var
sctx = item.structField()
= item.structField()
item.structField()
item.structField
item
structField
()
tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false))
tb.AddField
tb
AddField
(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false))
CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false)
CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false)
CompileField
(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false)
sctx.blockArg().Identifier()
sctx.blockArg().Identifier()
sctx.blockArg().Identifier
sctx.blockArg()
sctx.blockArg
sctx
blockArg
()
Identifier
()
sctx.blockArg().type()
sctx.blockArg().type()
sctx.blockArg().type
sctx.blockArg()
sctx.blockArg
sctx
blockArg
()
type
()
frame
frame
false
false
false
false
frame.Expr.Code.InstantiateType(tb);
frame.Expr.Code.InstantiateType(tb)
frame.Expr.Code.InstantiateType
frame.Expr.Code
frame.Expr
frame
Expr
Code
InstantiateType
(tb)
tb
tb
frame.Type = null;
frame.Type = null
frame.Type
frame
Type
null
public void Compile(JuliaParser.UsingModuleContext ctx, ExprFrame frame) {
            var ids = ctx.moduleRef().Identifier();
            var str = ctx.moduleRef().GetText().Substring(5);
            frame.Module.AddName(str, true, false);
        }
void
(JuliaParser.UsingModuleContext ctx, ExprFrame frame)
JuliaParser.UsingModuleContext ctx
JuliaParser.UsingModuleContext
JuliaParser
UsingModuleContext
ExprFrame frame
ExprFrame
{
            var ids = ctx.moduleRef().Identifier();
            var str = ctx.moduleRef().GetText().Substring(5);
            frame.Module.AddName(str, true, false);
        }
var ids = ctx.moduleRef().Identifier();
var ids = ctx.moduleRef().Identifier()
var
ids = ctx.moduleRef().Identifier()
= ctx.moduleRef().Identifier()
ctx.moduleRef().Identifier()
ctx.moduleRef().Identifier
ctx.moduleRef()
ctx.moduleRef
ctx
moduleRef
()
Identifier
()
var str = ctx.moduleRef().GetText().Substring(5);
var str = ctx.moduleRef().GetText().Substring(5)
var
str = ctx.moduleRef().GetText().Substring(5)
= ctx.moduleRef().GetText().Substring(5)
ctx.moduleRef().GetText().Substring(5)
ctx.moduleRef().GetText().Substring
ctx.moduleRef().GetText()
ctx.moduleRef().GetText
ctx.moduleRef()
ctx.moduleRef
ctx
moduleRef
()
GetText
()
Substring
(5)
5
5
frame.Module.AddName(str, true, false);
frame.Module.AddName(str, true, false)
frame.Module.AddName
frame.Module
frame
Module
AddName
(str, true, false)
str
str
true
true
false
false
public object Compile(JuliaParser.FunctionCallContext ctx, ExprFrame frame) => null;
object
(JuliaParser.FunctionCallContext ctx, ExprFrame frame)
JuliaParser.FunctionCallContext ctx
JuliaParser.FunctionCallContext
JuliaParser
FunctionCallContext
ExprFrame frame
ExprFrame
=> null
null
public void Compile(JuliaParser.ModuleExprContext ctx, ExprFrame frame) {
            if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
        }
void
(JuliaParser.ModuleExprContext ctx, ExprFrame frame)
JuliaParser.ModuleExprContext ctx
JuliaParser.ModuleExprContext
JuliaParser
ModuleExprContext
ExprFrame frame
ExprFrame
{
            if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
        }
if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
ctx.usingModule() != null
ctx.usingModule()
ctx.usingModule
ctx
usingModule
()
null
Compile(ctx.usingModule(), frame);
Compile(ctx.usingModule(), frame)
Compile
(ctx.usingModule(), frame)
ctx.usingModule()
ctx.usingModule()
ctx.usingModule
ctx
usingModule
()
frame
frame
else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
ctx.module() != null
ctx.module()
ctx.module
ctx
module
()
null
Compile(ctx.module(), frame);
Compile(ctx.module(), frame)
Compile
(ctx.module(), frame)
ctx.module()
ctx.module()
ctx.module
ctx
module
()
frame
frame
else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
ctx.blockExpr() != null
ctx.blockExpr()
ctx.blockExpr
ctx
blockExpr
()
null
Compile(ctx.blockExpr(), frame);
Compile(ctx.blockExpr(), frame)
Compile
(ctx.blockExpr(), frame)
ctx.blockExpr()
ctx.blockExpr()
ctx.blockExpr
ctx
blockExpr
()
frame
frame
else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
ctx.structure() != null
ctx.structure()
ctx.structure
ctx
structure
()
null
Compile(ctx.structure(), frame);
Compile(ctx.structure(), frame)
Compile
(ctx.structure(), frame)
ctx.structure()
ctx.structure()
ctx.structure
ctx
structure
()
frame
frame
else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
ctx.moduleVariableDeclaration() != null
ctx.moduleVariableDeclaration()
ctx.moduleVariableDeclaration
ctx
moduleVariableDeclaration
()
null
{
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
var mvd = ctx.moduleVariableDeclaration();
var mvd = ctx.moduleVariableDeclaration()
var
mvd = ctx.moduleVariableDeclaration()
= ctx.moduleVariableDeclaration()
ctx.moduleVariableDeclaration()
ctx.moduleVariableDeclaration
ctx
moduleVariableDeclaration
()
CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null)
CompileField
(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null)
mvd.blockArg().Identifier()
mvd.blockArg().Identifier()
mvd.blockArg().Identifier
mvd.blockArg()
mvd.blockArg
mvd
blockArg
()
Identifier
()
mvd.blockArg().type()
mvd.blockArg().type()
mvd.blockArg().type
mvd.blockArg()
mvd.blockArg
mvd
blockArg
()
type
()
frame
frame
mvd.Const() != null
mvd.Const() != null
mvd.Const()
mvd.Const
mvd
Const
()
null
mvd.Local() == null
mvd.Local() == null
mvd.Local()
mvd.Local
mvd
Local
()
null
public JRuntimeExpr Compile(JuliaParser.ScriptContext ctx, JRuntimeModule evaluationModule) {
            JILBuilder eb = new(evaluationModule);
            ExprFrame frame = new(null, eb, eb);
            
            if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }

            return eb.CreateExpression();
        }
JRuntimeExpr
(JuliaParser.ScriptContext ctx, JRuntimeModule evaluationModule)
JuliaParser.ScriptContext ctx
JuliaParser.ScriptContext
JuliaParser
ScriptContext
JRuntimeModule evaluationModule
JRuntimeModule
{
            JILBuilder eb = new(evaluationModule);
            ExprFrame frame = new(null, eb, eb);
            
            if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }

            return eb.CreateExpression();
        }
JILBuilder eb = new(evaluationModule);
JILBuilder eb = new(evaluationModule)
JILBuilder
eb = new(evaluationModule)
= new(evaluationModule)
new(evaluationModule)
(evaluationModule)
evaluationModule
evaluationModule
ExprFrame frame = new(null, eb, eb);
ExprFrame frame = new(null, eb, eb)
ExprFrame
frame = new(null, eb, eb)
= new(null, eb, eb)
new(null, eb, eb)
(null, eb, eb)
null
null
eb
eb
eb
eb
if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }
ctx.moduleExpr() != null
ctx.moduleExpr()
ctx.moduleExpr
ctx
moduleExpr
()
null
Compile(ctx.moduleExpr(), frame);
Compile(ctx.moduleExpr(), frame)
Compile
(ctx.moduleExpr(), frame)
ctx.moduleExpr()
ctx.moduleExpr()
ctx.moduleExpr
ctx
moduleExpr
()
frame
frame
else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }
{
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }
foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
var
ctx.moduleExprStatement()
ctx.moduleExprStatement
ctx
moduleExprStatement
()
Compile(v.moduleExpr(), frame);
Compile(v.moduleExpr(), frame)
Compile
(v.moduleExpr(), frame)
v.moduleExpr()
v.moduleExpr()
v.moduleExpr
v
moduleExpr
()
frame
frame
return eb.CreateExpression();
eb.CreateExpression()
eb.CreateExpression
eb
CreateExpression
()
using System;
using System.Runtime.CompilerServices;

namespace runtime.Utils
{
    public static class EnumExtensions
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static long ConvertToInt64<T>(T value) => Unsafe.As<T, long>(ref value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static T ConvertFromInt64<T>(long value) => Unsafe.As<long, T>(ref value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Include<T>(this T value, T append) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Remove<T>(this T value, T rem) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Set<T>(this T value, T flagSet, bool v = true) where T : Enum {
            if (v) return Include(value, flagSet);
            return Remove(value, flagSet);
        }
        
        
    }
}
using System;
System
using System.Runtime.CompilerServices;
System.Runtime.CompilerServices
System.Runtime
System
Runtime
CompilerServices
namespace runtime.Utils
{
    public static class EnumExtensions
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static long ConvertToInt64<T>(T value) => Unsafe.As<T, long>(ref value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static T ConvertFromInt64<T>(long value) => Unsafe.As<long, T>(ref value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Include<T>(this T value, T append) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Remove<T>(this T value, T rem) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Set<T>(this T value, T flagSet, bool v = true) where T : Enum {
            if (v) return Include(value, flagSet);
            return Remove(value, flagSet);
        }
        
        
    }
}
runtime.Utils
runtime
Utils
public static class EnumExtensions
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static long ConvertToInt64<T>(T value) => Unsafe.As<T, long>(ref value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static T ConvertFromInt64<T>(long value) => Unsafe.As<long, T>(ref value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Include<T>(this T value, T append) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Remove<T>(this T value, T rem) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Set<T>(this T value, T flagSet, bool v = true) where T : Enum {
            if (v) return Include(value, flagSet);
            return Remove(value, flagSet);
        }
        
        
    }
[MethodImpl(MethodImplOptions.AggressiveInlining)] private static long ConvertToInt64<T>(T value) => Unsafe.As<T, long>(ref value);
[MethodImpl(MethodImplOptions.AggressiveInlining)]
MethodImpl(MethodImplOptions.AggressiveInlining)
MethodImpl
(MethodImplOptions.AggressiveInlining)
MethodImplOptions.AggressiveInlining
MethodImplOptions.AggressiveInlining
MethodImplOptions
AggressiveInlining
long
<T>
T
(T value)
T value
T
=> Unsafe.As<T, long>(ref value)
Unsafe.As<T, long>(ref value)
Unsafe.As<T, long>
Unsafe
As<T, long>
<T, long>
T
long
(ref value)
ref value
value
[MethodImpl(MethodImplOptions.AggressiveInlining)] private static T ConvertFromInt64<T>(long value) => Unsafe.As<long, T>(ref value);
[MethodImpl(MethodImplOptions.AggressiveInlining)]
MethodImpl(MethodImplOptions.AggressiveInlining)
MethodImpl
(MethodImplOptions.AggressiveInlining)
MethodImplOptions.AggressiveInlining
MethodImplOptions.AggressiveInlining
MethodImplOptions
AggressiveInlining
T
<T>
T
(long value)
long value
long
=> Unsafe.As<long, T>(ref value)
Unsafe.As<long, T>(ref value)
Unsafe.As<long, T>
Unsafe
As<long, T>
<long, T>
long
T
(ref value)
ref value
value
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Include<T>(this T value, T append) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append));
[MethodImpl(MethodImplOptions.AggressiveInlining)]
MethodImpl(MethodImplOptions.AggressiveInlining)
MethodImpl
(MethodImplOptions.AggressiveInlining)
MethodImplOptions.AggressiveInlining
MethodImplOptions.AggressiveInlining
MethodImplOptions
AggressiveInlining
T
<T>
T
(this T value, T append)
this T value
T
T append
T
where T : Enum
T
Enum
Enum
=>
            ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append))
ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append))
ConvertFromInt64<T>
<T>
T
(ConvertToInt64(value) | ConvertToInt64(append))
ConvertToInt64(value) | ConvertToInt64(append)
ConvertToInt64(value) | ConvertToInt64(append)
ConvertToInt64(value)
ConvertToInt64
(value)
value
value
ConvertToInt64(append)
ConvertToInt64
(append)
append
append
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Remove<T>(this T value, T rem) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem));
[MethodImpl(MethodImplOptions.AggressiveInlining)]
MethodImpl(MethodImplOptions.AggressiveInlining)
MethodImpl
(MethodImplOptions.AggressiveInlining)
MethodImplOptions.AggressiveInlining
MethodImplOptions.AggressiveInlining
MethodImplOptions
AggressiveInlining
T
<T>
T
(this T value, T rem)
this T value
T
T rem
T
where T : Enum
T
Enum
Enum
=>
            ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem))
ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem))
ConvertFromInt64<T>
<T>
T
(ConvertToInt64(value) & ~ConvertToInt64(rem))
ConvertToInt64(value) & ~ConvertToInt64(rem)
ConvertToInt64(value) & ~ConvertToInt64(rem)
ConvertToInt64(value)
ConvertToInt64
(value)
value
value
~ConvertToInt64(rem)
ConvertToInt64(rem)
ConvertToInt64
(rem)
rem
rem
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Set<T>(this T value, T flagSet, bool v = true) where T : Enum {
            if (v) return Include(value, flagSet);
            return Remove(value, flagSet);
        }
[MethodImpl(MethodImplOptions.AggressiveInlining)]
MethodImpl(MethodImplOptions.AggressiveInlining)
MethodImpl
(MethodImplOptions.AggressiveInlining)
MethodImplOptions.AggressiveInlining
MethodImplOptions.AggressiveInlining
MethodImplOptions
AggressiveInlining
T
<T>
T
(this T value, T flagSet, bool v = true)
this T value
T
T flagSet
T
bool v = true
bool
= true
true
where T : Enum
T
Enum
Enum
{
            if (v) return Include(value, flagSet);
            return Remove(value, flagSet);
        }
if (v) return Include(value, flagSet);
v
return Include(value, flagSet);
Include(value, flagSet)
Include
(value, flagSet)
value
value
flagSet
flagSet
return Remove(value, flagSet);
Remove(value, flagSet)
Remove
(value, flagSet)
value
value
flagSet
flagSet
using System;
using System.Collections.Generic;

namespace runtime.Utils
{
    internal struct InternElement {
        internal int hash;
        internal int idx;
    }

    internal class MInternElementEquality<T> : IEqualityComparer<InternElement> {
        private MInternContainer<T> _c;
        
        internal MInternElementEquality(MInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }

    public class MInternContainer<T> {
        internal HashSet<InternElement> S;
        public readonly List<T> Data;
        protected internal T checkItem;
        
        public MInternContainer() : this(new()){}

        public MInternContainer(List<T> v) {
            S = new(new MInternElementEquality<T>(this));
            Data = v;
        }

        public T Get(int idx) => Data[idx];
        
        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = Data[idx].GetHashCode();
            e.idx = idx;
            S.Remove(e);
            Data[idx] = v;
            e.hash = v.GetHashCode();
            S.Add(e);
        }

        public int Load(T v)
        {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = Data.Count;
            Data.Add(v);
            S.Add(e);
            return e.idx;
        }

        public int GetIndex(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            return -1;
        }
    }
    
    internal class UInternElementEquality<T> : IEqualityComparer<InternElement> where T: unmanaged{
        private UInternContainer<T> _c;
        
        internal UInternElementEquality(UInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }
    
    public class UInternContainer<T> where T: unmanaged
    {
        private readonly HashSet<InternElement> _s;
        internal readonly UnsafeList<T> _data = new();
        internal T CheckItem = default;
        
        public UInternContainer() => _s = new(new UInternElementEquality<T>(this));

        public ref T Get(int idx) => ref _data.GetRef(idx);

        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = _data[idx].GetHashCode();
            e.idx = idx;
            _s.Remove(e);
            _data[idx] = v;
            e.hash = v.GetHashCode();
            _s.Add(e);
        }
        
        public int Load(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            CheckItem = v;
            if (_s.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = _data.Count;
            _data.Add(v);
            _s.Add(e);
            return e.idx;
        }
        
    }
}
using System;
System
using System.Collections.Generic;
System.Collections.Generic
System.Collections
System
Collections
Generic
namespace runtime.Utils
{
    internal struct InternElement {
        internal int hash;
        internal int idx;
    }

    internal class MInternElementEquality<T> : IEqualityComparer<InternElement> {
        private MInternContainer<T> _c;
        
        internal MInternElementEquality(MInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }

    public class MInternContainer<T> {
        internal HashSet<InternElement> S;
        public readonly List<T> Data;
        protected internal T checkItem;
        
        public MInternContainer() : this(new()){}

        public MInternContainer(List<T> v) {
            S = new(new MInternElementEquality<T>(this));
            Data = v;
        }

        public T Get(int idx) => Data[idx];
        
        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = Data[idx].GetHashCode();
            e.idx = idx;
            S.Remove(e);
            Data[idx] = v;
            e.hash = v.GetHashCode();
            S.Add(e);
        }

        public int Load(T v)
        {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = Data.Count;
            Data.Add(v);
            S.Add(e);
            return e.idx;
        }

        public int GetIndex(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            return -1;
        }
    }
    
    internal class UInternElementEquality<T> : IEqualityComparer<InternElement> where T: unmanaged{
        private UInternContainer<T> _c;
        
        internal UInternElementEquality(UInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }
    
    public class UInternContainer<T> where T: unmanaged
    {
        private readonly HashSet<InternElement> _s;
        internal readonly UnsafeList<T> _data = new();
        internal T CheckItem = default;
        
        public UInternContainer() => _s = new(new UInternElementEquality<T>(this));

        public ref T Get(int idx) => ref _data.GetRef(idx);

        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = _data[idx].GetHashCode();
            e.idx = idx;
            _s.Remove(e);
            _data[idx] = v;
            e.hash = v.GetHashCode();
            _s.Add(e);
        }
        
        public int Load(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            CheckItem = v;
            if (_s.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = _data.Count;
            _data.Add(v);
            _s.Add(e);
            return e.idx;
        }
        
    }
}
runtime.Utils
runtime
Utils
internal struct InternElement {
        internal int hash;
        internal int idx;
    }
internal int hash;
int hash
int
hash
internal int idx;
int idx
int
idx
internal class MInternElementEquality<T> : IEqualityComparer<InternElement> {
        private MInternContainer<T> _c;
        
        internal MInternElementEquality(MInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }
<T>
T
: IEqualityComparer<InternElement>
IEqualityComparer<InternElement>
IEqualityComparer<InternElement>
<InternElement>
InternElement
private MInternContainer<T> _c;
MInternContainer<T> _c
MInternContainer<T>
<T>
T
_c
internal MInternElementEquality(MInternContainer<T> c) => _c = c;
(MInternContainer<T> c)
MInternContainer<T> c
MInternContainer<T>
<T>
T
=> _c = c
_c = c
_c
c
public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));
        }
bool
(InternElement x, InternElement y)
InternElement x
InternElement
InternElement y
InternElement
{
            return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));
        }
return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));
x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]))
x.hash == y.hash
x.hash
x
hash
y.hash
y
hash
(x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]))
x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx])
x.idx == -1
x.idx
x
idx
-1
1
_c.checkItem.Equals(_c.Data[y.idx])
_c.checkItem.Equals
_c.checkItem
_c
checkItem
Equals
(_c.Data[y.idx])
_c.Data[y.idx]
_c.Data[y.idx]
_c.Data
_c
Data
[y.idx]
y.idx
y.idx
y
idx
y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx])
y.idx == -1
y.idx
y
idx
-1
1
_c.checkItem.Equals(_c.Data[x.idx])
_c.checkItem.Equals
_c.checkItem
_c
checkItem
Equals
(_c.Data[x.idx])
_c.Data[x.idx]
_c.Data[x.idx]
_c.Data
_c
Data
[x.idx]
x.idx
x.idx
x
idx
public int GetHashCode(InternElement obj) => obj.hash;
int
(InternElement obj)
InternElement obj
InternElement
=> obj.hash
obj.hash
obj
hash
public class MInternContainer<T> {
        internal HashSet<InternElement> S;
        public readonly List<T> Data;
        protected internal T checkItem;
        
        public MInternContainer() : this(new()){}

        public MInternContainer(List<T> v) {
            S = new(new MInternElementEquality<T>(this));
            Data = v;
        }

        public T Get(int idx) => Data[idx];
        
        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = Data[idx].GetHashCode();
            e.idx = idx;
            S.Remove(e);
            Data[idx] = v;
            e.hash = v.GetHashCode();
            S.Add(e);
        }

        public int Load(T v)
        {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = Data.Count;
            Data.Add(v);
            S.Add(e);
            return e.idx;
        }

        public int GetIndex(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            return -1;
        }
    }
<T>
T
internal HashSet<InternElement> S;
HashSet<InternElement> S
HashSet<InternElement>
<InternElement>
InternElement
S
public readonly List<T> Data;
List<T> Data
List<T>
<T>
T
Data
protected internal T checkItem;
T checkItem
T
checkItem
public MInternContainer() : this(new()){}
()
: this(new())
(new())
new()
new()
()
{}
public MInternContainer(List<T> v) {
            S = new(new MInternElementEquality<T>(this));
            Data = v;
        }
(List<T> v)
List<T> v
List<T>
<T>
T
{
            S = new(new MInternElementEquality<T>(this));
            Data = v;
        }
S = new(new MInternElementEquality<T>(this));
S = new(new MInternElementEquality<T>(this))
S
new(new MInternElementEquality<T>(this))
(new MInternElementEquality<T>(this))
new MInternElementEquality<T>(this)
new MInternElementEquality<T>(this)
MInternElementEquality<T>
<T>
T
(this)
this
this
Data = v;
Data = v
Data
v
public T Get(int idx) => Data[idx];
T
(int idx)
int idx
int
=> Data[idx]
Data[idx]
Data
[idx]
idx
idx
public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = Data[idx].GetHashCode();
            e.idx = idx;
            S.Remove(e);
            Data[idx] = v;
            e.hash = v.GetHashCode();
            S.Add(e);
        }
void
(int idx, T v)
int idx
int
T v
T
{
            InternElement e = new();
            e.hash = Data[idx].GetHashCode();
            e.idx = idx;
            S.Remove(e);
            Data[idx] = v;
            e.hash = v.GetHashCode();
            S.Add(e);
        }
InternElement e = new();
InternElement e = new()
InternElement
e = new()
= new()
new()
()
e.hash = Data[idx].GetHashCode();
e.hash = Data[idx].GetHashCode()
e.hash
e
hash
Data[idx].GetHashCode()
Data[idx].GetHashCode
Data[idx]
Data
[idx]
idx
idx
GetHashCode
()
e.idx = idx;
e.idx = idx
e.idx
e
idx
idx
S.Remove(e);
S.Remove(e)
S.Remove
S
Remove
(e)
e
e
Data[idx] = v;
Data[idx] = v
Data[idx]
Data
[idx]
idx
idx
v
e.hash = v.GetHashCode();
e.hash = v.GetHashCode()
e.hash
e
hash
v.GetHashCode()
v.GetHashCode
v
GetHashCode
()
S.Add(e);
S.Add(e)
S.Add
S
Add
(e)
e
e
public int Load(T v)
        {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = Data.Count;
            Data.Add(v);
            S.Add(e);
            return e.idx;
        }
int
(T v)
T v
T
{
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = Data.Count;
            Data.Add(v);
            S.Add(e);
            return e.idx;
        }
InternElement e = new();
InternElement e = new()
InternElement
e = new()
= new()
new()
()
e.hash = v.GetHashCode();
e.hash = v.GetHashCode()
e.hash
e
hash
v.GetHashCode()
v.GetHashCode
v
GetHashCode
()
e.idx = -1;
e.idx = -1
e.idx
e
idx
-1
1
checkItem = v;
checkItem = v
checkItem
v
if (S.TryGetValue(e, out var rE))
                return rE.idx;
S.TryGetValue(e, out var rE)
S.TryGetValue
S
TryGetValue
(e, out var rE)
e
e
out var rE
var rE
var
rE
return rE.idx;
rE.idx
rE
idx
e.idx = Data.Count;
e.idx = Data.Count
e.idx
e
idx
Data.Count
Data
Count
Data.Add(v);
Data.Add(v)
Data.Add
Data
Add
(v)
v
v
S.Add(e);
S.Add(e)
S.Add
S
Add
(e)
e
e
return e.idx;
e.idx
e
idx
public int GetIndex(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            return -1;
        }
int
(T v)
T v
T
{
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            return -1;
        }
InternElement e = new();
InternElement e = new()
InternElement
e = new()
= new()
new()
()
e.hash = v.GetHashCode();
e.hash = v.GetHashCode()
e.hash
e
hash
v.GetHashCode()
v.GetHashCode
v
GetHashCode
()
e.idx = -1;
e.idx = -1
e.idx
e
idx
-1
1
checkItem = v;
checkItem = v
checkItem
v
if (S.TryGetValue(e, out var rE))
                return rE.idx;
S.TryGetValue(e, out var rE)
S.TryGetValue
S
TryGetValue
(e, out var rE)
e
e
out var rE
var rE
var
rE
return rE.idx;
rE.idx
rE
idx
return -1;
-1
1
internal class UInternElementEquality<T> : IEqualityComparer<InternElement> where T: unmanaged{
        private UInternContainer<T> _c;
        
        internal UInternElementEquality(UInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }
<T>
T
: IEqualityComparer<InternElement>
IEqualityComparer<InternElement>
IEqualityComparer<InternElement>
<InternElement>
InternElement
where T: unmanaged
T
unmanaged
unmanaged
private UInternContainer<T> _c;
UInternContainer<T> _c
UInternContainer<T>
<T>
T
_c
internal UInternElementEquality(UInternContainer<T> c) => _c = c;
(UInternContainer<T> c)
UInternContainer<T> c
UInternContainer<T>
<T>
T
=> _c = c
_c = c
_c
c
public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));
        }
bool
(InternElement x, InternElement y)
InternElement x
InternElement
InternElement y
InternElement
{
            return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));
        }
return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));
x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]))
x.hash == y.hash
x.hash
x
hash
y.hash
y
hash
(x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]))
x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx])
x.idx == -1
x.idx
x
idx
-1
1
_c.CheckItem.Equals(_c._data[y.idx])
_c.CheckItem.Equals
_c.CheckItem
_c
CheckItem
Equals
(_c._data[y.idx])
_c._data[y.idx]
_c._data[y.idx]
_c._data
_c
_data
[y.idx]
y.idx
y.idx
y
idx
y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx])
y.idx == -1
y.idx
y
idx
-1
1
_c.CheckItem.Equals(_c._data[x.idx])
_c.CheckItem.Equals
_c.CheckItem
_c
CheckItem
Equals
(_c._data[x.idx])
_c._data[x.idx]
_c._data[x.idx]
_c._data
_c
_data
[x.idx]
x.idx
x.idx
x
idx
public int GetHashCode(InternElement obj) => obj.hash;
int
(InternElement obj)
InternElement obj
InternElement
=> obj.hash
obj.hash
obj
hash
public class UInternContainer<T> where T: unmanaged
    {
        private readonly HashSet<InternElement> _s;
        internal readonly UnsafeList<T> _data = new();
        internal T CheckItem = default;
        
        public UInternContainer() => _s = new(new UInternElementEquality<T>(this));

        public ref T Get(int idx) => ref _data.GetRef(idx);

        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = _data[idx].GetHashCode();
            e.idx = idx;
            _s.Remove(e);
            _data[idx] = v;
            e.hash = v.GetHashCode();
            _s.Add(e);
        }
        
        public int Load(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            CheckItem = v;
            if (_s.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = _data.Count;
            _data.Add(v);
            _s.Add(e);
            return e.idx;
        }
        
    }
<T>
T
where T: unmanaged
T
unmanaged
unmanaged
private readonly HashSet<InternElement> _s;
HashSet<InternElement> _s
HashSet<InternElement>
<InternElement>
InternElement
_s
internal readonly UnsafeList<T> _data = new();
UnsafeList<T> _data = new()
UnsafeList<T>
<T>
T
_data = new()
= new()
new()
()
internal T CheckItem = default;
T CheckItem = default
T
CheckItem = default
= default
default
public UInternContainer() => _s = new(new UInternElementEquality<T>(this));
()
=> _s = new(new UInternElementEquality<T>(this))
_s = new(new UInternElementEquality<T>(this))
_s
new(new UInternElementEquality<T>(this))
(new UInternElementEquality<T>(this))
new UInternElementEquality<T>(this)
new UInternElementEquality<T>(this)
UInternElementEquality<T>
<T>
T
(this)
this
this
public ref T Get(int idx) => ref _data.GetRef(idx);
ref T
T
(int idx)
int idx
int
=> ref _data.GetRef(idx)
ref _data.GetRef(idx)
_data.GetRef(idx)
_data.GetRef
_data
GetRef
(idx)
idx
idx
public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = _data[idx].GetHashCode();
            e.idx = idx;
            _s.Remove(e);
            _data[idx] = v;
            e.hash = v.GetHashCode();
            _s.Add(e);
        }
void
(int idx, T v)
int idx
int
T v
T
{
            InternElement e = new();
            e.hash = _data[idx].GetHashCode();
            e.idx = idx;
            _s.Remove(e);
            _data[idx] = v;
            e.hash = v.GetHashCode();
            _s.Add(e);
        }
InternElement e = new();
InternElement e = new()
InternElement
e = new()
= new()
new()
()
e.hash = _data[idx].GetHashCode();
e.hash = _data[idx].GetHashCode()
e.hash
e
hash
_data[idx].GetHashCode()
_data[idx].GetHashCode
_data[idx]
_data
[idx]
idx
idx
GetHashCode
()
e.idx = idx;
e.idx = idx
e.idx
e
idx
idx
_s.Remove(e);
_s.Remove(e)
_s.Remove
_s
Remove
(e)
e
e
_data[idx] = v;
_data[idx] = v
_data[idx]
_data
[idx]
idx
idx
v
e.hash = v.GetHashCode();
e.hash = v.GetHashCode()
e.hash
e
hash
v.GetHashCode()
v.GetHashCode
v
GetHashCode
()
_s.Add(e);
_s.Add(e)
_s.Add
_s
Add
(e)
e
e
public int Load(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            CheckItem = v;
            if (_s.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = _data.Count;
            _data.Add(v);
            _s.Add(e);
            return e.idx;
        }
int
(T v)
T v
T
{
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            CheckItem = v;
            if (_s.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = _data.Count;
            _data.Add(v);
            _s.Add(e);
            return e.idx;
        }
InternElement e = new();
InternElement e = new()
InternElement
e = new()
= new()
new()
()
e.hash = v.GetHashCode();
e.hash = v.GetHashCode()
e.hash
e
hash
v.GetHashCode()
v.GetHashCode
v
GetHashCode
()
e.idx = -1;
e.idx = -1
e.idx
e
idx
-1
1
CheckItem = v;
CheckItem = v
CheckItem
v
if (_s.TryGetValue(e, out var rE))
                return rE.idx;
_s.TryGetValue(e, out var rE)
_s.TryGetValue
_s
TryGetValue
(e, out var rE)
e
e
out var rE
var rE
var
rE
return rE.idx;
rE.idx
rE
idx
e.idx = _data.Count;
e.idx = _data.Count
e.idx
e
idx
_data.Count
_data
Count
_data.Add(v);
_data.Add(v)
_data.Add
_data
Add
(v)
v
v
_s.Add(e);
_s.Add(e)
_s.Add
_s
Add
(e)
e
e
return e.idx;
e.idx
e
idx
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using runtime.core;

namespace runtime.Utils
{
    public unsafe class UnsafeStream
    {
        internal byte[] _items;
        internal int _size;
        internal byte* ptr;
        public int Count => _size;

        public UnsafeStream(int initCapacity = 4)
        {
            //Does not Free Handle
            _items = Array.Empty<byte>();
            _size = 0;
            Capacity = initCapacity;
        }

        public UnsafeStream(byte[] items)
        {
            _items = items;
            _size = items.Length;
        }

        public int Capacity
        {
            get => _items.Length;
            set => ptr = Resize(value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected byte* Resize(int value)
        {
            if (value < _size)
                throw new JuliaException("Index to Small!");
            if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }

            return ptr;
        }

        public T[] ReadArray<T>(int idx) where T : unmanaged
        {
            T[] v = new T[Read<int>(idx)];
            idx += sizeof(int);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
            return v;
        }

        public T* WriteArray<T>(T[] v, out int aptr) where T : unmanaged
        {
            var p = WriteArray<T>(v.Length, out aptr);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
            return p;
        }

        public T* WriteArray<T>(int size, out int aptr) where T : unmanaged
        {
            var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));
            *p++ = size;
            return (T*) p;
        }

        public int WriteList<T>(UnsafeList<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));
            return aptr;
        }

        public int WriteList<T>(List<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];
            return aptr;
        }

        public T* WritePtr<T>(int nel, out int pptr, int pad = 0) where T : unmanaged {
            pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);
            return (T*)(pptr + ptr);
        }

        public int Write<T>(ref T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        public int Write<T>(T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        protected int EnsureSizeWrite(int size)
        {
            byte[] array = _items;
            if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }

            var loc = _size;
            _size = size;
            return loc;
        }

        public byte[] ToByteArray() {
            var bytes = new byte[Count];
            fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);
            return bytes;
        }

        public byte* GetDataPointer(int idx) => ptr + idx;

        public ref T Read<T>() where T : unmanaged => ref Read<T>(_size);
        public ref T Read<T>(int idx) where T : unmanaged => ref Unsafe.AsRef<T>(ptr + idx);
        public byte* GetDataPointer() => ptr;
        public void SetCount(int p) => _size = p;
    }

   

    public class UnsafeList<T> : UnsafeStream, IList<T> where T : unmanaged
    {
        public UnsafeList() : base(sizeof(int)) => Write<int>(0);

        public IEnumerator<T> GetEnumerator() => throw new NotImplementedException();
        IEnumerator IEnumerable.GetEnumerator() => throw new NotImplementedException();

        public void Add(T item) =>  Write(item);
        public void Clear() => Capacity = 0;
        public bool Contains(T item) => throw new NotImplementedException();
        public void CopyTo(T[] array, int arrayIndex) => throw new NotImplementedException();
        public bool Remove(T item) => throw new NotImplementedException();
        public bool IsReadOnly => false;
        public int IndexOf(T item) => throw new NotImplementedException();
        public void Insert(int index, T item) => throw new NotImplementedException();
        public void RemoveAt(int index) => throw new NotImplementedException();
        public void PopLast() => Capacity--;

        public T this[int index]
        {
            get => Read<T>(index + sizeof(int));
            set => Read<T>(index + sizeof(int)) = value;
        }

        public ref T GetRef(int index) => ref Read<T>(index + sizeof(int));
    }
}
using System;
System
using System.Collections;
System.Collections
System
Collections
using System.Collections.Generic;
System.Collections.Generic
System.Collections
System
Collections
Generic
using System.Runtime.CompilerServices;
System.Runtime.CompilerServices
System.Runtime
System
Runtime
CompilerServices
using runtime.core;
runtime.core
runtime
core
namespace runtime.Utils
{
    public unsafe class UnsafeStream
    {
        internal byte[] _items;
        internal int _size;
        internal byte* ptr;
        public int Count => _size;

        public UnsafeStream(int initCapacity = 4)
        {
            //Does not Free Handle
            _items = Array.Empty<byte>();
            _size = 0;
            Capacity = initCapacity;
        }

        public UnsafeStream(byte[] items)
        {
            _items = items;
            _size = items.Length;
        }

        public int Capacity
        {
            get => _items.Length;
            set => ptr = Resize(value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected byte* Resize(int value)
        {
            if (value < _size)
                throw new JuliaException("Index to Small!");
            if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }

            return ptr;
        }

        public T[] ReadArray<T>(int idx) where T : unmanaged
        {
            T[] v = new T[Read<int>(idx)];
            idx += sizeof(int);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
            return v;
        }

        public T* WriteArray<T>(T[] v, out int aptr) where T : unmanaged
        {
            var p = WriteArray<T>(v.Length, out aptr);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
            return p;
        }

        public T* WriteArray<T>(int size, out int aptr) where T : unmanaged
        {
            var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));
            *p++ = size;
            return (T*) p;
        }

        public int WriteList<T>(UnsafeList<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));
            return aptr;
        }

        public int WriteList<T>(List<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];
            return aptr;
        }

        public T* WritePtr<T>(int nel, out int pptr, int pad = 0) where T : unmanaged {
            pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);
            return (T*)(pptr + ptr);
        }

        public int Write<T>(ref T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        public int Write<T>(T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        protected int EnsureSizeWrite(int size)
        {
            byte[] array = _items;
            if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }

            var loc = _size;
            _size = size;
            return loc;
        }

        public byte[] ToByteArray() {
            var bytes = new byte[Count];
            fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);
            return bytes;
        }

        public byte* GetDataPointer(int idx) => ptr + idx;

        public ref T Read<T>() where T : unmanaged => ref Read<T>(_size);
        public ref T Read<T>(int idx) where T : unmanaged => ref Unsafe.AsRef<T>(ptr + idx);
        public byte* GetDataPointer() => ptr;
        public void SetCount(int p) => _size = p;
    }

   

    public class UnsafeList<T> : UnsafeStream, IList<T> where T : unmanaged
    {
        public UnsafeList() : base(sizeof(int)) => Write<int>(0);

        public IEnumerator<T> GetEnumerator() => throw new NotImplementedException();
        IEnumerator IEnumerable.GetEnumerator() => throw new NotImplementedException();

        public void Add(T item) =>  Write(item);
        public void Clear() => Capacity = 0;
        public bool Contains(T item) => throw new NotImplementedException();
        public void CopyTo(T[] array, int arrayIndex) => throw new NotImplementedException();
        public bool Remove(T item) => throw new NotImplementedException();
        public bool IsReadOnly => false;
        public int IndexOf(T item) => throw new NotImplementedException();
        public void Insert(int index, T item) => throw new NotImplementedException();
        public void RemoveAt(int index) => throw new NotImplementedException();
        public void PopLast() => Capacity--;

        public T this[int index]
        {
            get => Read<T>(index + sizeof(int));
            set => Read<T>(index + sizeof(int)) = value;
        }

        public ref T GetRef(int index) => ref Read<T>(index + sizeof(int));
    }
}
runtime.Utils
runtime
Utils
public unsafe class UnsafeStream
    {
        internal byte[] _items;
        internal int _size;
        internal byte* ptr;
        public int Count => _size;

        public UnsafeStream(int initCapacity = 4)
        {
            //Does not Free Handle
            _items = Array.Empty<byte>();
            _size = 0;
            Capacity = initCapacity;
        }

        public UnsafeStream(byte[] items)
        {
            _items = items;
            _size = items.Length;
        }

        public int Capacity
        {
            get => _items.Length;
            set => ptr = Resize(value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected byte* Resize(int value)
        {
            if (value < _size)
                throw new JuliaException("Index to Small!");
            if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }

            return ptr;
        }

        public T[] ReadArray<T>(int idx) where T : unmanaged
        {
            T[] v = new T[Read<int>(idx)];
            idx += sizeof(int);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
            return v;
        }

        public T* WriteArray<T>(T[] v, out int aptr) where T : unmanaged
        {
            var p = WriteArray<T>(v.Length, out aptr);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
            return p;
        }

        public T* WriteArray<T>(int size, out int aptr) where T : unmanaged
        {
            var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));
            *p++ = size;
            return (T*) p;
        }

        public int WriteList<T>(UnsafeList<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));
            return aptr;
        }

        public int WriteList<T>(List<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];
            return aptr;
        }

        public T* WritePtr<T>(int nel, out int pptr, int pad = 0) where T : unmanaged {
            pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);
            return (T*)(pptr + ptr);
        }

        public int Write<T>(ref T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        public int Write<T>(T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        protected int EnsureSizeWrite(int size)
        {
            byte[] array = _items;
            if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }

            var loc = _size;
            _size = size;
            return loc;
        }

        public byte[] ToByteArray() {
            var bytes = new byte[Count];
            fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);
            return bytes;
        }

        public byte* GetDataPointer(int idx) => ptr + idx;

        public ref T Read<T>() where T : unmanaged => ref Read<T>(_size);
        public ref T Read<T>(int idx) where T : unmanaged => ref Unsafe.AsRef<T>(ptr + idx);
        public byte* GetDataPointer() => ptr;
        public void SetCount(int p) => _size = p;
    }
internal byte[] _items;
byte[] _items
byte[]
byte
[]

_items
internal int _size;
int _size
int
_size
internal byte* ptr;
byte* ptr
byte*
byte
ptr
public int Count => _size;
int
=> _size
_size
public UnsafeStream(int initCapacity = 4)
        {
            //Does not Free Handle
            _items = Array.Empty<byte>();
            _size = 0;
            Capacity = initCapacity;
        }
(int initCapacity = 4)
int initCapacity = 4
int
= 4
4
{
            //Does not Free Handle
            _items = Array.Empty<byte>();
            _size = 0;
            Capacity = initCapacity;
        }
_items = Array.Empty<byte>();
_items = Array.Empty<byte>()
_items
Array.Empty<byte>()
Array.Empty<byte>
Array
Empty<byte>
<byte>
byte
()
_size = 0;
_size = 0
_size
0
Capacity = initCapacity;
Capacity = initCapacity
Capacity
initCapacity
public UnsafeStream(byte[] items)
        {
            _items = items;
            _size = items.Length;
        }
(byte[] items)
byte[] items
byte[]
byte
[]

{
            _items = items;
            _size = items.Length;
        }
_items = items;
_items = items
_items
items
_size = items.Length;
_size = items.Length
_size
items.Length
items
Length
public int Capacity
        {
            get => _items.Length;
            set => ptr = Resize(value);
        }
int
{
            get => _items.Length;
            set => ptr = Resize(value);
        }
get => _items.Length;
=> _items.Length
_items.Length
_items
Length
set => ptr = Resize(value);
=> ptr = Resize(value)
ptr = Resize(value)
ptr
Resize(value)
Resize
(value)
value
value
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected byte* Resize(int value)
        {
            if (value < _size)
                throw new JuliaException("Index to Small!");
            if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }

            return ptr;
        }
[MethodImpl(MethodImplOptions.AggressiveInlining)]
MethodImpl(MethodImplOptions.AggressiveInlining)
MethodImpl
(MethodImplOptions.AggressiveInlining)
MethodImplOptions.AggressiveInlining
MethodImplOptions.AggressiveInlining
MethodImplOptions
AggressiveInlining
byte*
byte
(int value)
int value
int
{
            if (value < _size)
                throw new JuliaException("Index to Small!");
            if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }

            return ptr;
        }
if (value < _size)
                throw new JuliaException("Index to Small!");
value < _size
value
_size
throw new JuliaException("Index to Small!");
new JuliaException("Index to Small!")
JuliaException
("Index to Small!")
"Index to Small!"
"Index to Small!"
if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }
value != _items.Length
value
_items.Length
_items
Length
{
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }
if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }
value > 0
value
0
{
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }
byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true)
byte[]
byte
[]

newItems = GC.AllocateUninitializedArray<byte>(value, true)
= GC.AllocateUninitializedArray<byte>(value, true)
GC.AllocateUninitializedArray<byte>(value, true)
GC.AllocateUninitializedArray<byte>
GC
AllocateUninitializedArray<byte>
<byte>
byte
(value, true)
value
value
true
true
if (_size > 0)
                        Array.Copy(_items, newItems, _size);
_size > 0
_size
0
Array.Copy(_items, newItems, _size);
Array.Copy(_items, newItems, _size)
Array.Copy
Array
Copy
(_items, newItems, _size)
_items
_items
newItems
newItems
_size
_size
_items = newItems;
_items = newItems
_items
newItems
fixed (byte* bptr = newItems)
                        return bptr;
byte* bptr = newItems
byte*
byte
bptr = newItems
= newItems
newItems
return bptr;
bptr
_items = Array.Empty<byte>();
_items = Array.Empty<byte>()
_items
Array.Empty<byte>()
Array.Empty<byte>
Array
Empty<byte>
<byte>
byte
()
_size = 0;
_size = 0
_size
0
return null;
null
return ptr;
ptr
public T[] ReadArray<T>(int idx) where T : unmanaged
        {
            T[] v = new T[Read<int>(idx)];
            idx += sizeof(int);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
            return v;
        }
T[]
T
[]

<T>
T
(int idx)
int idx
int
where T : unmanaged
T
unmanaged
unmanaged
{
            T[] v = new T[Read<int>(idx)];
            idx += sizeof(int);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
            return v;
        }
T[] v = new T[Read<int>(idx)];
T[] v = new T[Read<int>(idx)]
T[]
T
[]

v = new T[Read<int>(idx)]
= new T[Read<int>(idx)]
new T[Read<int>(idx)]
T[Read<int>(idx)]
T
[Read<int>(idx)]
Read<int>(idx)
Read<int>
<int>
int
(idx)
idx
idx
idx += sizeof(int);
idx += sizeof(int)
idx
sizeof(int)
int
fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
T* dptr = v
T*
T
dptr = v
= v
v
Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length)
Unsafe.CopyBlock
Unsafe
CopyBlock
(dptr, (T*)(ptr + idx), (uint)v.Length)
dptr
dptr
(T*)(ptr + idx)
(T*)(ptr + idx)
T*
T
(ptr + idx)
ptr + idx
ptr
idx
(uint)v.Length
(uint)v.Length
uint
v.Length
v
Length
return v;
v
public T* WriteArray<T>(T[] v, out int aptr) where T : unmanaged
        {
            var p = WriteArray<T>(v.Length, out aptr);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
            return p;
        }
T*
T
<T>
T
(T[] v, out int aptr)
T[] v
T[]
T
[]

out int aptr
int
where T : unmanaged
T
unmanaged
unmanaged
{
            var p = WriteArray<T>(v.Length, out aptr);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
            return p;
        }
var p = WriteArray<T>(v.Length, out aptr);
var p = WriteArray<T>(v.Length, out aptr)
var
p = WriteArray<T>(v.Length, out aptr)
= WriteArray<T>(v.Length, out aptr)
WriteArray<T>(v.Length, out aptr)
WriteArray<T>
<T>
T
(v.Length, out aptr)
v.Length
v.Length
v
Length
out aptr
aptr
fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
T* dptr = v
T*
T
dptr = v
= v
v
Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length))
Unsafe.CopyBlock
Unsafe
CopyBlock
(p, dptr, (uint)(sizeof(T) * v.Length))
p
p
dptr
dptr
(uint)(sizeof(T) * v.Length)
(uint)(sizeof(T) * v.Length)
uint
(sizeof(T) * v.Length)
sizeof(T) * v.Length
sizeof(T)
T
v.Length
v
Length
return p;
p
public T* WriteArray<T>(int size, out int aptr) where T : unmanaged
        {
            var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));
            *p++ = size;
            return (T*) p;
        }
T*
T
<T>
T
(int size, out int aptr)
int size
int
out int aptr
int
where T : unmanaged
T
unmanaged
unmanaged
{
            var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));
            *p++ = size;
            return (T*) p;
        }
var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));
var p = (int*) WritePtr<T>(size, out aptr, sizeof(int))
var
p = (int*) WritePtr<T>(size, out aptr, sizeof(int))
= (int*) WritePtr<T>(size, out aptr, sizeof(int))
(int*) WritePtr<T>(size, out aptr, sizeof(int))
int*
int
WritePtr<T>(size, out aptr, sizeof(int))
WritePtr<T>
<T>
T
(size, out aptr, sizeof(int))
size
size
out aptr
aptr
sizeof(int)
sizeof(int)
int
*p++ = size;
*p++ = size
*p++
p++
p
size
return (T*) p;
(T*) p
T*
T
p
public int WriteList<T>(UnsafeList<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));
            return aptr;
        }
int
<T>
T
(UnsafeList<T> v)
UnsafeList<T> v
UnsafeList<T>
<T>
T
where T : unmanaged
T
unmanaged
unmanaged
{
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));
            return aptr;
        }
int aptr;
int aptr
int
aptr
var p = WriteArray<T>(v.Count, out aptr);
var p = WriteArray<T>(v.Count, out aptr)
var
p = WriteArray<T>(v.Count, out aptr)
= WriteArray<T>(v.Count, out aptr)
WriteArray<T>(v.Count, out aptr)
WriteArray<T>
<T>
T
(v.Count, out aptr)
v.Count
v.Count
v
Count
out aptr
aptr
Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));
Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)))
Unsafe.CopyBlock
Unsafe
CopyBlock
(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)))
p
p
v.GetDataPointer(sizeof(int))
v.GetDataPointer(sizeof(int))
v.GetDataPointer
v
GetDataPointer
(sizeof(int))
sizeof(int)
sizeof(int)
int
(uint)(v.Count * sizeof(T))
(uint)(v.Count * sizeof(T))
uint
(v.Count * sizeof(T))
v.Count * sizeof(T)
v.Count
v
Count
sizeof(T)
T
return aptr;
aptr
public int WriteList<T>(List<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];
            return aptr;
        }
int
<T>
T
(List<T> v)
List<T> v
List<T>
<T>
T
where T : unmanaged
T
unmanaged
unmanaged
{
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];
            return aptr;
        }
int aptr;
int aptr
int
aptr
var p = WriteArray<T>(v.Count, out aptr);
var p = WriteArray<T>(v.Count, out aptr)
var
p = WriteArray<T>(v.Count, out aptr)
= WriteArray<T>(v.Count, out aptr)
WriteArray<T>(v.Count, out aptr)
WriteArray<T>
<T>
T
(v.Count, out aptr)
v.Count
v.Count
v
Count
out aptr
aptr
for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];
int i = 0, n = v.Count
int
i = 0
= 0
0
n = v.Count
= v.Count
v.Count
v
Count
i < n
i
n
i++
i
p[i] = v[i];
p[i] = v[i]
p[i]
p
[i]
i
i
v[i]
v
[i]
i
i
return aptr;
aptr
public T* WritePtr<T>(int nel, out int pptr, int pad = 0) where T : unmanaged {
            pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);
            return (T*)(pptr + ptr);
        }
T*
T
<T>
T
(int nel, out int pptr, int pad = 0)
int nel
int
out int pptr
int
int pad = 0
int
= 0
0
where T : unmanaged
T
unmanaged
unmanaged
{
            pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);
            return (T*)(pptr + ptr);
        }
pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);
pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad)
pptr
EnsureSizeWrite(_size + sizeof(T) * nel + pad)
EnsureSizeWrite
(_size + sizeof(T) * nel + pad)
_size + sizeof(T) * nel + pad
_size + sizeof(T) * nel + pad
_size + sizeof(T) * nel
_size
sizeof(T) * nel
sizeof(T)
T
nel
pad
return (T*)(pptr + ptr);
(T*)(pptr + ptr)
T*
T
(pptr + ptr)
pptr + ptr
pptr
ptr
public int Write<T>(ref T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }
int
<T>
T
(ref T v)
ref T v
T
where T : unmanaged
T
unmanaged
unmanaged
{
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }
*WritePtr<T>(1, out int aptr) = v;
*WritePtr<T>(1, out int aptr) = v
*WritePtr<T>(1, out int aptr)
WritePtr<T>(1, out int aptr)
WritePtr<T>
<T>
T
(1, out int aptr)
1
1
out int aptr
int aptr
int
aptr
v
return aptr;
aptr
public int Write<T>(T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }
int
<T>
T
(T v)
T v
T
where T : unmanaged
T
unmanaged
unmanaged
{
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }
*WritePtr<T>(1, out int aptr) = v;
*WritePtr<T>(1, out int aptr) = v
*WritePtr<T>(1, out int aptr)
WritePtr<T>(1, out int aptr)
WritePtr<T>
<T>
T
(1, out int aptr)
1
1
out int aptr
int aptr
int
aptr
v
return aptr;
aptr
protected int EnsureSizeWrite(int size)
        {
            byte[] array = _items;
            if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }

            var loc = _size;
            _size = size;
            return loc;
        }
int
(int size)
int size
int
{
            byte[] array = _items;
            if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }

            var loc = _size;
            _size = size;
            return loc;
        }
byte[] array = _items;
byte[] array = _items
byte[]
byte
[]

array = _items
= _items
_items
if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }
(uint)size >= (uint)array.Length
(uint)size
uint
size
(uint)array.Length
uint
array.Length
array
Length
{
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }
int min = size + 1;
int min = size + 1
int
min = size + 1
= size + 1
size + 1
size
1
if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
_items.Length < min
_items.Length
_items
Length
min
{
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2
int
newCapacity = _items.Length == 0 ? 4 : _items.Length * 2
= _items.Length == 0 ? 4 : _items.Length * 2
_items.Length == 0 ? 4 : _items.Length * 2
_items.Length == 0
_items.Length
_items
Length
0
4
_items.Length * 2
_items.Length
_items
Length
2
if (newCapacity < min)
                        newCapacity = min;
newCapacity < min
newCapacity
min
newCapacity = min;
newCapacity = min
newCapacity
min
Capacity = newCapacity;
Capacity = newCapacity
Capacity
newCapacity
var loc = _size;
var loc = _size
var
loc = _size
= _size
_size
_size = size;
_size = size
_size
size
return loc;
loc
public byte[] ToByteArray() {
            var bytes = new byte[Count];
            fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);
            return bytes;
        }
byte[]
byte
[]

()
{
            var bytes = new byte[Count];
            fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);
            return bytes;
        }
var bytes = new byte[Count];
var bytes = new byte[Count]
var
bytes = new byte[Count]
= new byte[Count]
new byte[Count]
byte[Count]
byte
[Count]
Count
fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);
byte* dest = bytes
byte*
byte
dest = bytes
= bytes
bytes
Unsafe.CopyBlock(dest, ptr, (uint) Count);
Unsafe.CopyBlock(dest, ptr, (uint) Count)
Unsafe.CopyBlock
Unsafe
CopyBlock
(dest, ptr, (uint) Count)
dest
dest
ptr
ptr
(uint) Count
(uint) Count
uint
Count
return bytes;
bytes
public byte* GetDataPointer(int idx) => ptr + idx;
byte*
byte
(int idx)
int idx
int
=> ptr + idx
ptr + idx
ptr
idx
public ref T Read<T>() where T : unmanaged => ref Read<T>(_size);
ref T
T
<T>
T
()
where T : unmanaged
T
unmanaged
unmanaged
=> ref Read<T>(_size)
ref Read<T>(_size)
Read<T>(_size)
Read<T>
<T>
T
(_size)
_size
_size
public ref T Read<T>(int idx) where T : unmanaged => ref Unsafe.AsRef<T>(ptr + idx);
ref T
T
<T>
T
(int idx)
int idx
int
where T : unmanaged
T
unmanaged
unmanaged
=> ref Unsafe.AsRef<T>(ptr + idx)
ref Unsafe.AsRef<T>(ptr + idx)
Unsafe.AsRef<T>(ptr + idx)
Unsafe.AsRef<T>
Unsafe
AsRef<T>
<T>
T
(ptr + idx)
ptr + idx
ptr + idx
ptr
idx
public byte* GetDataPointer() => ptr;
byte*
byte
()
=> ptr
ptr
public void SetCount(int p) => _size = p;
void
(int p)
int p
int
=> _size = p
_size = p
_size
p
public class UnsafeList<T> : UnsafeStream, IList<T> where T : unmanaged
    {
        public UnsafeList() : base(sizeof(int)) => Write<int>(0);

        public IEnumerator<T> GetEnumerator() => throw new NotImplementedException();
        IEnumerator IEnumerable.GetEnumerator() => throw new NotImplementedException();

        public void Add(T item) =>  Write(item);
        public void Clear() => Capacity = 0;
        public bool Contains(T item) => throw new NotImplementedException();
        public void CopyTo(T[] array, int arrayIndex) => throw new NotImplementedException();
        public bool Remove(T item) => throw new NotImplementedException();
        public bool IsReadOnly => false;
        public int IndexOf(T item) => throw new NotImplementedException();
        public void Insert(int index, T item) => throw new NotImplementedException();
        public void RemoveAt(int index) => throw new NotImplementedException();
        public void PopLast() => Capacity--;

        public T this[int index]
        {
            get => Read<T>(index + sizeof(int));
            set => Read<T>(index + sizeof(int)) = value;
        }

        public ref T GetRef(int index) => ref Read<T>(index + sizeof(int));
    }
<T>
T
: UnsafeStream, IList<T>
UnsafeStream
UnsafeStream
IList<T>
IList<T>
<T>
T
where T : unmanaged
T
unmanaged
unmanaged
public UnsafeList() : base(sizeof(int)) => Write<int>(0);
()
: base(sizeof(int))
(sizeof(int))
sizeof(int)
sizeof(int)
int
=> Write<int>(0)
Write<int>(0)
Write<int>
<int>
int
(0)
0
0
public IEnumerator<T> GetEnumerator() => throw new NotImplementedException();
IEnumerator<T>
<T>
T
()
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
IEnumerator IEnumerable.GetEnumerator() => throw new NotImplementedException();
IEnumerator
IEnumerable.
IEnumerable
()
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public void Add(T item) =>  Write(item);
void
(T item)
T item
T
=>  Write(item)
Write(item)
Write
(item)
item
item
public void Clear() => Capacity = 0;
void
()
=> Capacity = 0
Capacity = 0
Capacity
0
public bool Contains(T item) => throw new NotImplementedException();
bool
(T item)
T item
T
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public void CopyTo(T[] array, int arrayIndex) => throw new NotImplementedException();
void
(T[] array, int arrayIndex)
T[] array
T[]
T
[]

int arrayIndex
int
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public bool Remove(T item) => throw new NotImplementedException();
bool
(T item)
T item
T
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public bool IsReadOnly => false;
bool
=> false
false
public int IndexOf(T item) => throw new NotImplementedException();
int
(T item)
T item
T
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public void Insert(int index, T item) => throw new NotImplementedException();
void
(int index, T item)
int index
int
T item
T
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public void RemoveAt(int index) => throw new NotImplementedException();
void
(int index)
int index
int
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public void PopLast() => Capacity--;
void
()
=> Capacity--
Capacity--
Capacity
public T this[int index]
        {
            get => Read<T>(index + sizeof(int));
            set => Read<T>(index + sizeof(int)) = value;
        }
T
[int index]
int index
int
{
            get => Read<T>(index + sizeof(int));
            set => Read<T>(index + sizeof(int)) = value;
        }
get => Read<T>(index + sizeof(int));
=> Read<T>(index + sizeof(int))
Read<T>(index + sizeof(int))
Read<T>
<T>
T
(index + sizeof(int))
index + sizeof(int)
index + sizeof(int)
index
sizeof(int)
int
set => Read<T>(index + sizeof(int)) = value;
=> Read<T>(index + sizeof(int)) = value
Read<T>(index + sizeof(int)) = value
Read<T>(index + sizeof(int))
Read<T>
<T>
T
(index + sizeof(int))
index + sizeof(int)
index + sizeof(int)
index
sizeof(int)
int
value
public ref T GetRef(int index) => ref Read<T>(index + sizeof(int));
ref T
T
(int index)
int index
int
=> ref Read<T>(index + sizeof(int))
ref Read<T>(index + sizeof(int))
Read<T>(index + sizeof(int))
Read<T>
<T>
T
(index + sizeof(int))
index + sizeof(int)
index + sizeof(int)
index
sizeof(int)
int
using System.IO;
using runtime.core.Runtime;

namespace runtime.core
{
    public class Julia {
        public static JRootModule MAIN = JRootModule.CreateRootModule("Main");
        public static JRootModule BASE = JRootModule.CreateRootModule("Base");

        public static JRuntimeExpr EvalToExpression(string s) => MAIN.EvalToExpression(s);
       // public static object Eval(string s) => MAIN.Eval(s);
      //  public static object Eval(FileInfo file) => MAIN.Eval(file);
    }
}
using System.IO;
System.IO
System
IO
using runtime.core.Runtime;
runtime.core.Runtime
runtime.core
runtime
core
Runtime
namespace runtime.core
{
    public class Julia {
        public static JRootModule MAIN = JRootModule.CreateRootModule("Main");
        public static JRootModule BASE = JRootModule.CreateRootModule("Base");

        public static JRuntimeExpr EvalToExpression(string s) => MAIN.EvalToExpression(s);
       // public static object Eval(string s) => MAIN.Eval(s);
      //  public static object Eval(FileInfo file) => MAIN.Eval(file);
    }
}
runtime.core
runtime
core
public class Julia {
        public static JRootModule MAIN = JRootModule.CreateRootModule("Main");
        public static JRootModule BASE = JRootModule.CreateRootModule("Base");

        public static JRuntimeExpr EvalToExpression(string s) => MAIN.EvalToExpression(s);
       // public static object Eval(string s) => MAIN.Eval(s);
      //  public static object Eval(FileInfo file) => MAIN.Eval(file);
    }
public static JRootModule MAIN = JRootModule.CreateRootModule("Main");
JRootModule MAIN = JRootModule.CreateRootModule("Main")
JRootModule
MAIN = JRootModule.CreateRootModule("Main")
= JRootModule.CreateRootModule("Main")
JRootModule.CreateRootModule("Main")
JRootModule.CreateRootModule
JRootModule
CreateRootModule
("Main")
"Main"
"Main"
public static JRootModule BASE = JRootModule.CreateRootModule("Base");
JRootModule BASE = JRootModule.CreateRootModule("Base")
JRootModule
BASE = JRootModule.CreateRootModule("Base")
= JRootModule.CreateRootModule("Base")
JRootModule.CreateRootModule("Base")
JRootModule.CreateRootModule
JRootModule
CreateRootModule
("Base")
"Base"
"Base"
public static JRuntimeExpr EvalToExpression(string s) => MAIN.EvalToExpression(s);
JRuntimeExpr
(string s)
string s
string
=> MAIN.EvalToExpression(s)
MAIN.EvalToExpression(s)
MAIN.EvalToExpression
MAIN
EvalToExpression
(s)
s
s
using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using runtime.core;

namespace runtime.ILCompiler
{
    public struct IlExprBuilder
    {
        private readonly ILGenerator _il;
        private readonly object _internalMethod;

        #region BuilderExtensions

        public struct ILFunctionExprBuilder
        {
            private readonly IlExprBuilder _eb;

            internal ILFunctionExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Invoke<T>(string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod<T>(name, parameters));

            public void Invoke(Type t, string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod(t, name, parameters));

            public void Invoke<T>(params Type[] parameters) => Invoke(SharpReflect.GetConstructor<T>(parameters));
            public void Invoke(Type t, params Type[] parameters) => Invoke(SharpReflect.GetConstructor(t, parameters));

            public void Invoke(MethodInfo info) =>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null);

            public void Invoke(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)
            {
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }

            public void Invoke(ConstructorInfo ci) => _eb._il.Emit(OpCodes.Newobj, ci);

            public void Println(string s) => _eb._il.EmitWriteLine(s);
        }

        public struct ILLoadExprBuilder
        {
            private static readonly MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle");

            private readonly IlExprBuilder _eb;
            internal ILLoadExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Arg(uint i)
            {
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }

            public void String(string str) => _eb._il.Emit(OpCodes.Ldstr, str);
            public void Bool(bool b) => _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
            public void Int64(Int64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void Int32(Int32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void Int16(Int16 v) => Int32(v);
            public void Int8(sbyte v) => Int32(v);
            public void UInt64(UInt64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void UInt32(UInt32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void UInt16(UInt16 v) => UInt32(v);
            public void UInt8(byte v) => UInt32(v);
            public void Float32(float v) => _eb._il.Emit(OpCodes.Ldc_R4, v);
            public void Float64(double v) => _eb._il.Emit(OpCodes.Ldc_R8, v);

            public void Type(System.Type t)
            {
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }

            public void FieldValue(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f);
            public void FieldValue(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb);

            public void FieldAddr(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f);
            public void FieldAddr(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb);

            public void OptFloat(double v)
            {
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }

            public void OptInt(Int64 v)
            {
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }

            public void OptUInt(UInt64 v)
            {
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }

            public void Const(UInt64 v) => OptUInt(v);
            public void Const(Int64 v) => OptInt(v);
            public void Const(double v) => OptFloat(v);
            public void Const(string s) => String(s);
            public void Const(bool b) => Bool(b);
            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Ldloc, lb);

            public void FromPointerInt8() => _eb.Emit(OpCodes.Ldind_I1);
            public void FromPointerInt16() => _eb.Emit(OpCodes.Ldind_I2);
            public void FromPointerInt32() => _eb.Emit(OpCodes.Ldind_I4);
            public void FromPointerInt64() => _eb.Emit(OpCodes.Ldind_I8);
            public void FromPointerFloat32() => _eb.Emit(OpCodes.Ldind_R4);
            public void FromPointerFloat64() => _eb.Emit(OpCodes.Ldind_R8);
            public void FromPointerRef() => _eb.Emit(OpCodes.Ldind_Ref);

            public void FromPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILStoreExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILStoreExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Field(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f);
            public void Field(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb);

            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Stloc, lb);

            public void ToPointerInt8() => _eb.Emit(OpCodes.Stind_I1);
            public void ToPointerInt16() => _eb.Emit(OpCodes.Stind_I2);
            public void ToPointerInt32() => _eb.Emit(OpCodes.Stind_I4);
            public void ToPointerInt64() => _eb.Emit(OpCodes.Stind_I8);
            public void ToPointerFloat32() => _eb.Emit(OpCodes.Stind_R4);
            public void ToPointerFloat64() => _eb.Emit(OpCodes.Stind_R8);
            public void ToPointerRef() => _eb.Emit(OpCodes.Stind_Ref);

            public void ToPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILCreateExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILCreateExprBuilder(IlExprBuilder eb) => _eb = eb;
            public LocalBuilder Local(Type t) => _eb._il.DeclareLocal(t);
            public LocalBuilder Local<T>() => Local(typeof(T));

            public LocalBuilder LocalAndStore(Type t)
            {
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }

            public LocalBuilder LocalAndStore<T>() => LocalAndStore(typeof(T));

            public void Object(ConstructorInfo ci) => _eb.Function.Invoke(ci);
            public void Object(IlExprBuilder cb) => _eb.Function.Invoke(cb, true);
            public void Object<T>(params Type[] parameters) => _eb.Function.Invoke<T>(parameters);
            public void Object(Type t, params Type[] parameters) => _eb.Function.Invoke(t, parameters);
        }

        public struct ILArrayExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILArrayExprBuilder(IlExprBuilder eb) => _eb = eb;
        }

        public struct ILUnsafeExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILUnsafeExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void StackAlloc() => _eb._il.Emit(OpCodes.Localloc);

            public void StackAlloc(Type t, int size)
            {
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }

            public void StackAlloc<T>(int size) => StackAlloc(typeof(T), size);
            public void StoreToPointer(Type t) => _eb.Store.ToPointer(t);
            public void StoreToPointer<T>() => StoreToPointer(typeof(T));
            public void LoadFromPointer(Type t) => _eb.Load.FromPointer(t);
            public void LoadFromPointer<T>() => LoadFromPointer(typeof(T));

            public void CopyBlock(int numBytes)
            {
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }

            public void CopyBlock() => _eb._il.Emit(OpCodes.Cpblk);
        }

        #endregion

        #region BuilderExtensionImpl
        public ILFunctionExprBuilder Function => new(this);
        public ILLoadExprBuilder Load => new(this);
        public ILStoreExprBuilder Store => new(this);
        public ILCreateExprBuilder Create => new(this);
        public ILArrayExprBuilder Array => new(this);
        public ILUnsafeExprBuilder Unsafe => new(this);
        
        #endregion

        private IlExprBuilder(ILGenerator il, object internalMethod) {
            _il = il;
            _internalMethod = internalMethod;
        }

        public IlExprBuilder(MethodBuilder mb) : this(mb.GetILGenerator(), mb) {}

        public IlExprBuilder(ConstructorBuilder cb) : this(cb.GetILGenerator(), cb) {}
        
        #region HelperFunctions
        public void Emit(OpCode code) => _il.Emit(code);

        public void Return() => Emit(OpCodes.Ret);
        public void Add() => Emit(OpCodes.Add);
        public void Sub() => Emit(OpCodes.Sub);
        public void Duplicate() => Emit(OpCodes.Dup);
        public void Box(Type t) => _il.Emit(OpCodes.Box, t);
        public void Box<T>() => Box(typeof(T));

        public void ReturnVoid() {
            _il.Emit(OpCodes.Nop);
            Return();
        }

        public static IlExprBuilder CreateDynamicFunction(out DynamicMethod m, string name = "<Eval>")
        {
            m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);
            return new(m.GetILGenerator(), m);
        }
        
        #endregion
    }
}
using System;
System
using System.Reflection;
System.Reflection
System
Reflection
using System.Reflection.Emit;
System.Reflection.Emit
System.Reflection
System
Reflection
Emit
using System.Runtime.InteropServices;
System.Runtime.InteropServices
System.Runtime
System
Runtime
InteropServices
using runtime.core;
runtime.core
runtime
core
namespace runtime.ILCompiler
{
    public struct IlExprBuilder
    {
        private readonly ILGenerator _il;
        private readonly object _internalMethod;

        #region BuilderExtensions

        public struct ILFunctionExprBuilder
        {
            private readonly IlExprBuilder _eb;

            internal ILFunctionExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Invoke<T>(string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod<T>(name, parameters));

            public void Invoke(Type t, string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod(t, name, parameters));

            public void Invoke<T>(params Type[] parameters) => Invoke(SharpReflect.GetConstructor<T>(parameters));
            public void Invoke(Type t, params Type[] parameters) => Invoke(SharpReflect.GetConstructor(t, parameters));

            public void Invoke(MethodInfo info) =>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null);

            public void Invoke(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)
            {
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }

            public void Invoke(ConstructorInfo ci) => _eb._il.Emit(OpCodes.Newobj, ci);

            public void Println(string s) => _eb._il.EmitWriteLine(s);
        }

        public struct ILLoadExprBuilder
        {
            private static readonly MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle");

            private readonly IlExprBuilder _eb;
            internal ILLoadExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Arg(uint i)
            {
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }

            public void String(string str) => _eb._il.Emit(OpCodes.Ldstr, str);
            public void Bool(bool b) => _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
            public void Int64(Int64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void Int32(Int32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void Int16(Int16 v) => Int32(v);
            public void Int8(sbyte v) => Int32(v);
            public void UInt64(UInt64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void UInt32(UInt32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void UInt16(UInt16 v) => UInt32(v);
            public void UInt8(byte v) => UInt32(v);
            public void Float32(float v) => _eb._il.Emit(OpCodes.Ldc_R4, v);
            public void Float64(double v) => _eb._il.Emit(OpCodes.Ldc_R8, v);

            public void Type(System.Type t)
            {
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }

            public void FieldValue(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f);
            public void FieldValue(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb);

            public void FieldAddr(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f);
            public void FieldAddr(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb);

            public void OptFloat(double v)
            {
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }

            public void OptInt(Int64 v)
            {
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }

            public void OptUInt(UInt64 v)
            {
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }

            public void Const(UInt64 v) => OptUInt(v);
            public void Const(Int64 v) => OptInt(v);
            public void Const(double v) => OptFloat(v);
            public void Const(string s) => String(s);
            public void Const(bool b) => Bool(b);
            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Ldloc, lb);

            public void FromPointerInt8() => _eb.Emit(OpCodes.Ldind_I1);
            public void FromPointerInt16() => _eb.Emit(OpCodes.Ldind_I2);
            public void FromPointerInt32() => _eb.Emit(OpCodes.Ldind_I4);
            public void FromPointerInt64() => _eb.Emit(OpCodes.Ldind_I8);
            public void FromPointerFloat32() => _eb.Emit(OpCodes.Ldind_R4);
            public void FromPointerFloat64() => _eb.Emit(OpCodes.Ldind_R8);
            public void FromPointerRef() => _eb.Emit(OpCodes.Ldind_Ref);

            public void FromPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILStoreExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILStoreExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Field(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f);
            public void Field(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb);

            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Stloc, lb);

            public void ToPointerInt8() => _eb.Emit(OpCodes.Stind_I1);
            public void ToPointerInt16() => _eb.Emit(OpCodes.Stind_I2);
            public void ToPointerInt32() => _eb.Emit(OpCodes.Stind_I4);
            public void ToPointerInt64() => _eb.Emit(OpCodes.Stind_I8);
            public void ToPointerFloat32() => _eb.Emit(OpCodes.Stind_R4);
            public void ToPointerFloat64() => _eb.Emit(OpCodes.Stind_R8);
            public void ToPointerRef() => _eb.Emit(OpCodes.Stind_Ref);

            public void ToPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILCreateExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILCreateExprBuilder(IlExprBuilder eb) => _eb = eb;
            public LocalBuilder Local(Type t) => _eb._il.DeclareLocal(t);
            public LocalBuilder Local<T>() => Local(typeof(T));

            public LocalBuilder LocalAndStore(Type t)
            {
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }

            public LocalBuilder LocalAndStore<T>() => LocalAndStore(typeof(T));

            public void Object(ConstructorInfo ci) => _eb.Function.Invoke(ci);
            public void Object(IlExprBuilder cb) => _eb.Function.Invoke(cb, true);
            public void Object<T>(params Type[] parameters) => _eb.Function.Invoke<T>(parameters);
            public void Object(Type t, params Type[] parameters) => _eb.Function.Invoke(t, parameters);
        }

        public struct ILArrayExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILArrayExprBuilder(IlExprBuilder eb) => _eb = eb;
        }

        public struct ILUnsafeExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILUnsafeExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void StackAlloc() => _eb._il.Emit(OpCodes.Localloc);

            public void StackAlloc(Type t, int size)
            {
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }

            public void StackAlloc<T>(int size) => StackAlloc(typeof(T), size);
            public void StoreToPointer(Type t) => _eb.Store.ToPointer(t);
            public void StoreToPointer<T>() => StoreToPointer(typeof(T));
            public void LoadFromPointer(Type t) => _eb.Load.FromPointer(t);
            public void LoadFromPointer<T>() => LoadFromPointer(typeof(T));

            public void CopyBlock(int numBytes)
            {
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }

            public void CopyBlock() => _eb._il.Emit(OpCodes.Cpblk);
        }

        #endregion

        #region BuilderExtensionImpl
        public ILFunctionExprBuilder Function => new(this);
        public ILLoadExprBuilder Load => new(this);
        public ILStoreExprBuilder Store => new(this);
        public ILCreateExprBuilder Create => new(this);
        public ILArrayExprBuilder Array => new(this);
        public ILUnsafeExprBuilder Unsafe => new(this);
        
        #endregion

        private IlExprBuilder(ILGenerator il, object internalMethod) {
            _il = il;
            _internalMethod = internalMethod;
        }

        public IlExprBuilder(MethodBuilder mb) : this(mb.GetILGenerator(), mb) {}

        public IlExprBuilder(ConstructorBuilder cb) : this(cb.GetILGenerator(), cb) {}
        
        #region HelperFunctions
        public void Emit(OpCode code) => _il.Emit(code);

        public void Return() => Emit(OpCodes.Ret);
        public void Add() => Emit(OpCodes.Add);
        public void Sub() => Emit(OpCodes.Sub);
        public void Duplicate() => Emit(OpCodes.Dup);
        public void Box(Type t) => _il.Emit(OpCodes.Box, t);
        public void Box<T>() => Box(typeof(T));

        public void ReturnVoid() {
            _il.Emit(OpCodes.Nop);
            Return();
        }

        public static IlExprBuilder CreateDynamicFunction(out DynamicMethod m, string name = "<Eval>")
        {
            m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);
            return new(m.GetILGenerator(), m);
        }
        
        #endregion
    }
}
runtime.ILCompiler
runtime
ILCompiler
public struct IlExprBuilder
    {
        private readonly ILGenerator _il;
        private readonly object _internalMethod;

        #region BuilderExtensions

        public struct ILFunctionExprBuilder
        {
            private readonly IlExprBuilder _eb;

            internal ILFunctionExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Invoke<T>(string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod<T>(name, parameters));

            public void Invoke(Type t, string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod(t, name, parameters));

            public void Invoke<T>(params Type[] parameters) => Invoke(SharpReflect.GetConstructor<T>(parameters));
            public void Invoke(Type t, params Type[] parameters) => Invoke(SharpReflect.GetConstructor(t, parameters));

            public void Invoke(MethodInfo info) =>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null);

            public void Invoke(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)
            {
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }

            public void Invoke(ConstructorInfo ci) => _eb._il.Emit(OpCodes.Newobj, ci);

            public void Println(string s) => _eb._il.EmitWriteLine(s);
        }

        public struct ILLoadExprBuilder
        {
            private static readonly MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle");

            private readonly IlExprBuilder _eb;
            internal ILLoadExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Arg(uint i)
            {
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }

            public void String(string str) => _eb._il.Emit(OpCodes.Ldstr, str);
            public void Bool(bool b) => _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
            public void Int64(Int64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void Int32(Int32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void Int16(Int16 v) => Int32(v);
            public void Int8(sbyte v) => Int32(v);
            public void UInt64(UInt64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void UInt32(UInt32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void UInt16(UInt16 v) => UInt32(v);
            public void UInt8(byte v) => UInt32(v);
            public void Float32(float v) => _eb._il.Emit(OpCodes.Ldc_R4, v);
            public void Float64(double v) => _eb._il.Emit(OpCodes.Ldc_R8, v);

            public void Type(System.Type t)
            {
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }

            public void FieldValue(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f);
            public void FieldValue(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb);

            public void FieldAddr(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f);
            public void FieldAddr(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb);

            public void OptFloat(double v)
            {
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }

            public void OptInt(Int64 v)
            {
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }

            public void OptUInt(UInt64 v)
            {
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }

            public void Const(UInt64 v) => OptUInt(v);
            public void Const(Int64 v) => OptInt(v);
            public void Const(double v) => OptFloat(v);
            public void Const(string s) => String(s);
            public void Const(bool b) => Bool(b);
            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Ldloc, lb);

            public void FromPointerInt8() => _eb.Emit(OpCodes.Ldind_I1);
            public void FromPointerInt16() => _eb.Emit(OpCodes.Ldind_I2);
            public void FromPointerInt32() => _eb.Emit(OpCodes.Ldind_I4);
            public void FromPointerInt64() => _eb.Emit(OpCodes.Ldind_I8);
            public void FromPointerFloat32() => _eb.Emit(OpCodes.Ldind_R4);
            public void FromPointerFloat64() => _eb.Emit(OpCodes.Ldind_R8);
            public void FromPointerRef() => _eb.Emit(OpCodes.Ldind_Ref);

            public void FromPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILStoreExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILStoreExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Field(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f);
            public void Field(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb);

            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Stloc, lb);

            public void ToPointerInt8() => _eb.Emit(OpCodes.Stind_I1);
            public void ToPointerInt16() => _eb.Emit(OpCodes.Stind_I2);
            public void ToPointerInt32() => _eb.Emit(OpCodes.Stind_I4);
            public void ToPointerInt64() => _eb.Emit(OpCodes.Stind_I8);
            public void ToPointerFloat32() => _eb.Emit(OpCodes.Stind_R4);
            public void ToPointerFloat64() => _eb.Emit(OpCodes.Stind_R8);
            public void ToPointerRef() => _eb.Emit(OpCodes.Stind_Ref);

            public void ToPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILCreateExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILCreateExprBuilder(IlExprBuilder eb) => _eb = eb;
            public LocalBuilder Local(Type t) => _eb._il.DeclareLocal(t);
            public LocalBuilder Local<T>() => Local(typeof(T));

            public LocalBuilder LocalAndStore(Type t)
            {
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }

            public LocalBuilder LocalAndStore<T>() => LocalAndStore(typeof(T));

            public void Object(ConstructorInfo ci) => _eb.Function.Invoke(ci);
            public void Object(IlExprBuilder cb) => _eb.Function.Invoke(cb, true);
            public void Object<T>(params Type[] parameters) => _eb.Function.Invoke<T>(parameters);
            public void Object(Type t, params Type[] parameters) => _eb.Function.Invoke(t, parameters);
        }

        public struct ILArrayExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILArrayExprBuilder(IlExprBuilder eb) => _eb = eb;
        }

        public struct ILUnsafeExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILUnsafeExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void StackAlloc() => _eb._il.Emit(OpCodes.Localloc);

            public void StackAlloc(Type t, int size)
            {
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }

            public void StackAlloc<T>(int size) => StackAlloc(typeof(T), size);
            public void StoreToPointer(Type t) => _eb.Store.ToPointer(t);
            public void StoreToPointer<T>() => StoreToPointer(typeof(T));
            public void LoadFromPointer(Type t) => _eb.Load.FromPointer(t);
            public void LoadFromPointer<T>() => LoadFromPointer(typeof(T));

            public void CopyBlock(int numBytes)
            {
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }

            public void CopyBlock() => _eb._il.Emit(OpCodes.Cpblk);
        }

        #endregion

        #region BuilderExtensionImpl
        public ILFunctionExprBuilder Function => new(this);
        public ILLoadExprBuilder Load => new(this);
        public ILStoreExprBuilder Store => new(this);
        public ILCreateExprBuilder Create => new(this);
        public ILArrayExprBuilder Array => new(this);
        public ILUnsafeExprBuilder Unsafe => new(this);
        
        #endregion

        private IlExprBuilder(ILGenerator il, object internalMethod) {
            _il = il;
            _internalMethod = internalMethod;
        }

        public IlExprBuilder(MethodBuilder mb) : this(mb.GetILGenerator(), mb) {}

        public IlExprBuilder(ConstructorBuilder cb) : this(cb.GetILGenerator(), cb) {}
        
        #region HelperFunctions
        public void Emit(OpCode code) => _il.Emit(code);

        public void Return() => Emit(OpCodes.Ret);
        public void Add() => Emit(OpCodes.Add);
        public void Sub() => Emit(OpCodes.Sub);
        public void Duplicate() => Emit(OpCodes.Dup);
        public void Box(Type t) => _il.Emit(OpCodes.Box, t);
        public void Box<T>() => Box(typeof(T));

        public void ReturnVoid() {
            _il.Emit(OpCodes.Nop);
            Return();
        }

        public static IlExprBuilder CreateDynamicFunction(out DynamicMethod m, string name = "<Eval>")
        {
            m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);
            return new(m.GetILGenerator(), m);
        }
        
        #endregion
    }
private readonly ILGenerator _il;
ILGenerator _il
ILGenerator
_il
private readonly object _internalMethod;
object _internalMethod
object
_internalMethod
public struct ILFunctionExprBuilder
        {
            private readonly IlExprBuilder _eb;

            internal ILFunctionExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Invoke<T>(string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod<T>(name, parameters));

            public void Invoke(Type t, string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod(t, name, parameters));

            public void Invoke<T>(params Type[] parameters) => Invoke(SharpReflect.GetConstructor<T>(parameters));
            public void Invoke(Type t, params Type[] parameters) => Invoke(SharpReflect.GetConstructor(t, parameters));

            public void Invoke(MethodInfo info) =>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null);

            public void Invoke(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)
            {
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }

            public void Invoke(ConstructorInfo ci) => _eb._il.Emit(OpCodes.Newobj, ci);

            public void Println(string s) => _eb._il.EmitWriteLine(s);
        }
private readonly IlExprBuilder _eb;
IlExprBuilder _eb
IlExprBuilder
_eb
internal ILFunctionExprBuilder(IlExprBuilder eb) => _eb = eb;
(IlExprBuilder eb)
IlExprBuilder eb
IlExprBuilder
=> _eb = eb
_eb = eb
_eb
eb
public void Invoke<T>(string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod<T>(name, parameters));
void
<T>
T
(string name, params Type[] parameters)
string name
string
params Type[] parameters
Type[]
Type
[]

=>
                Invoke(SharpReflect.GetMethod<T>(name, parameters))
Invoke(SharpReflect.GetMethod<T>(name, parameters))
Invoke
(SharpReflect.GetMethod<T>(name, parameters))
SharpReflect.GetMethod<T>(name, parameters)
SharpReflect.GetMethod<T>(name, parameters)
SharpReflect.GetMethod<T>
SharpReflect
GetMethod<T>
<T>
T
(name, parameters)
name
name
parameters
parameters
public void Invoke(Type t, string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod(t, name, parameters));
void
(Type t, string name, params Type[] parameters)
Type t
Type
string name
string
params Type[] parameters
Type[]
Type
[]

=>
                Invoke(SharpReflect.GetMethod(t, name, parameters))
Invoke(SharpReflect.GetMethod(t, name, parameters))
Invoke
(SharpReflect.GetMethod(t, name, parameters))
SharpReflect.GetMethod(t, name, parameters)
SharpReflect.GetMethod(t, name, parameters)
SharpReflect.GetMethod
SharpReflect
GetMethod
(t, name, parameters)
t
t
name
name
parameters
parameters
public void Invoke<T>(params Type[] parameters) => Invoke(SharpReflect.GetConstructor<T>(parameters));
void
<T>
T
(params Type[] parameters)
params Type[] parameters
Type[]
Type
[]

=> Invoke(SharpReflect.GetConstructor<T>(parameters))
Invoke(SharpReflect.GetConstructor<T>(parameters))
Invoke
(SharpReflect.GetConstructor<T>(parameters))
SharpReflect.GetConstructor<T>(parameters)
SharpReflect.GetConstructor<T>(parameters)
SharpReflect.GetConstructor<T>
SharpReflect
GetConstructor<T>
<T>
T
(parameters)
parameters
parameters
public void Invoke(Type t, params Type[] parameters) => Invoke(SharpReflect.GetConstructor(t, parameters));
void
(Type t, params Type[] parameters)
Type t
Type
params Type[] parameters
Type[]
Type
[]

=> Invoke(SharpReflect.GetConstructor(t, parameters))
Invoke(SharpReflect.GetConstructor(t, parameters))
Invoke
(SharpReflect.GetConstructor(t, parameters))
SharpReflect.GetConstructor(t, parameters)
SharpReflect.GetConstructor(t, parameters)
SharpReflect.GetConstructor
SharpReflect
GetConstructor
(t, parameters)
t
t
parameters
parameters
public void Invoke(MethodInfo info) =>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null);
void
(MethodInfo info)
MethodInfo info
MethodInfo
=>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null)
_eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null)
_eb._il.EmitCall
_eb._il
_eb
_il
EmitCall
(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null)
info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call
info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call
info.IsVirtual
info
IsVirtual
OpCodes.Callvirt
OpCodes
Callvirt
OpCodes.Call
OpCodes
Call
info
info
null
null
public void Invoke(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)
            {
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }
void
(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)
IlExprBuilder fb
IlExprBuilder
bool requiresConstructor = false
bool
= false
false
bool requiresMethod = false
bool
= false
false
{
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }
if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
fb._internalMethod is MethodBuilder mb && !requiresConstructor
fb._internalMethod is MethodBuilder mb
fb._internalMethod
fb
_internalMethod
MethodBuilder mb
MethodBuilder
mb
!requiresConstructor
requiresConstructor
Invoke(mb);
Invoke(mb)
Invoke
(mb)
mb
mb
else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
fb._internalMethod is ConstructorBuilder cb && !requiresMethod
fb._internalMethod is ConstructorBuilder cb
fb._internalMethod
fb
_internalMethod
ConstructorBuilder cb
ConstructorBuilder
cb
!requiresMethod
requiresMethod
Invoke(cb);
Invoke(cb)
Invoke
(cb)
cb
cb
else throw new Exception("Unable To Invoke Unknown Internal Method!");
throw new Exception("Unable To Invoke Unknown Internal Method!");
new Exception("Unable To Invoke Unknown Internal Method!")
Exception
("Unable To Invoke Unknown Internal Method!")
"Unable To Invoke Unknown Internal Method!"
"Unable To Invoke Unknown Internal Method!"
public void Invoke(ConstructorInfo ci) => _eb._il.Emit(OpCodes.Newobj, ci);
void
(ConstructorInfo ci)
ConstructorInfo ci
ConstructorInfo
=> _eb._il.Emit(OpCodes.Newobj, ci)
_eb._il.Emit(OpCodes.Newobj, ci)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Newobj, ci)
OpCodes.Newobj
OpCodes.Newobj
OpCodes
Newobj
ci
ci
public void Println(string s) => _eb._il.EmitWriteLine(s);
void
(string s)
string s
string
=> _eb._il.EmitWriteLine(s)
_eb._il.EmitWriteLine(s)
_eb._il.EmitWriteLine
_eb._il
_eb
_il
EmitWriteLine
(s)
s
s
public struct ILLoadExprBuilder
        {
            private static readonly MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle");

            private readonly IlExprBuilder _eb;
            internal ILLoadExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Arg(uint i)
            {
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }

            public void String(string str) => _eb._il.Emit(OpCodes.Ldstr, str);
            public void Bool(bool b) => _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
            public void Int64(Int64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void Int32(Int32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void Int16(Int16 v) => Int32(v);
            public void Int8(sbyte v) => Int32(v);
            public void UInt64(UInt64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void UInt32(UInt32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void UInt16(UInt16 v) => UInt32(v);
            public void UInt8(byte v) => UInt32(v);
            public void Float32(float v) => _eb._il.Emit(OpCodes.Ldc_R4, v);
            public void Float64(double v) => _eb._il.Emit(OpCodes.Ldc_R8, v);

            public void Type(System.Type t)
            {
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }

            public void FieldValue(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f);
            public void FieldValue(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb);

            public void FieldAddr(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f);
            public void FieldAddr(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb);

            public void OptFloat(double v)
            {
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }

            public void OptInt(Int64 v)
            {
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }

            public void OptUInt(UInt64 v)
            {
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }

            public void Const(UInt64 v) => OptUInt(v);
            public void Const(Int64 v) => OptInt(v);
            public void Const(double v) => OptFloat(v);
            public void Const(string s) => String(s);
            public void Const(bool b) => Bool(b);
            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Ldloc, lb);

            public void FromPointerInt8() => _eb.Emit(OpCodes.Ldind_I1);
            public void FromPointerInt16() => _eb.Emit(OpCodes.Ldind_I2);
            public void FromPointerInt32() => _eb.Emit(OpCodes.Ldind_I4);
            public void FromPointerInt64() => _eb.Emit(OpCodes.Ldind_I8);
            public void FromPointerFloat32() => _eb.Emit(OpCodes.Ldind_R4);
            public void FromPointerFloat64() => _eb.Emit(OpCodes.Ldind_R8);
            public void FromPointerRef() => _eb.Emit(OpCodes.Ldind_Ref);

            public void FromPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }
private static readonly MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle");
MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle")
MethodInfo
GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle")
= SharpReflect.GetMethod<Type>("GetTypeFromHandle")
SharpReflect.GetMethod<Type>("GetTypeFromHandle")
SharpReflect.GetMethod<Type>
SharpReflect
GetMethod<Type>
<Type>
Type
("GetTypeFromHandle")
"GetTypeFromHandle"
"GetTypeFromHandle"
private readonly IlExprBuilder _eb;
IlExprBuilder _eb
IlExprBuilder
_eb
internal ILLoadExprBuilder(IlExprBuilder eb) => _eb = eb;
(IlExprBuilder eb)
IlExprBuilder eb
IlExprBuilder
=> _eb = eb
_eb = eb
_eb
eb
public void Arg(uint i)
            {
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }
void
(uint i)
uint i
uint
{
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }
if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
i < 4
i
4
{
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
i == 0
i
0
_eb.Emit(OpCodes.Ldarg_0);
_eb.Emit(OpCodes.Ldarg_0)
_eb.Emit
_eb
Emit
(OpCodes.Ldarg_0)
OpCodes.Ldarg_0
OpCodes.Ldarg_0
OpCodes
Ldarg_0
else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
i == 1
i
1
_eb.Emit(OpCodes.Ldarg_1);
_eb.Emit(OpCodes.Ldarg_1)
_eb.Emit
_eb
Emit
(OpCodes.Ldarg_1)
OpCodes.Ldarg_1
OpCodes.Ldarg_1
OpCodes
Ldarg_1
else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
i == 2
i
2
_eb.Emit(OpCodes.Ldarg_2);
_eb.Emit(OpCodes.Ldarg_2)
_eb.Emit
_eb
Emit
(OpCodes.Ldarg_2)
OpCodes.Ldarg_2
OpCodes.Ldarg_2
OpCodes
Ldarg_2
else _eb.Emit(OpCodes.Ldarg_3);
_eb.Emit(OpCodes.Ldarg_3);
_eb.Emit(OpCodes.Ldarg_3)
_eb.Emit
_eb
Emit
(OpCodes.Ldarg_3)
OpCodes.Ldarg_3
OpCodes.Ldarg_3
OpCodes
Ldarg_3
else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
i < 255
i
255
_eb._il.Emit(OpCodes.Ldarg_S, i);
_eb._il.Emit(OpCodes.Ldarg_S, i)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Ldarg_S, i)
OpCodes.Ldarg_S
OpCodes.Ldarg_S
OpCodes
Ldarg_S
i
i
else
                    _eb._il.Emit(OpCodes.Ldarg, i);
_eb._il.Emit(OpCodes.Ldarg, i);
_eb._il.Emit(OpCodes.Ldarg, i)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Ldarg, i)
OpCodes.Ldarg
OpCodes.Ldarg
OpCodes
Ldarg
i
i
public void String(string str) => _eb._il.Emit(OpCodes.Ldstr, str);
void
(string str)
string str
string
=> _eb._il.Emit(OpCodes.Ldstr, str)
_eb._il.Emit(OpCodes.Ldstr, str)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Ldstr, str)
OpCodes.Ldstr
OpCodes.Ldstr
OpCodes
Ldstr
str
str
public void Bool(bool b) => _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
void
(bool b)
bool b
bool
=> _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0)
_eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0)
b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0
b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0
b
OpCodes.Ldc_I4_1
OpCodes
Ldc_I4_1
OpCodes.Ldc_I4_0
OpCodes
Ldc_I4_0
public void Int64(Int64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
void
(Int64 v)
Int64 v
Int64
=> _eb._il.Emit(OpCodes.Ldc_I8, v)
_eb._il.Emit(OpCodes.Ldc_I8, v)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Ldc_I8, v)
OpCodes.Ldc_I8
OpCodes.Ldc_I8
OpCodes
Ldc_I8
v
v
public void Int32(Int32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
void
(Int32 v)
Int32 v
Int32
=> _eb._il.Emit(OpCodes.Ldc_I4, v)
_eb._il.Emit(OpCodes.Ldc_I4, v)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Ldc_I4, v)
OpCodes.Ldc_I4
OpCodes.Ldc_I4
OpCodes
Ldc_I4
v
v
public void Int16(Int16 v) => Int32(v);
void
(Int16 v)
Int16 v
Int16
=> Int32(v)
Int32(v)
Int32
(v)
v
v
public void Int8(sbyte v) => Int32(v);
void
(sbyte v)
sbyte v
sbyte
=> Int32(v)
Int32(v)
Int32
(v)
v
v
public void UInt64(UInt64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
void
(UInt64 v)
UInt64 v
UInt64
=> _eb._il.Emit(OpCodes.Ldc_I8, v)
_eb._il.Emit(OpCodes.Ldc_I8, v)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Ldc_I8, v)
OpCodes.Ldc_I8
OpCodes.Ldc_I8
OpCodes
Ldc_I8
v
v
public void UInt32(UInt32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
void
(UInt32 v)
UInt32 v
UInt32
=> _eb._il.Emit(OpCodes.Ldc_I4, v)
_eb._il.Emit(OpCodes.Ldc_I4, v)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Ldc_I4, v)
OpCodes.Ldc_I4
OpCodes.Ldc_I4
OpCodes
Ldc_I4
v
v
public void UInt16(UInt16 v) => UInt32(v);
void
(UInt16 v)
UInt16 v
UInt16
=> UInt32(v)
UInt32(v)
UInt32
(v)
v
v
public void UInt8(byte v) => UInt32(v);
void
(byte v)
byte v
byte
=> UInt32(v)
UInt32(v)
UInt32
(v)
v
v
public void Float32(float v) => _eb._il.Emit(OpCodes.Ldc_R4, v);
void
(float v)
float v
float
=> _eb._il.Emit(OpCodes.Ldc_R4, v)
_eb._il.Emit(OpCodes.Ldc_R4, v)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Ldc_R4, v)
OpCodes.Ldc_R4
OpCodes.Ldc_R4
OpCodes
Ldc_R4
v
v
public void Float64(double v) => _eb._il.Emit(OpCodes.Ldc_R8, v);
void
(double v)
double v
double
=> _eb._il.Emit(OpCodes.Ldc_R8, v)
_eb._il.Emit(OpCodes.Ldc_R8, v)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Ldc_R8, v)
OpCodes.Ldc_R8
OpCodes.Ldc_R8
OpCodes
Ldc_R8
v
v
public void Type(System.Type t)
            {
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }
void
(System.Type t)
System.Type t
System.Type
System
Type
{
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }
_eb._il.Emit(OpCodes.Ldtoken, t);
_eb._il.Emit(OpCodes.Ldtoken, t)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Ldtoken, t)
OpCodes.Ldtoken
OpCodes.Ldtoken
OpCodes
Ldtoken
t
t
_eb.Function.Invoke(GET_RUNTIME_TYPE);
_eb.Function.Invoke(GET_RUNTIME_TYPE)
_eb.Function.Invoke
_eb.Function
_eb
Function
Invoke
(GET_RUNTIME_TYPE)
GET_RUNTIME_TYPE
GET_RUNTIME_TYPE
public void FieldValue(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f);
void
(FieldInfo f)
FieldInfo f
FieldInfo
=> _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f)
_eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f)
f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld
f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld
f.IsStatic
f
IsStatic
OpCodes.Ldsfld
OpCodes
Ldsfld
OpCodes.Ldfld
OpCodes
Ldfld
f
f
public void FieldValue(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb);
void
(FieldBuilder fb)
FieldBuilder fb
FieldBuilder
=> _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb)
_eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb)
fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld
fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld
fb.IsStatic
fb
IsStatic
OpCodes.Ldsfld
OpCodes
Ldsfld
OpCodes.Ldfld
OpCodes
Ldfld
fb
fb
public void FieldAddr(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f);
void
(FieldInfo f)
FieldInfo f
FieldInfo
=> _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f)
_eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f)
f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld
f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld
f.IsStatic
f
IsStatic
OpCodes.Ldsflda
OpCodes
Ldsflda
OpCodes.Ldsfld
OpCodes
Ldsfld
f
f
public void FieldAddr(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb);
void
(FieldBuilder fb)
FieldBuilder fb
FieldBuilder
=> _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb)
_eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb)
fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld
fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld
fb.IsStatic
fb
IsStatic
OpCodes.Ldsflda
OpCodes
Ldsflda
OpCodes.Ldsfld
OpCodes
Ldsfld
fb
fb
public void OptFloat(double v)
            {
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }
void
(double v)
double v
double
{
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }
if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
v > float.MaxValue
v
float.MaxValue
float
MaxValue
Float32((float)v);
Float32((float)v)
Float32
((float)v)
(float)v
(float)v
float
v
else
                    Float64(v);
Float64(v);
Float64(v)
Float64
(v)
v
v
public void OptInt(Int64 v)
            {
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }
void
(Int64 v)
Int64 v
Int64
{
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }
bool less = v < 0;
bool less = v < 0
bool
less = v < 0
= v < 0
v < 0
v
0
if (less) v *= -1;
less
v *= -1;
v *= -1
v
-1
1
if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
v < System.Int32.MaxValue
v
System.Int32.MaxValue
System.Int32
System
Int32
MaxValue
Int32((Int32)v * (less ? -1 : 1));
Int32((Int32)v * (less ? -1 : 1))
Int32
((Int32)v * (less ? -1 : 1))
(Int32)v * (less ? -1 : 1)
(Int32)v * (less ? -1 : 1)
(Int32)v
Int32
v
(less ? -1 : 1)
less ? -1 : 1
less
-1
1
1
else
                    Int64(v * (less ? -1 : 1));
Int64(v * (less ? -1 : 1));
Int64(v * (less ? -1 : 1))
Int64
(v * (less ? -1 : 1))
v * (less ? -1 : 1)
v * (less ? -1 : 1)
v
(less ? -1 : 1)
less ? -1 : 1
less
-1
1
1
public void OptUInt(UInt64 v)
            {
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }
void
(UInt64 v)
UInt64 v
UInt64
{
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }
if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
v < System.Int32.MaxValue
v
System.Int32.MaxValue
System.Int32
System
Int32
MaxValue
UInt32((UInt32)v);
UInt32((UInt32)v)
UInt32
((UInt32)v)
(UInt32)v
(UInt32)v
UInt32
v
else
                    UInt64(v);
UInt64(v);
UInt64(v)
UInt64
(v)
v
v
public void Const(UInt64 v) => OptUInt(v);
void
(UInt64 v)
UInt64 v
UInt64
=> OptUInt(v)
OptUInt(v)
OptUInt
(v)
v
v
public void Const(Int64 v) => OptInt(v);
void
(Int64 v)
Int64 v
Int64
=> OptInt(v)
OptInt(v)
OptInt
(v)
v
v
public void Const(double v) => OptFloat(v);
void
(double v)
double v
double
=> OptFloat(v)
OptFloat(v)
OptFloat
(v)
v
v
public void Const(string s) => String(s);
void
(string s)
string s
string
=> String(s)
String(s)
String
(s)
s
s
public void Const(bool b) => Bool(b);
void
(bool b)
bool b
bool
=> Bool(b)
Bool(b)
Bool
(b)
b
b
public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Ldloc, lb);
void
(LocalBuilder lb)
LocalBuilder lb
LocalBuilder
=> _eb._il.Emit(OpCodes.Ldloc, lb)
_eb._il.Emit(OpCodes.Ldloc, lb)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Ldloc, lb)
OpCodes.Ldloc
OpCodes.Ldloc
OpCodes
Ldloc
lb
lb
public void FromPointerInt8() => _eb.Emit(OpCodes.Ldind_I1);
void
()
=> _eb.Emit(OpCodes.Ldind_I1)
_eb.Emit(OpCodes.Ldind_I1)
_eb.Emit
_eb
Emit
(OpCodes.Ldind_I1)
OpCodes.Ldind_I1
OpCodes.Ldind_I1
OpCodes
Ldind_I1
public void FromPointerInt16() => _eb.Emit(OpCodes.Ldind_I2);
void
()
=> _eb.Emit(OpCodes.Ldind_I2)
_eb.Emit(OpCodes.Ldind_I2)
_eb.Emit
_eb
Emit
(OpCodes.Ldind_I2)
OpCodes.Ldind_I2
OpCodes.Ldind_I2
OpCodes
Ldind_I2
public void FromPointerInt32() => _eb.Emit(OpCodes.Ldind_I4);
void
()
=> _eb.Emit(OpCodes.Ldind_I4)
_eb.Emit(OpCodes.Ldind_I4)
_eb.Emit
_eb
Emit
(OpCodes.Ldind_I4)
OpCodes.Ldind_I4
OpCodes.Ldind_I4
OpCodes
Ldind_I4
public void FromPointerInt64() => _eb.Emit(OpCodes.Ldind_I8);
void
()
=> _eb.Emit(OpCodes.Ldind_I8)
_eb.Emit(OpCodes.Ldind_I8)
_eb.Emit
_eb
Emit
(OpCodes.Ldind_I8)
OpCodes.Ldind_I8
OpCodes.Ldind_I8
OpCodes
Ldind_I8
public void FromPointerFloat32() => _eb.Emit(OpCodes.Ldind_R4);
void
()
=> _eb.Emit(OpCodes.Ldind_R4)
_eb.Emit(OpCodes.Ldind_R4)
_eb.Emit
_eb
Emit
(OpCodes.Ldind_R4)
OpCodes.Ldind_R4
OpCodes.Ldind_R4
OpCodes
Ldind_R4
public void FromPointerFloat64() => _eb.Emit(OpCodes.Ldind_R8);
void
()
=> _eb.Emit(OpCodes.Ldind_R8)
_eb.Emit(OpCodes.Ldind_R8)
_eb.Emit
_eb
Emit
(OpCodes.Ldind_R8)
OpCodes.Ldind_R8
OpCodes.Ldind_R8
OpCodes
Ldind_R8
public void FromPointerRef() => _eb.Emit(OpCodes.Ldind_Ref);
void
()
=> _eb.Emit(OpCodes.Ldind_Ref)
_eb.Emit(OpCodes.Ldind_Ref)
_eb.Emit
_eb
Emit
(OpCodes.Ldind_Ref)
OpCodes.Ldind_Ref
OpCodes.Ldind_Ref
OpCodes
Ldind_Ref
public void FromPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
void
(Type t)
Type t
Type
{
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
t.IsPrimitive
t
IsPrimitive
{
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(byte) || t == typeof(sbyte)
t == typeof(byte)
t
typeof(byte)
byte
t == typeof(sbyte)
t
typeof(sbyte)
sbyte
FromPointerInt8();
FromPointerInt8()
FromPointerInt8
()
else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(Int16) || t == typeof(UInt16)
t == typeof(Int16)
t
typeof(Int16)
Int16
t == typeof(UInt16)
t
typeof(UInt16)
UInt16
FromPointerInt16();
FromPointerInt16()
FromPointerInt16
()
else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(Int32) || t == typeof(UInt32)
t == typeof(Int32)
t
typeof(Int32)
Int32
t == typeof(UInt32)
t
typeof(UInt32)
UInt32
FromPointerInt32();
FromPointerInt32()
FromPointerInt32
()
else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(Int64) || t == typeof(UInt64)
t == typeof(Int64)
t
typeof(Int64)
Int64
t == typeof(UInt64)
t
typeof(UInt64)
UInt64
FromPointerInt64();
FromPointerInt64()
FromPointerInt64
()
else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(float)
t
typeof(float)
float
FromPointerFloat32();
FromPointerFloat32()
FromPointerFloat32
()
else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(double)
t
typeof(double)
double
FromPointerFloat64();
FromPointerFloat64()
FromPointerFloat64
()
else throw new JuliaException("Unable to Determine Pointer Type T");
throw new JuliaException("Unable to Determine Pointer Type T");
new JuliaException("Unable to Determine Pointer Type T")
JuliaException
("Unable to Determine Pointer Type T")
"Unable to Determine Pointer Type T"
"Unable to Determine Pointer Type T"
else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
t.IsByRef
t
IsByRef
{
                    FromPointerRef();
                }
FromPointerRef();
FromPointerRef()
FromPointerRef
()
else throw new JuliaException("Unable to Determine Pointer Type T");
throw new JuliaException("Unable to Determine Pointer Type T");
new JuliaException("Unable to Determine Pointer Type T")
JuliaException
("Unable to Determine Pointer Type T")
"Unable to Determine Pointer Type T"
"Unable to Determine Pointer Type T"
public struct ILStoreExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILStoreExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Field(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f);
            public void Field(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb);

            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Stloc, lb);

            public void ToPointerInt8() => _eb.Emit(OpCodes.Stind_I1);
            public void ToPointerInt16() => _eb.Emit(OpCodes.Stind_I2);
            public void ToPointerInt32() => _eb.Emit(OpCodes.Stind_I4);
            public void ToPointerInt64() => _eb.Emit(OpCodes.Stind_I8);
            public void ToPointerFloat32() => _eb.Emit(OpCodes.Stind_R4);
            public void ToPointerFloat64() => _eb.Emit(OpCodes.Stind_R8);
            public void ToPointerRef() => _eb.Emit(OpCodes.Stind_Ref);

            public void ToPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }
private readonly IlExprBuilder _eb;
IlExprBuilder _eb
IlExprBuilder
_eb
internal ILStoreExprBuilder(IlExprBuilder eb) => _eb = eb;
(IlExprBuilder eb)
IlExprBuilder eb
IlExprBuilder
=> _eb = eb
_eb = eb
_eb
eb
public void Field(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f);
void
(FieldInfo f)
FieldInfo f
FieldInfo
=> _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f)
_eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f)
f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld
f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld
f.IsStatic
f
IsStatic
OpCodes.Stsfld
OpCodes
Stsfld
OpCodes.Stfld
OpCodes
Stfld
f
f
public void Field(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb);
void
(FieldBuilder fb)
FieldBuilder fb
FieldBuilder
=> _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb)
_eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb)
fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld
fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld
fb.IsStatic
fb
IsStatic
OpCodes.Stsfld
OpCodes
Stsfld
OpCodes.Stfld
OpCodes
Stfld
fb
fb
public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Stloc, lb);
void
(LocalBuilder lb)
LocalBuilder lb
LocalBuilder
=> _eb._il.Emit(OpCodes.Stloc, lb)
_eb._il.Emit(OpCodes.Stloc, lb)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Stloc, lb)
OpCodes.Stloc
OpCodes.Stloc
OpCodes
Stloc
lb
lb
public void ToPointerInt8() => _eb.Emit(OpCodes.Stind_I1);
void
()
=> _eb.Emit(OpCodes.Stind_I1)
_eb.Emit(OpCodes.Stind_I1)
_eb.Emit
_eb
Emit
(OpCodes.Stind_I1)
OpCodes.Stind_I1
OpCodes.Stind_I1
OpCodes
Stind_I1
public void ToPointerInt16() => _eb.Emit(OpCodes.Stind_I2);
void
()
=> _eb.Emit(OpCodes.Stind_I2)
_eb.Emit(OpCodes.Stind_I2)
_eb.Emit
_eb
Emit
(OpCodes.Stind_I2)
OpCodes.Stind_I2
OpCodes.Stind_I2
OpCodes
Stind_I2
public void ToPointerInt32() => _eb.Emit(OpCodes.Stind_I4);
void
()
=> _eb.Emit(OpCodes.Stind_I4)
_eb.Emit(OpCodes.Stind_I4)
_eb.Emit
_eb
Emit
(OpCodes.Stind_I4)
OpCodes.Stind_I4
OpCodes.Stind_I4
OpCodes
Stind_I4
public void ToPointerInt64() => _eb.Emit(OpCodes.Stind_I8);
void
()
=> _eb.Emit(OpCodes.Stind_I8)
_eb.Emit(OpCodes.Stind_I8)
_eb.Emit
_eb
Emit
(OpCodes.Stind_I8)
OpCodes.Stind_I8
OpCodes.Stind_I8
OpCodes
Stind_I8
public void ToPointerFloat32() => _eb.Emit(OpCodes.Stind_R4);
void
()
=> _eb.Emit(OpCodes.Stind_R4)
_eb.Emit(OpCodes.Stind_R4)
_eb.Emit
_eb
Emit
(OpCodes.Stind_R4)
OpCodes.Stind_R4
OpCodes.Stind_R4
OpCodes
Stind_R4
public void ToPointerFloat64() => _eb.Emit(OpCodes.Stind_R8);
void
()
=> _eb.Emit(OpCodes.Stind_R8)
_eb.Emit(OpCodes.Stind_R8)
_eb.Emit
_eb
Emit
(OpCodes.Stind_R8)
OpCodes.Stind_R8
OpCodes.Stind_R8
OpCodes
Stind_R8
public void ToPointerRef() => _eb.Emit(OpCodes.Stind_Ref);
void
()
=> _eb.Emit(OpCodes.Stind_Ref)
_eb.Emit(OpCodes.Stind_Ref)
_eb.Emit
_eb
Emit
(OpCodes.Stind_Ref)
OpCodes.Stind_Ref
OpCodes.Stind_Ref
OpCodes
Stind_Ref
public void ToPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
void
(Type t)
Type t
Type
{
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
t.IsPrimitive
t
IsPrimitive
{
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(byte) || t == typeof(sbyte)
t == typeof(byte)
t
typeof(byte)
byte
t == typeof(sbyte)
t
typeof(sbyte)
sbyte
ToPointerInt8();
ToPointerInt8()
ToPointerInt8
()
else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(Int16) || t == typeof(UInt16)
t == typeof(Int16)
t
typeof(Int16)
Int16
t == typeof(UInt16)
t
typeof(UInt16)
UInt16
ToPointerInt16();
ToPointerInt16()
ToPointerInt16
()
else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(Int32) || t == typeof(UInt32)
t == typeof(Int32)
t
typeof(Int32)
Int32
t == typeof(UInt32)
t
typeof(UInt32)
UInt32
ToPointerInt32();
ToPointerInt32()
ToPointerInt32
()
else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(Int64) || t == typeof(UInt64)
t == typeof(Int64)
t
typeof(Int64)
Int64
t == typeof(UInt64)
t
typeof(UInt64)
UInt64
ToPointerInt64();
ToPointerInt64()
ToPointerInt64
()
else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(float)
t
typeof(float)
float
ToPointerFloat32();
ToPointerFloat32()
ToPointerFloat32
()
else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
t == typeof(double)
t
typeof(double)
double
ToPointerFloat64();
ToPointerFloat64()
ToPointerFloat64
()
else throw new JuliaException("Unable to Determine Pointer Type T");
throw new JuliaException("Unable to Determine Pointer Type T");
new JuliaException("Unable to Determine Pointer Type T")
JuliaException
("Unable to Determine Pointer Type T")
"Unable to Determine Pointer Type T"
"Unable to Determine Pointer Type T"
else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
t.IsByRef
t
IsByRef
{
                    ToPointerRef();
                }
ToPointerRef();
ToPointerRef()
ToPointerRef
()
else throw new JuliaException("Unable to Determine Pointer Type T");
throw new JuliaException("Unable to Determine Pointer Type T");
new JuliaException("Unable to Determine Pointer Type T")
JuliaException
("Unable to Determine Pointer Type T")
"Unable to Determine Pointer Type T"
"Unable to Determine Pointer Type T"
public struct ILCreateExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILCreateExprBuilder(IlExprBuilder eb) => _eb = eb;
            public LocalBuilder Local(Type t) => _eb._il.DeclareLocal(t);
            public LocalBuilder Local<T>() => Local(typeof(T));

            public LocalBuilder LocalAndStore(Type t)
            {
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }

            public LocalBuilder LocalAndStore<T>() => LocalAndStore(typeof(T));

            public void Object(ConstructorInfo ci) => _eb.Function.Invoke(ci);
            public void Object(IlExprBuilder cb) => _eb.Function.Invoke(cb, true);
            public void Object<T>(params Type[] parameters) => _eb.Function.Invoke<T>(parameters);
            public void Object(Type t, params Type[] parameters) => _eb.Function.Invoke(t, parameters);
        }
private readonly IlExprBuilder _eb;
IlExprBuilder _eb
IlExprBuilder
_eb
internal ILCreateExprBuilder(IlExprBuilder eb) => _eb = eb;
(IlExprBuilder eb)
IlExprBuilder eb
IlExprBuilder
=> _eb = eb
_eb = eb
_eb
eb
public LocalBuilder Local(Type t) => _eb._il.DeclareLocal(t);
LocalBuilder
(Type t)
Type t
Type
=> _eb._il.DeclareLocal(t)
_eb._il.DeclareLocal(t)
_eb._il.DeclareLocal
_eb._il
_eb
_il
DeclareLocal
(t)
t
t
public LocalBuilder Local<T>() => Local(typeof(T));
LocalBuilder
<T>
T
()
=> Local(typeof(T))
Local(typeof(T))
Local
(typeof(T))
typeof(T)
typeof(T)
T
public LocalBuilder LocalAndStore(Type t)
            {
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }
LocalBuilder
(Type t)
Type t
Type
{
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }
var lb = Local(t);
var lb = Local(t)
var
lb = Local(t)
= Local(t)
Local(t)
Local
(t)
t
t
_eb.Store.Local(lb);
_eb.Store.Local(lb)
_eb.Store.Local
_eb.Store
_eb
Store
Local
(lb)
lb
lb
return lb;
lb
public LocalBuilder LocalAndStore<T>() => LocalAndStore(typeof(T));
LocalBuilder
<T>
T
()
=> LocalAndStore(typeof(T))
LocalAndStore(typeof(T))
LocalAndStore
(typeof(T))
typeof(T)
typeof(T)
T
public void Object(ConstructorInfo ci) => _eb.Function.Invoke(ci);
void
(ConstructorInfo ci)
ConstructorInfo ci
ConstructorInfo
=> _eb.Function.Invoke(ci)
_eb.Function.Invoke(ci)
_eb.Function.Invoke
_eb.Function
_eb
Function
Invoke
(ci)
ci
ci
public void Object(IlExprBuilder cb) => _eb.Function.Invoke(cb, true);
void
(IlExprBuilder cb)
IlExprBuilder cb
IlExprBuilder
=> _eb.Function.Invoke(cb, true)
_eb.Function.Invoke(cb, true)
_eb.Function.Invoke
_eb.Function
_eb
Function
Invoke
(cb, true)
cb
cb
true
true
public void Object<T>(params Type[] parameters) => _eb.Function.Invoke<T>(parameters);
void
<T>
T
(params Type[] parameters)
params Type[] parameters
Type[]
Type
[]

=> _eb.Function.Invoke<T>(parameters)
_eb.Function.Invoke<T>(parameters)
_eb.Function.Invoke<T>
_eb.Function
_eb
Function
Invoke<T>
<T>
T
(parameters)
parameters
parameters
public void Object(Type t, params Type[] parameters) => _eb.Function.Invoke(t, parameters);
void
(Type t, params Type[] parameters)
Type t
Type
params Type[] parameters
Type[]
Type
[]

=> _eb.Function.Invoke(t, parameters)
_eb.Function.Invoke(t, parameters)
_eb.Function.Invoke
_eb.Function
_eb
Function
Invoke
(t, parameters)
t
t
parameters
parameters
public struct ILArrayExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILArrayExprBuilder(IlExprBuilder eb) => _eb = eb;
        }
private readonly IlExprBuilder _eb;
IlExprBuilder _eb
IlExprBuilder
_eb
internal ILArrayExprBuilder(IlExprBuilder eb) => _eb = eb;
(IlExprBuilder eb)
IlExprBuilder eb
IlExprBuilder
=> _eb = eb
_eb = eb
_eb
eb
public struct ILUnsafeExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILUnsafeExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void StackAlloc() => _eb._il.Emit(OpCodes.Localloc);

            public void StackAlloc(Type t, int size)
            {
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }

            public void StackAlloc<T>(int size) => StackAlloc(typeof(T), size);
            public void StoreToPointer(Type t) => _eb.Store.ToPointer(t);
            public void StoreToPointer<T>() => StoreToPointer(typeof(T));
            public void LoadFromPointer(Type t) => _eb.Load.FromPointer(t);
            public void LoadFromPointer<T>() => LoadFromPointer(typeof(T));

            public void CopyBlock(int numBytes)
            {
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }

            public void CopyBlock() => _eb._il.Emit(OpCodes.Cpblk);
        }
private readonly IlExprBuilder _eb;
IlExprBuilder _eb
IlExprBuilder
_eb
internal ILUnsafeExprBuilder(IlExprBuilder eb) => _eb = eb;
(IlExprBuilder eb)
IlExprBuilder eb
IlExprBuilder
=> _eb = eb
_eb = eb
_eb
eb
public void StackAlloc() => _eb._il.Emit(OpCodes.Localloc);
void
()
=> _eb._il.Emit(OpCodes.Localloc)
_eb._il.Emit(OpCodes.Localloc)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Localloc)
OpCodes.Localloc
OpCodes.Localloc
OpCodes
Localloc
public void StackAlloc(Type t, int size)
            {
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }
void
(Type t, int size)
Type t
Type
int size
int
{
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }
_eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
_eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size))
_eb.Load.UInt32
_eb.Load
_eb
Load
UInt32
((uint)(Marshal.SizeOf(t) * size))
(uint)(Marshal.SizeOf(t) * size)
(uint)(Marshal.SizeOf(t) * size)
uint
(Marshal.SizeOf(t) * size)
Marshal.SizeOf(t) * size
Marshal.SizeOf(t)
Marshal.SizeOf
Marshal
SizeOf
(t)
t
t
size
StackAlloc();
StackAlloc()
StackAlloc
()
public void StackAlloc<T>(int size) => StackAlloc(typeof(T), size);
void
<T>
T
(int size)
int size
int
=> StackAlloc(typeof(T), size)
StackAlloc(typeof(T), size)
StackAlloc
(typeof(T), size)
typeof(T)
typeof(T)
T
size
size
public void StoreToPointer(Type t) => _eb.Store.ToPointer(t);
void
(Type t)
Type t
Type
=> _eb.Store.ToPointer(t)
_eb.Store.ToPointer(t)
_eb.Store.ToPointer
_eb.Store
_eb
Store
ToPointer
(t)
t
t
public void StoreToPointer<T>() => StoreToPointer(typeof(T));
void
<T>
T
()
=> StoreToPointer(typeof(T))
StoreToPointer(typeof(T))
StoreToPointer
(typeof(T))
typeof(T)
typeof(T)
T
public void LoadFromPointer(Type t) => _eb.Load.FromPointer(t);
void
(Type t)
Type t
Type
=> _eb.Load.FromPointer(t)
_eb.Load.FromPointer(t)
_eb.Load.FromPointer
_eb.Load
_eb
Load
FromPointer
(t)
t
t
public void LoadFromPointer<T>() => LoadFromPointer(typeof(T));
void
<T>
T
()
=> LoadFromPointer(typeof(T))
LoadFromPointer(typeof(T))
LoadFromPointer
(typeof(T))
typeof(T)
typeof(T)
T
public void CopyBlock(int numBytes)
            {
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }
void
(int numBytes)
int numBytes
int
{
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }
_eb.Load.Int32(numBytes);
_eb.Load.Int32(numBytes)
_eb.Load.Int32
_eb.Load
_eb
Load
Int32
(numBytes)
numBytes
numBytes
CopyBlock();
CopyBlock()
CopyBlock
()
public void CopyBlock() => _eb._il.Emit(OpCodes.Cpblk);
void
()
=> _eb._il.Emit(OpCodes.Cpblk)
_eb._il.Emit(OpCodes.Cpblk)
_eb._il.Emit
_eb._il
_eb
_il
Emit
(OpCodes.Cpblk)
OpCodes.Cpblk
OpCodes.Cpblk
OpCodes
Cpblk
public ILFunctionExprBuilder Function => new(this);
ILFunctionExprBuilder
=> new(this)
new(this)
(this)
this
this
public ILLoadExprBuilder Load => new(this);
ILLoadExprBuilder
=> new(this)
new(this)
(this)
this
this
public ILStoreExprBuilder Store => new(this);
ILStoreExprBuilder
=> new(this)
new(this)
(this)
this
this
public ILCreateExprBuilder Create => new(this);
ILCreateExprBuilder
=> new(this)
new(this)
(this)
this
this
public ILArrayExprBuilder Array => new(this);
ILArrayExprBuilder
=> new(this)
new(this)
(this)
this
this
public ILUnsafeExprBuilder Unsafe => new(this);
ILUnsafeExprBuilder
=> new(this)
new(this)
(this)
this
this
private IlExprBuilder(ILGenerator il, object internalMethod) {
            _il = il;
            _internalMethod = internalMethod;
        }
(ILGenerator il, object internalMethod)
ILGenerator il
ILGenerator
object internalMethod
object
{
            _il = il;
            _internalMethod = internalMethod;
        }
_il = il;
_il = il
_il
il
_internalMethod = internalMethod;
_internalMethod = internalMethod
_internalMethod
internalMethod
public IlExprBuilder(MethodBuilder mb) : this(mb.GetILGenerator(), mb) {}
(MethodBuilder mb)
MethodBuilder mb
MethodBuilder
: this(mb.GetILGenerator(), mb)
(mb.GetILGenerator(), mb)
mb.GetILGenerator()
mb.GetILGenerator()
mb.GetILGenerator
mb
GetILGenerator
()
mb
mb
{}
public IlExprBuilder(ConstructorBuilder cb) : this(cb.GetILGenerator(), cb) {}
(ConstructorBuilder cb)
ConstructorBuilder cb
ConstructorBuilder
: this(cb.GetILGenerator(), cb)
(cb.GetILGenerator(), cb)
cb.GetILGenerator()
cb.GetILGenerator()
cb.GetILGenerator
cb
GetILGenerator
()
cb
cb
{}
public void Emit(OpCode code) => _il.Emit(code);
void
(OpCode code)
OpCode code
OpCode
=> _il.Emit(code)
_il.Emit(code)
_il.Emit
_il
Emit
(code)
code
code
public void Return() => Emit(OpCodes.Ret);
void
()
=> Emit(OpCodes.Ret)
Emit(OpCodes.Ret)
Emit
(OpCodes.Ret)
OpCodes.Ret
OpCodes.Ret
OpCodes
Ret
public void Add() => Emit(OpCodes.Add);
void
()
=> Emit(OpCodes.Add)
Emit(OpCodes.Add)
Emit
(OpCodes.Add)
OpCodes.Add
OpCodes.Add
OpCodes
Add
public void Sub() => Emit(OpCodes.Sub);
void
()
=> Emit(OpCodes.Sub)
Emit(OpCodes.Sub)
Emit
(OpCodes.Sub)
OpCodes.Sub
OpCodes.Sub
OpCodes
Sub
public void Duplicate() => Emit(OpCodes.Dup);
void
()
=> Emit(OpCodes.Dup)
Emit(OpCodes.Dup)
Emit
(OpCodes.Dup)
OpCodes.Dup
OpCodes.Dup
OpCodes
Dup
public void Box(Type t) => _il.Emit(OpCodes.Box, t);
void
(Type t)
Type t
Type
=> _il.Emit(OpCodes.Box, t)
_il.Emit(OpCodes.Box, t)
_il.Emit
_il
Emit
(OpCodes.Box, t)
OpCodes.Box
OpCodes.Box
OpCodes
Box
t
t
public void Box<T>() => Box(typeof(T));
void
<T>
T
()
=> Box(typeof(T))
Box(typeof(T))
Box
(typeof(T))
typeof(T)
typeof(T)
T
public void ReturnVoid() {
            _il.Emit(OpCodes.Nop);
            Return();
        }
void
()
{
            _il.Emit(OpCodes.Nop);
            Return();
        }
_il.Emit(OpCodes.Nop);
_il.Emit(OpCodes.Nop)
_il.Emit
_il
Emit
(OpCodes.Nop)
OpCodes.Nop
OpCodes.Nop
OpCodes
Nop
Return();
Return()
Return
()
public static IlExprBuilder CreateDynamicFunction(out DynamicMethod m, string name = "<Eval>")
        {
            m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);
            return new(m.GetILGenerator(), m);
        }
IlExprBuilder
(out DynamicMethod m, string name = "<Eval>")
out DynamicMethod m
DynamicMethod
string name = "<Eval>"
string
= "<Eval>"
"<Eval>"
{
            m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);
            return new(m.GetILGenerator(), m);
        }
m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);
m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module)
m
new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module)
DynamicMethod
(name, typeof(object), Type.EmptyTypes, typeof(string).Module)
name
name
typeof(object)
typeof(object)
object
Type.EmptyTypes
Type.EmptyTypes
Type
EmptyTypes
typeof(string).Module
typeof(string).Module
typeof(string)
string
Module
return new(m.GetILGenerator(), m);
new(m.GetILGenerator(), m)
(m.GetILGenerator(), m)
m.GetILGenerator()
m.GetILGenerator()
m.GetILGenerator
m
GetILGenerator
()
m
m
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;

namespace runtime.Utils;

public static class ListExtensions
{
    public static bool Visit<T>(this IList<T> l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }
        
    public static bool Visit<T>(this T[] l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }

    public static void Print<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
    
    public static TextWriter Print<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) {
        toStringMethod ??= x => x.ToString();
        tw ??= Console.Out;
        tw.Write("{");
        tw.Write(typeof(T));
        tw.Write("}[");
        if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
        tw.Write("]");
        return tw;
    }

    public static void PrintLn<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l, toStringMethod, tw).WriteLine();
    public static void Print<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
}
using System;
System
using System.Collections;
System.Collections
System
Collections
using System.Collections.Generic;
System.Collections.Generic
System.Collections
System
Collections
Generic
using System.IO;
System.IO
System
IO
using System.Linq;
System.Linq
System
Linq
using System.Runtime.CompilerServices;
System.Runtime.CompilerServices
System.Runtime
System
Runtime
CompilerServices
namespace runtime.Utils;

public static class ListExtensions
{
    public static bool Visit<T>(this IList<T> l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }
        
    public static bool Visit<T>(this T[] l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }

    public static void Print<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
    
    public static TextWriter Print<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) {
        toStringMethod ??= x => x.ToString();
        tw ??= Console.Out;
        tw.Write("{");
        tw.Write(typeof(T));
        tw.Write("}[");
        if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
        tw.Write("]");
        return tw;
    }

    public static void PrintLn<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l, toStringMethod, tw).WriteLine();
    public static void Print<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
}
runtime.Utils
runtime
Utils
public static class ListExtensions
{
    public static bool Visit<T>(this IList<T> l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }
        
    public static bool Visit<T>(this T[] l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }

    public static void Print<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
    
    public static TextWriter Print<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) {
        toStringMethod ??= x => x.ToString();
        tw ??= Console.Out;
        tw.Write("{");
        tw.Write(typeof(T));
        tw.Write("}[");
        if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
        tw.Write("]");
        return tw;
    }

    public static void PrintLn<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l, toStringMethod, tw).WriteLine();
    public static void Print<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
}
public static bool Visit<T>(this IList<T> l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }
bool
<T>
T
(this IList<T> l, Func<T, bool> v)
this IList<T> l
IList<T>
<T>
T
Func<T, bool> v
Func<T, bool>
<T, bool>
T
bool
{
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }
foreach (var t in l)
            if (!v(t))
                return false;
var
l
if (!v(t))
                return false;
!v(t)
v(t)
v
(t)
t
t
return false;
false
return true;
true
public static bool Visit<T>(this T[] l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }
bool
<T>
T
(this T[] l, Func<T, bool> v)
this T[] l
T[]
T
[]

Func<T, bool> v
Func<T, bool>
<T, bool>
T
bool
{
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }
foreach (var t in l)
            if (!v(t))
                return false;
var
l
if (!v(t))
                return false;
!v(t)
v(t)
v
(t)
t
t
return false;
false
return true;
true
public static void Print<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
void
<T>
T
(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null)
this IList<T> l
IList<T>
<T>
T
Func<T, string> toStringMethod = null
Func<T, string>
<T, string>
T
string
= null
null
TextWriter tw = null
TextWriter
= null
null
=> Print(l.GetEnumerator(), toStringMethod, tw)
Print(l.GetEnumerator(), toStringMethod, tw)
Print
(l.GetEnumerator(), toStringMethod, tw)
l.GetEnumerator()
l.GetEnumerator()
l.GetEnumerator
l
GetEnumerator
()
toStringMethod
toStringMethod
tw
tw
public static void PrintLn<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
void
<T>
T
(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null)
this IList<T> l
IList<T>
<T>
T
Func<T, string> toStringMethod = null
Func<T, string>
<T, string>
T
string
= null
null
TextWriter tw = null
TextWriter
= null
null
=> PrintLn(l.GetEnumerator(), toStringMethod, tw)
PrintLn(l.GetEnumerator(), toStringMethod, tw)
PrintLn
(l.GetEnumerator(), toStringMethod, tw)
l.GetEnumerator()
l.GetEnumerator()
l.GetEnumerator
l
GetEnumerator
()
toStringMethod
toStringMethod
tw
tw
public static TextWriter Print<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) {
        toStringMethod ??= x => x.ToString();
        tw ??= Console.Out;
        tw.Write("{");
        tw.Write(typeof(T));
        tw.Write("}[");
        if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
        tw.Write("]");
        return tw;
    }
TextWriter
<T>
T
(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null)
this IEnumerator l
IEnumerator
Func<T, string> toStringMethod = null
Func<T, string>
<T, string>
T
string
= null
null
TextWriter tw = null
TextWriter
= null
null
{
        toStringMethod ??= x => x.ToString();
        tw ??= Console.Out;
        tw.Write("{");
        tw.Write(typeof(T));
        tw.Write("}[");
        if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
        tw.Write("]");
        return tw;
    }
toStringMethod ??= x => x.ToString();
toStringMethod ??= x => x.ToString()
toStringMethod
x => x.ToString()
x
x.ToString()
x.ToString
x
ToString
()
tw ??= Console.Out;
tw ??= Console.Out
tw
Console.Out
Console
Out
tw.Write("{");
tw.Write("{")
tw.Write
tw
Write
("{")
"{"
"{"
tw.Write(typeof(T));
tw.Write(typeof(T))
tw.Write
tw
Write
(typeof(T))
typeof(T)
typeof(T)
T
tw.Write("}[");
tw.Write("}[")
tw.Write
tw
Write
("}[")
"}["
"}["
if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
l.MoveNext()
l.MoveNext
l
MoveNext
()
{
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
tw.Write(toStringMethod((T) l.Current));
tw.Write(toStringMethod((T) l.Current))
tw.Write
tw
Write
(toStringMethod((T) l.Current))
toStringMethod((T) l.Current)
toStringMethod((T) l.Current)
toStringMethod
((T) l.Current)
(T) l.Current
(T) l.Current
T
l.Current
l
Current
while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
l.MoveNext()
l.MoveNext
l
MoveNext
()
{
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
tw.Write(", ");
tw.Write(", ")
tw.Write
tw
Write
(", ")
", "
", "
tw.Write(toStringMethod((T) l.Current));
tw.Write(toStringMethod((T) l.Current))
tw.Write
tw
Write
(toStringMethod((T) l.Current))
toStringMethod((T) l.Current)
toStringMethod((T) l.Current)
toStringMethod
((T) l.Current)
(T) l.Current
(T) l.Current
T
l.Current
l
Current
tw.Write("]");
tw.Write("]")
tw.Write
tw
Write
("]")
"]"
"]"
return tw;
tw
public static void PrintLn<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l, toStringMethod, tw).WriteLine();
void
<T>
T
(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null)
this IEnumerator l
IEnumerator
Func<T, string> toStringMethod = null
Func<T, string>
<T, string>
T
string
= null
null
TextWriter tw = null
TextWriter
= null
null
=> Print(l, toStringMethod, tw).WriteLine()
Print(l, toStringMethod, tw).WriteLine()
Print(l, toStringMethod, tw).WriteLine
Print(l, toStringMethod, tw)
Print
(l, toStringMethod, tw)
l
l
toStringMethod
toStringMethod
tw
tw
WriteLine
()
public static void Print<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
void
<T>
T
(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null)
this T[] l
T[]
T
[]

Func<T, string> toStringMethod = null
Func<T, string>
<T, string>
T
string
= null
null
TextWriter tw = null
TextWriter
= null
null
=> Print(l.GetEnumerator(), toStringMethod, tw)
Print(l.GetEnumerator(), toStringMethod, tw)
Print
(l.GetEnumerator(), toStringMethod, tw)
l.GetEnumerator()
l.GetEnumerator()
l.GetEnumerator
l
GetEnumerator
()
toStringMethod
toStringMethod
tw
tw
public static void PrintLn<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
void
<T>
T
(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null)
this T[] l
T[]
T
[]

Func<T, string> toStringMethod = null
Func<T, string>
<T, string>
T
string
= null
null
TextWriter tw = null
TextWriter
= null
null
=> PrintLn(l.GetEnumerator(), toStringMethod, tw)
PrintLn(l.GetEnumerator(), toStringMethod, tw)
PrintLn
(l.GetEnumerator(), toStringMethod, tw)
l.GetEnumerator()
l.GetEnumerator()
l.GetEnumerator
l
GetEnumerator
()
toStringMethod
toStringMethod
tw
tw
global using JStringRef = System.Int32;
using System;
using runtime.Utils;

namespace runtime.core.JIL;

public readonly struct JNameRef {
    public readonly int CompileTimeNameRefIndex;
    public readonly ushort CompileTimeExprStackDelta;

    public JNameRef(int nameRefIndex, ushort stackDelta) {
        CompileTimeNameRefIndex = nameRefIndex;
        CompileTimeExprStackDelta = stackDelta;
    }

    public override string ToString() => "Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex;
}

public class JILExpr : IJExpr {
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];
    
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    internal JILExpr(JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)
    {
        Modifiers = modifiers;
        Code = code;
        VarTable = variables;
        Names = names;
        Parent = parent;
    }
}

public class JILMethod : JILExpr, IJMethod
{
    public readonly JNameRef[] Parameters;

    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v) {
        var names = Names;
        foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);

    internal JILMethod(JMethodFlags methodModifiers, JNameRef[] parameters, 
            JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        MethodModifiers = methodModifiers;
        Parameters = parameters;
    }
}

public struct JILField : IJField {
    public JStringRef NameRef { get; internal set; }
    public JNameRef TypeRef { get; internal set; }
    public string Name => Parent.Context.GetString(NameRef);
    public IJType Type => throw new NotSupportedException();
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    internal JILField(JStringRef name, JFieldFlags modifiers, JNameRef type, IJExpr parent) {
        NameRef = name;
        Modifiers = modifiers;
        TypeRef = type;
        Parent = parent;
    }
}

public class JILType : IJType{
    public JStringRef NameRef { get; internal set; }
    public readonly JILField[] Fields;
    public readonly JILMethod[] Constructors;
    public IJExpr Parent { get; internal set; }
    public JTypeType Type { get; }

    internal JILType(JStringRef name, JTypeType type, JILField[] fields, JILMethod[] constructors, IJModule parent) {
        NameRef = name;
        Type = type;
        Fields = fields;
        Constructors = constructors;
        Parent = parent;
    }

    public string Name => Parent.Context.GetString(NameRef);
    public JExprFlags Modifiers => JExprFlags.None;
    public IJModule Module => Parent as IJModule;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => Constructors.Visit(x => v(x));
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }
    
    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}

public sealed class JILModule : JILExpr, IJModule {
    public JStringRef NameRef { get; internal set; }
    internal IJCodeContext Ctx;
    public JModuleFlags ModuleModifiers { get; }

    internal JILModule(JStringRef name, JModuleFlags flags, 
        JExprFlags modifiers, byte[] code, JNameRef[] variables, 
        JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        NameRef = name;
        ModuleModifiers = flags;
        Parent = parent;
    }

    public string Name => Ctx.GetString(NameRef);
    
    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotSupportedException();

    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        Names.PrintLn(x => x.Name);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}
global using JStringRef = System.Int32;
JStringRef =
JStringRef
System.Int32
System
Int32
using System;
System
using runtime.Utils;
runtime.Utils
runtime
Utils
namespace runtime.core.JIL;

public readonly struct JNameRef {
    public readonly int CompileTimeNameRefIndex;
    public readonly ushort CompileTimeExprStackDelta;

    public JNameRef(int nameRefIndex, ushort stackDelta) {
        CompileTimeNameRefIndex = nameRefIndex;
        CompileTimeExprStackDelta = stackDelta;
    }

    public override string ToString() => "Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex;
}

public class JILExpr : IJExpr {
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];
    
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    internal JILExpr(JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)
    {
        Modifiers = modifiers;
        Code = code;
        VarTable = variables;
        Names = names;
        Parent = parent;
    }
}

public class JILMethod : JILExpr, IJMethod
{
    public readonly JNameRef[] Parameters;

    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v) {
        var names = Names;
        foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);

    internal JILMethod(JMethodFlags methodModifiers, JNameRef[] parameters, 
            JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        MethodModifiers = methodModifiers;
        Parameters = parameters;
    }
}

public struct JILField : IJField {
    public JStringRef NameRef { get; internal set; }
    public JNameRef TypeRef { get; internal set; }
    public string Name => Parent.Context.GetString(NameRef);
    public IJType Type => throw new NotSupportedException();
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    internal JILField(JStringRef name, JFieldFlags modifiers, JNameRef type, IJExpr parent) {
        NameRef = name;
        Modifiers = modifiers;
        TypeRef = type;
        Parent = parent;
    }
}

public class JILType : IJType{
    public JStringRef NameRef { get; internal set; }
    public readonly JILField[] Fields;
    public readonly JILMethod[] Constructors;
    public IJExpr Parent { get; internal set; }
    public JTypeType Type { get; }

    internal JILType(JStringRef name, JTypeType type, JILField[] fields, JILMethod[] constructors, IJModule parent) {
        NameRef = name;
        Type = type;
        Fields = fields;
        Constructors = constructors;
        Parent = parent;
    }

    public string Name => Parent.Context.GetString(NameRef);
    public JExprFlags Modifiers => JExprFlags.None;
    public IJModule Module => Parent as IJModule;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => Constructors.Visit(x => v(x));
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }
    
    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}

public sealed class JILModule : JILExpr, IJModule {
    public JStringRef NameRef { get; internal set; }
    internal IJCodeContext Ctx;
    public JModuleFlags ModuleModifiers { get; }

    internal JILModule(JStringRef name, JModuleFlags flags, 
        JExprFlags modifiers, byte[] code, JNameRef[] variables, 
        JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        NameRef = name;
        ModuleModifiers = flags;
        Parent = parent;
    }

    public string Name => Ctx.GetString(NameRef);
    
    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotSupportedException();

    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        Names.PrintLn(x => x.Name);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}
runtime.core.JIL
runtime.core
runtime
core
JIL
public readonly struct JNameRef {
    public readonly int CompileTimeNameRefIndex;
    public readonly ushort CompileTimeExprStackDelta;

    public JNameRef(int nameRefIndex, ushort stackDelta) {
        CompileTimeNameRefIndex = nameRefIndex;
        CompileTimeExprStackDelta = stackDelta;
    }

    public override string ToString() => "Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex;
}
public readonly int CompileTimeNameRefIndex;
int CompileTimeNameRefIndex
int
CompileTimeNameRefIndex
public readonly ushort CompileTimeExprStackDelta;
ushort CompileTimeExprStackDelta
ushort
CompileTimeExprStackDelta
public JNameRef(int nameRefIndex, ushort stackDelta) {
        CompileTimeNameRefIndex = nameRefIndex;
        CompileTimeExprStackDelta = stackDelta;
    }
(int nameRefIndex, ushort stackDelta)
int nameRefIndex
int
ushort stackDelta
ushort
{
        CompileTimeNameRefIndex = nameRefIndex;
        CompileTimeExprStackDelta = stackDelta;
    }
CompileTimeNameRefIndex = nameRefIndex;
CompileTimeNameRefIndex = nameRefIndex
CompileTimeNameRefIndex
nameRefIndex
CompileTimeExprStackDelta = stackDelta;
CompileTimeExprStackDelta = stackDelta
CompileTimeExprStackDelta
stackDelta
public override string ToString() => "Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex;
string
()
=> "Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex
"Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex
"Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:"
"Expression Depth:" + CompileTimeExprStackDelta
"Expression Depth:"
CompileTimeExprStackDelta
"\tNameRefIndex:"
CompileTimeNameRefIndex
public class JILExpr : IJExpr {
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];
    
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    internal JILExpr(JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)
    {
        Modifiers = modifiers;
        Code = code;
        VarTable = variables;
        Names = names;
        Parent = parent;
    }
}
: IJExpr
IJExpr
IJExpr
public readonly byte[] Code;
byte[] Code
byte[]
byte
[]

Code
public readonly JNameRef[] VarTable;
JNameRef[] VarTable
JNameRef[]
JNameRef
[]

VarTable
public readonly JILField[] Names;
JILField[] Names
JILField[]
JILField
[]

Names
public JExprFlags Modifiers { get; }
JExprFlags
{ get; }
get;
public IJExpr Parent { get; internal set; }
IJExpr
{ get; internal set; }
get;
internal set;
public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
{
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }
foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
var
VarTable
{
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
!v(Names[va.CompileTimeNameRefIndex])
v(Names[va.CompileTimeNameRefIndex])
v
(Names[va.CompileTimeNameRefIndex])
Names[va.CompileTimeNameRefIndex]
Names[va.CompileTimeNameRefIndex]
Names
[va.CompileTimeNameRefIndex]
va.CompileTimeNameRefIndex
va.CompileTimeNameRefIndex
va
CompileTimeNameRefIndex
return false;
false
return true;
true
public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
bool
(Func<IJField, object, bool> v)
Func<IJField, object, bool> v
Func<IJField, object, bool>
<IJField, object, bool>
IJField
object
bool
{
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
int i = 0
int
i = 0
= 0
0
i < Names.Length
i
Names.Length
Names
Length
i++
i
if (!v(Names[i], null))
                return false;
!v(Names[i], null)
v(Names[i], null)
v
(Names[i], null)
Names[i]
Names[i]
Names
[i]
i
i
null
null
return false;
false
return true;
true
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];
IJField
IJExpr.
IJExpr
(JNameRef nameRef)
JNameRef nameRef
JNameRef
=> Names[nameRef.CompileTimeNameRefIndex]
Names[nameRef.CompileTimeNameRefIndex]
Names
[nameRef.CompileTimeNameRefIndex]
nameRef.CompileTimeNameRefIndex
nameRef.CompileTimeNameRefIndex
nameRef
CompileTimeNameRefIndex
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
bool
IJExpr.
IJExpr
(string name, out JNameRef nameRef)
string name
string
out JNameRef nameRef
JNameRef
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
internal JILExpr(JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)
    {
        Modifiers = modifiers;
        Code = code;
        VarTable = variables;
        Names = names;
        Parent = parent;
    }
(JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)
JExprFlags modifiers
JExprFlags
byte[] code
byte[]
byte
[]

JNameRef[] variables
JNameRef[]
JNameRef
[]

JILField[] names
JILField[]
JILField
[]

IJExpr parent
IJExpr
{
        Modifiers = modifiers;
        Code = code;
        VarTable = variables;
        Names = names;
        Parent = parent;
    }
Modifiers = modifiers;
Modifiers = modifiers
Modifiers
modifiers
Code = code;
Code = code
Code
code
VarTable = variables;
VarTable = variables
VarTable
variables
Names = names;
Names = names
Names
names
Parent = parent;
Parent = parent
Parent
parent
public class JILMethod : JILExpr, IJMethod
{
    public readonly JNameRef[] Parameters;

    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v) {
        var names = Names;
        foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);

    internal JILMethod(JMethodFlags methodModifiers, JNameRef[] parameters, 
            JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        MethodModifiers = methodModifiers;
        Parameters = parameters;
    }
}
: JILExpr, IJMethod
JILExpr
JILExpr
IJMethod
IJMethod
public readonly JNameRef[] Parameters;
JNameRef[] Parameters
JNameRef[]
JNameRef
[]

Parameters
public JMethodFlags MethodModifiers { get; }
JMethodFlags
{ get; }
get;
public bool VisitParameters(Func<IJField, bool> v) {
        var names = Names;
        foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
{
        var names = Names;
        foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }
var names = Names;
var names = Names
var
names = Names
= Names
Names
foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
var
Parameters
{
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
!v(names[va.CompileTimeNameRefIndex])
v(names[va.CompileTimeNameRefIndex])
v
(names[va.CompileTimeNameRefIndex])
names[va.CompileTimeNameRefIndex]
names[va.CompileTimeNameRefIndex]
names
[va.CompileTimeNameRefIndex]
va.CompileTimeNameRefIndex
va.CompileTimeNameRefIndex
va
CompileTimeNameRefIndex
return false;
false
return true;
true
public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);
bool
=> MethodModifiers.HasFlag(JMethodFlags.Inline)
MethodModifiers.HasFlag(JMethodFlags.Inline)
MethodModifiers.HasFlag
MethodModifiers
HasFlag
(JMethodFlags.Inline)
JMethodFlags.Inline
JMethodFlags.Inline
JMethodFlags
Inline
internal JILMethod(JMethodFlags methodModifiers, JNameRef[] parameters, 
            JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        MethodModifiers = methodModifiers;
        Parameters = parameters;
    }
(JMethodFlags methodModifiers, JNameRef[] parameters, 
            JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)
JMethodFlags methodModifiers
JMethodFlags
JNameRef[] parameters
JNameRef[]
JNameRef
[]

JExprFlags modifiers
JExprFlags
byte[] code
byte[]
byte
[]

JNameRef[] variables
JNameRef[]
JNameRef
[]

JILField[] names
JILField[]
JILField
[]

IJExpr parent
IJExpr
: base(modifiers, code, variables, names, parent)
(modifiers, code, variables, names, parent)
modifiers
modifiers
code
code
variables
variables
names
names
parent
parent
{
        MethodModifiers = methodModifiers;
        Parameters = parameters;
    }
MethodModifiers = methodModifiers;
MethodModifiers = methodModifiers
MethodModifiers
methodModifiers
Parameters = parameters;
Parameters = parameters
Parameters
parameters
public struct JILField : IJField {
    public JStringRef NameRef { get; internal set; }
    public JNameRef TypeRef { get; internal set; }
    public string Name => Parent.Context.GetString(NameRef);
    public IJType Type => throw new NotSupportedException();
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    internal JILField(JStringRef name, JFieldFlags modifiers, JNameRef type, IJExpr parent) {
        NameRef = name;
        Modifiers = modifiers;
        TypeRef = type;
        Parent = parent;
    }
}
: IJField
IJField
IJField
public JStringRef NameRef { get; internal set; }
JStringRef
{ get; internal set; }
get;
internal set;
public JNameRef TypeRef { get; internal set; }
JNameRef
{ get; internal set; }
get;
internal set;
public string Name => Parent.Context.GetString(NameRef);
string
=> Parent.Context.GetString(NameRef)
Parent.Context.GetString(NameRef)
Parent.Context.GetString
Parent.Context
Parent
Context
GetString
(NameRef)
NameRef
NameRef
public IJType Type => throw new NotSupportedException();
IJType
=> throw new NotSupportedException()
throw new NotSupportedException()
new NotSupportedException()
NotSupportedException
()
public JFieldFlags Modifiers { get; }
JFieldFlags
{ get; }
get;
public IJExpr Parent { get; internal set; }
IJExpr
{ get; internal set; }
get;
internal set;
internal JILField(JStringRef name, JFieldFlags modifiers, JNameRef type, IJExpr parent) {
        NameRef = name;
        Modifiers = modifiers;
        TypeRef = type;
        Parent = parent;
    }
(JStringRef name, JFieldFlags modifiers, JNameRef type, IJExpr parent)
JStringRef name
JStringRef
JFieldFlags modifiers
JFieldFlags
JNameRef type
JNameRef
IJExpr parent
IJExpr
{
        NameRef = name;
        Modifiers = modifiers;
        TypeRef = type;
        Parent = parent;
    }
NameRef = name;
NameRef = name
NameRef
name
Modifiers = modifiers;
Modifiers = modifiers
Modifiers
modifiers
TypeRef = type;
TypeRef = type
TypeRef
type
Parent = parent;
Parent = parent
Parent
parent
public class JILType : IJType{
    public JStringRef NameRef { get; internal set; }
    public readonly JILField[] Fields;
    public readonly JILMethod[] Constructors;
    public IJExpr Parent { get; internal set; }
    public JTypeType Type { get; }

    internal JILType(JStringRef name, JTypeType type, JILField[] fields, JILMethod[] constructors, IJModule parent) {
        NameRef = name;
        Type = type;
        Fields = fields;
        Constructors = constructors;
        Parent = parent;
    }

    public string Name => Parent.Context.GetString(NameRef);
    public JExprFlags Modifiers => JExprFlags.None;
    public IJModule Module => Parent as IJModule;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => Constructors.Visit(x => v(x));
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }
    
    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}
: IJType
IJType
IJType
public JStringRef NameRef { get; internal set; }
JStringRef
{ get; internal set; }
get;
internal set;
public readonly JILField[] Fields;
JILField[] Fields
JILField[]
JILField
[]

Fields
public readonly JILMethod[] Constructors;
JILMethod[] Constructors
JILMethod[]
JILMethod
[]

Constructors
public IJExpr Parent { get; internal set; }
IJExpr
{ get; internal set; }
get;
internal set;
public JTypeType Type { get; }
JTypeType
{ get; }
get;
internal JILType(JStringRef name, JTypeType type, JILField[] fields, JILMethod[] constructors, IJModule parent) {
        NameRef = name;
        Type = type;
        Fields = fields;
        Constructors = constructors;
        Parent = parent;
    }
(JStringRef name, JTypeType type, JILField[] fields, JILMethod[] constructors, IJModule parent)
JStringRef name
JStringRef
JTypeType type
JTypeType
JILField[] fields
JILField[]
JILField
[]

JILMethod[] constructors
JILMethod[]
JILMethod
[]

IJModule parent
IJModule
{
        NameRef = name;
        Type = type;
        Fields = fields;
        Constructors = constructors;
        Parent = parent;
    }
NameRef = name;
NameRef = name
NameRef
name
Type = type;
Type = type
Type
type
Fields = fields;
Fields = fields
Fields
fields
Constructors = constructors;
Constructors = constructors
Constructors
constructors
Parent = parent;
Parent = parent
Parent
parent
public string Name => Parent.Context.GetString(NameRef);
string
=> Parent.Context.GetString(NameRef)
Parent.Context.GetString(NameRef)
Parent.Context.GetString
Parent.Context
Parent
Context
GetString
(NameRef)
NameRef
NameRef
public JExprFlags Modifiers => JExprFlags.None;
JExprFlags
=> JExprFlags.None
JExprFlags.None
JExprFlags
None
public IJModule Module => Parent as IJModule;
IJModule
=> Parent as IJModule
Parent as IJModule
Parent
IJModule
public bool VisitVariables(Func<IJField, bool> v) => true;
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
=> true
true
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
IJField
IJExpr.
IJExpr
(JNameRef nameRef)
JNameRef nameRef
JNameRef
=> Fields[nameRef.CompileTimeNameRefIndex]
Fields[nameRef.CompileTimeNameRefIndex]
Fields
[nameRef.CompileTimeNameRefIndex]
nameRef.CompileTimeNameRefIndex
nameRef.CompileTimeNameRefIndex
nameRef
CompileTimeNameRefIndex
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
bool
IJExpr.
IJExpr
(string name, out JNameRef nameRef)
string name
string
out JNameRef nameRef
JNameRef
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
=> Fields.Visit(x => v(x))
Fields.Visit(x => v(x))
Fields.Visit
Fields
Visit
(x => v(x))
x => v(x)
x => v(x)
x
v(x)
v
(x)
x
x
public bool VisitConstructors(Func<IJMethod, bool> v) => Constructors.Visit(x => v(x));
bool
(Func<IJMethod, bool> v)
Func<IJMethod, bool> v
Func<IJMethod, bool>
<IJMethod, bool>
IJMethod
bool
=> Constructors.Visit(x => v(x))
Constructors.Visit(x => v(x))
Constructors.Visit
Constructors
Visit
(x => v(x))
x => v(x)
x => v(x)
x
v(x)
v
(x)
x
x
public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }
bool
(Func<IJField, object, bool> v)
Func<IJField, object, bool> v
Func<IJField, object, bool>
<IJField, object, bool>
IJField
object
bool
{
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }
for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
int i = 0
int
i = 0
= 0
0
i < Fields.Length
i
Fields.Length
Fields
Length
i++
i
if (!v(Fields[i], null))
                return false;
!v(Fields[i], null)
v(Fields[i], null)
v
(Fields[i], null)
Fields[i]
Fields[i]
Fields
[i]
i
i
null
null
return false;
false
return true;
true
void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
void
IJExpr.
IJExpr
(IContextMerger merger)
IContextMerger merger
IContextMerger
{
        NameRef = merger.GetNewString(NameRef);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
NameRef = merger.GetNewString(NameRef);
NameRef = merger.GetNewString(NameRef)
NameRef
merger.GetNewString(NameRef)
merger.GetNewString
merger
GetNewString
(NameRef)
NameRef
NameRef
VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        })
VisitNames
((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        })
(f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }
(f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }
(f, v)
f
v
{
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }
var jf = (JILField) f;
var jf = (JILField) f
var
jf = (JILField) f
= (JILField) f
(JILField) f
JILField
f
jf.NameRef = merger.GetNewString(jf.NameRef);
jf.NameRef = merger.GetNewString(jf.NameRef)
jf.NameRef
jf
NameRef
merger.GetNewString(jf.NameRef)
merger.GetNewString
merger
GetNewString
(jf.NameRef)
jf.NameRef
jf.NameRef
jf
NameRef
return true;
true
public sealed class JILModule : JILExpr, IJModule {
    public JStringRef NameRef { get; internal set; }
    internal IJCodeContext Ctx;
    public JModuleFlags ModuleModifiers { get; }

    internal JILModule(JStringRef name, JModuleFlags flags, 
        JExprFlags modifiers, byte[] code, JNameRef[] variables, 
        JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        NameRef = name;
        ModuleModifiers = flags;
        Parent = parent;
    }

    public string Name => Ctx.GetString(NameRef);
    
    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotSupportedException();

    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        Names.PrintLn(x => x.Name);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}
: JILExpr, IJModule
JILExpr
JILExpr
IJModule
IJModule
public JStringRef NameRef { get; internal set; }
JStringRef
{ get; internal set; }
get;
internal set;
internal IJCodeContext Ctx;
IJCodeContext Ctx
IJCodeContext
Ctx
public JModuleFlags ModuleModifiers { get; }
JModuleFlags
{ get; }
get;
internal JILModule(JStringRef name, JModuleFlags flags, 
        JExprFlags modifiers, byte[] code, JNameRef[] variables, 
        JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        NameRef = name;
        ModuleModifiers = flags;
        Parent = parent;
    }
(JStringRef name, JModuleFlags flags, 
        JExprFlags modifiers, byte[] code, JNameRef[] variables, 
        JILField[] names, IJExpr parent)
JStringRef name
JStringRef
JModuleFlags flags
JModuleFlags
JExprFlags modifiers
JExprFlags
byte[] code
byte[]
byte
[]

JNameRef[] variables
JNameRef[]
JNameRef
[]

JILField[] names
JILField[]
JILField
[]

IJExpr parent
IJExpr
: base(modifiers, code, variables, names, parent)
(modifiers, code, variables, names, parent)
modifiers
modifiers
code
code
variables
variables
names
names
parent
parent
{
        NameRef = name;
        ModuleModifiers = flags;
        Parent = parent;
    }
NameRef = name;
NameRef = name
NameRef
name
ModuleModifiers = flags;
ModuleModifiers = flags
ModuleModifiers
flags
Parent = parent;
Parent = parent
Parent
parent
public string Name => Ctx.GetString(NameRef);
string
=> Ctx.GetString(NameRef)
Ctx.GetString(NameRef)
Ctx.GetString
Ctx
GetString
(NameRef)
NameRef
NameRef
public bool GetNameV<T>(JNameRef r, out T t) => throw new NotSupportedException();
bool
<T>
T
(JNameRef r, out T t)
JNameRef r
JNameRef
out T t
T
=> throw new NotSupportedException()
throw new NotSupportedException()
new NotSupportedException()
NotSupportedException
()
void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        Names.PrintLn(x => x.Name);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
void
IJExpr.
IJExpr
(IContextMerger merger)
IContextMerger merger
IContextMerger
{
        NameRef = merger.GetNewString(NameRef);
        Names.PrintLn(x => x.Name);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
NameRef = merger.GetNewString(NameRef);
NameRef = merger.GetNewString(NameRef)
NameRef
merger.GetNewString(NameRef)
merger.GetNewString
merger
GetNewString
(NameRef)
NameRef
NameRef
Names.PrintLn(x => x.Name);
Names.PrintLn(x => x.Name)
Names.PrintLn
Names
PrintLn
(x => x.Name)
x => x.Name
x => x.Name
x
x.Name
x
Name
VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        })
VisitNames
((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        })
(f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }
(f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }
(f, v)
f
v
{
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }
var jf = (JILField) f;
var jf = (JILField) f
var
jf = (JILField) f
= (JILField) f
(JILField) f
JILField
f
jf.NameRef = merger.GetNewString(jf.NameRef);
jf.NameRef = merger.GetNewString(jf.NameRef)
jf.NameRef
jf
NameRef
merger.GetNewString(jf.NameRef)
merger.GetNewString
merger
GetNewString
(jf.NameRef)
jf.NameRef
jf.NameRef
jf
NameRef
return true;
true
using System;
using runtime.core.JIL;

namespace runtime.core;

[Flags]
public enum JExprFlags : byte {
    None = 0
}

[Flags]
public enum JMethodFlags : byte {
    None = 0,
    Inline = 1 << 0
}

[Flags]
public enum JModuleFlags : byte
{
    None = 0,
    Bare = 1 << 0
}

[Flags]
public enum JFieldFlags : byte{
    None = 0,
    Const = 1 << 0,
    Global = 1 << 1,
}

public enum JTypeType : byte{
    None,
    Abstract,
    Mutable,
    Struct,
    Primitive
}



public interface IJCodeContext {
    public string GetString(JStringRef i);
    public IJModule GetCtxModule(int i);
    public IJType GetCtxType(int i);
    public JStringRef GetStringIndex(string s);
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        IJExpr v = e;
        while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
        nameRef = default;
        return false;
    }
    
    public IJField GetNameField(IJExpr e, JNameRef nameRef)  {
        if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
        return e.GetNameFieldImpl(nameRef);
    }
}

public interface IJCodeExecutionContext : IJCodeContext{
    public void EnterModule(IJModule m);
    public void ExitModule();
    public void EnterExpr(IJExpr e);
    public void ExitExpr();
    public IJExpr GetExpr(int i);
    public IJModule CurrentModule { get; }
    public IJExpr CurrentExpr { get; }
}

public interface IJModule : IJExpr
{
    public string Name { get; }
    IJModule IJExpr.Module => this;
    public IJModule ParentModule => Parent.Module;
    public JModuleFlags ModuleModifiers { get; }
    public bool IsBare => ModuleModifiers.HasFlag(JModuleFlags.Bare);
    public bool GetNameV<T>(JNameRef r, out T t);
    public bool GetName(JNameRef r, out object o) => GetNameV(r, out o);
}

public interface IContextMerger : Reader.IJILVisitor {
    public JStringRef GetNewString(JStringRef str);
    public int GetNewType(int oldType);
    public int GetNewModule(int oldModule);
}

public interface IJExpr {
    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; }
    public IJModule Module => Parent.Module;
    public IJCodeContext Context => Parent.Context;
    public bool VisitVariables(Func<IJField, bool> v);
    public bool VisitNames(Func<IJField, object, bool> v);
    public IJField GetNameField(JNameRef nameRef) => Context.GetNameField(this, nameRef);
    internal IJField GetNameFieldImpl(JNameRef nameRef);
    
    public bool GetNameRef(string name, out JNameRef nameRef) => Context.GetNameRef(this, name, out nameRef);
    internal bool GetNameRefImpl(string name, out JNameRef nameRef);
    public JNameRef GetNameRef(string name) {
        if (GetNameRef(name, out var nameRef))
            return nameRef;
        throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");
    }

    protected internal void UpdateContext(IContextMerger merger){}
}

public interface IJMethod : IJExpr{
    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v);
    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);
}

public interface IJType : IJExpr{
    public string Name { get; }
    public JTypeType Type { get; }
    public bool VisitFields(Func<IJField, bool> v);
    public bool VisitConstructors(Func<IJMethod, bool> v);
}

public interface IJField {
    public string Name { get; }
    public IJType Type { get; }
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; }
    protected internal void UpdateContext(JStringRef[] str2strmap, int typeOffset, int moduleOffset){}
    public bool IsConst => Modifiers.HasFlag(JFieldFlags.Const);

    public bool IsGlobal => Modifiers.HasFlag(JFieldFlags.Global);

    public bool IsLocal => !IsGlobal;
}

public interface IJFunction {
    public string Name { get; }

    public bool VisitMethods(Func<IJMethod, bool> v);
}

public interface IJName : IJField {
    public object ObjectValue { get; set; }
    public JNameRef NameRef { get; }
    IJExpr IJField.Parent => Type.Parent;
}

public interface IJName<T> : IJName
{
    public T Value { get; set; }
}
using System;
System
using runtime.core.JIL;
runtime.core.JIL
runtime.core
runtime
core
JIL
namespace runtime.core;

[Flags]
public enum JExprFlags : byte {
    None = 0
}

[Flags]
public enum JMethodFlags : byte {
    None = 0,
    Inline = 1 << 0
}

[Flags]
public enum JModuleFlags : byte
{
    None = 0,
    Bare = 1 << 0
}

[Flags]
public enum JFieldFlags : byte{
    None = 0,
    Const = 1 << 0,
    Global = 1 << 1,
}

public enum JTypeType : byte{
    None,
    Abstract,
    Mutable,
    Struct,
    Primitive
}



public interface IJCodeContext {
    public string GetString(JStringRef i);
    public IJModule GetCtxModule(int i);
    public IJType GetCtxType(int i);
    public JStringRef GetStringIndex(string s);
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        IJExpr v = e;
        while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
        nameRef = default;
        return false;
    }
    
    public IJField GetNameField(IJExpr e, JNameRef nameRef)  {
        if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
        return e.GetNameFieldImpl(nameRef);
    }
}

public interface IJCodeExecutionContext : IJCodeContext{
    public void EnterModule(IJModule m);
    public void ExitModule();
    public void EnterExpr(IJExpr e);
    public void ExitExpr();
    public IJExpr GetExpr(int i);
    public IJModule CurrentModule { get; }
    public IJExpr CurrentExpr { get; }
}

public interface IJModule : IJExpr
{
    public string Name { get; }
    IJModule IJExpr.Module => this;
    public IJModule ParentModule => Parent.Module;
    public JModuleFlags ModuleModifiers { get; }
    public bool IsBare => ModuleModifiers.HasFlag(JModuleFlags.Bare);
    public bool GetNameV<T>(JNameRef r, out T t);
    public bool GetName(JNameRef r, out object o) => GetNameV(r, out o);
}

public interface IContextMerger : Reader.IJILVisitor {
    public JStringRef GetNewString(JStringRef str);
    public int GetNewType(int oldType);
    public int GetNewModule(int oldModule);
}

public interface IJExpr {
    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; }
    public IJModule Module => Parent.Module;
    public IJCodeContext Context => Parent.Context;
    public bool VisitVariables(Func<IJField, bool> v);
    public bool VisitNames(Func<IJField, object, bool> v);
    public IJField GetNameField(JNameRef nameRef) => Context.GetNameField(this, nameRef);
    internal IJField GetNameFieldImpl(JNameRef nameRef);
    
    public bool GetNameRef(string name, out JNameRef nameRef) => Context.GetNameRef(this, name, out nameRef);
    internal bool GetNameRefImpl(string name, out JNameRef nameRef);
    public JNameRef GetNameRef(string name) {
        if (GetNameRef(name, out var nameRef))
            return nameRef;
        throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");
    }

    protected internal void UpdateContext(IContextMerger merger){}
}

public interface IJMethod : IJExpr{
    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v);
    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);
}

public interface IJType : IJExpr{
    public string Name { get; }
    public JTypeType Type { get; }
    public bool VisitFields(Func<IJField, bool> v);
    public bool VisitConstructors(Func<IJMethod, bool> v);
}

public interface IJField {
    public string Name { get; }
    public IJType Type { get; }
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; }
    protected internal void UpdateContext(JStringRef[] str2strmap, int typeOffset, int moduleOffset){}
    public bool IsConst => Modifiers.HasFlag(JFieldFlags.Const);

    public bool IsGlobal => Modifiers.HasFlag(JFieldFlags.Global);

    public bool IsLocal => !IsGlobal;
}

public interface IJFunction {
    public string Name { get; }

    public bool VisitMethods(Func<IJMethod, bool> v);
}

public interface IJName : IJField {
    public object ObjectValue { get; set; }
    public JNameRef NameRef { get; }
    IJExpr IJField.Parent => Type.Parent;
}

public interface IJName<T> : IJName
{
    public T Value { get; set; }
}
runtime.core
runtime
core
[Flags]
public enum JExprFlags : byte {
    None = 0
}
[Flags]
Flags
Flags
: byte
byte
byte
None = 0
= 0
0
[Flags]
public enum JMethodFlags : byte {
    None = 0,
    Inline = 1 << 0
}
[Flags]
Flags
Flags
: byte
byte
byte
None = 0
= 0
0
Inline = 1 << 0
= 1 << 0
1 << 0
1
0
[Flags]
public enum JModuleFlags : byte
{
    None = 0,
    Bare = 1 << 0
}
[Flags]
Flags
Flags
: byte
byte
byte
None = 0
= 0
0
Bare = 1 << 0
= 1 << 0
1 << 0
1
0
[Flags]
public enum JFieldFlags : byte{
    None = 0,
    Const = 1 << 0,
    Global = 1 << 1,
}
[Flags]
Flags
Flags
: byte
byte
byte
None = 0
= 0
0
Const = 1 << 0
= 1 << 0
1 << 0
1
0
Global = 1 << 1
= 1 << 1
1 << 1
1
1
public enum JTypeType : byte{
    None,
    Abstract,
    Mutable,
    Struct,
    Primitive
}
: byte
byte
byte
None
Abstract
Mutable
Struct
Primitive
public interface IJCodeContext {
    public string GetString(JStringRef i);
    public IJModule GetCtxModule(int i);
    public IJType GetCtxType(int i);
    public JStringRef GetStringIndex(string s);
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        IJExpr v = e;
        while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
        nameRef = default;
        return false;
    }
    
    public IJField GetNameField(IJExpr e, JNameRef nameRef)  {
        if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
        return e.GetNameFieldImpl(nameRef);
    }
}
public string GetString(JStringRef i);
string
(JStringRef i)
JStringRef i
JStringRef
public IJModule GetCtxModule(int i);
IJModule
(int i)
int i
int
public IJType GetCtxType(int i);
IJType
(int i)
int i
int
public JStringRef GetStringIndex(string s);
JStringRef
(string s)
string s
string
public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        IJExpr v = e;
        while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
        nameRef = default;
        return false;
    }
bool
(IJExpr e, string name, out JNameRef nameRef)
IJExpr e
IJExpr
string name
string
out JNameRef nameRef
JNameRef
{
        IJExpr v = e;
        while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
        nameRef = default;
        return false;
    }
IJExpr v = e;
IJExpr v = e
IJExpr
v = e
= e
e
while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
v != null
v
null
{
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
if (GetNameRef(v, name, out nameRef))
                return true;
GetNameRef(v, name, out nameRef)
GetNameRef
(v, name, out nameRef)
v
v
name
name
out nameRef
nameRef
return true;
true
v = v.Parent;
v = v.Parent
v
v.Parent
v
Parent
nameRef = default;
nameRef = default
nameRef
default
return false;
false
public IJField GetNameField(IJExpr e, JNameRef nameRef)  {
        if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
        return e.GetNameFieldImpl(nameRef);
    }
IJField
(IJExpr e, JNameRef nameRef)
IJExpr e
IJExpr
JNameRef nameRef
JNameRef
{
        if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
        return e.GetNameFieldImpl(nameRef);
    }
if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
nameRef.CompileTimeExprStackDelta != 0
nameRef.CompileTimeExprStackDelta
nameRef
CompileTimeExprStackDelta
0
return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)))
GetNameField
(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)))
e.Parent
e.Parent
e
Parent
new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1))
new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1))
(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1))
nameRef.CompileTimeNameRefIndex
nameRef.CompileTimeNameRefIndex
nameRef
CompileTimeNameRefIndex
(ushort)(nameRef.CompileTimeExprStackDelta - 1)
(ushort)(nameRef.CompileTimeExprStackDelta - 1)
ushort
(nameRef.CompileTimeExprStackDelta - 1)
nameRef.CompileTimeExprStackDelta - 1
nameRef.CompileTimeExprStackDelta
nameRef
CompileTimeExprStackDelta
1
return e.GetNameFieldImpl(nameRef);
e.GetNameFieldImpl(nameRef)
e.GetNameFieldImpl
e
GetNameFieldImpl
(nameRef)
nameRef
nameRef
public interface IJCodeExecutionContext : IJCodeContext{
    public void EnterModule(IJModule m);
    public void ExitModule();
    public void EnterExpr(IJExpr e);
    public void ExitExpr();
    public IJExpr GetExpr(int i);
    public IJModule CurrentModule { get; }
    public IJExpr CurrentExpr { get; }
}
: IJCodeContext
IJCodeContext
IJCodeContext
public void EnterModule(IJModule m);
void
(IJModule m)
IJModule m
IJModule
public void ExitModule();
void
()
public void EnterExpr(IJExpr e);
void
(IJExpr e)
IJExpr e
IJExpr
public void ExitExpr();
void
()
public IJExpr GetExpr(int i);
IJExpr
(int i)
int i
int
public IJModule CurrentModule { get; }
IJModule
{ get; }
get;
public IJExpr CurrentExpr { get; }
IJExpr
{ get; }
get;
public interface IJModule : IJExpr
{
    public string Name { get; }
    IJModule IJExpr.Module => this;
    public IJModule ParentModule => Parent.Module;
    public JModuleFlags ModuleModifiers { get; }
    public bool IsBare => ModuleModifiers.HasFlag(JModuleFlags.Bare);
    public bool GetNameV<T>(JNameRef r, out T t);
    public bool GetName(JNameRef r, out object o) => GetNameV(r, out o);
}
: IJExpr
IJExpr
IJExpr
public string Name { get; }
string
{ get; }
get;
IJModule IJExpr.Module => this;
IJModule
IJExpr.
IJExpr
=> this
this
public IJModule ParentModule => Parent.Module;
IJModule
=> Parent.Module
Parent.Module
Parent
Module
public JModuleFlags ModuleModifiers { get; }
JModuleFlags
{ get; }
get;
public bool IsBare => ModuleModifiers.HasFlag(JModuleFlags.Bare);
bool
=> ModuleModifiers.HasFlag(JModuleFlags.Bare)
ModuleModifiers.HasFlag(JModuleFlags.Bare)
ModuleModifiers.HasFlag
ModuleModifiers
HasFlag
(JModuleFlags.Bare)
JModuleFlags.Bare
JModuleFlags.Bare
JModuleFlags
Bare
public bool GetNameV<T>(JNameRef r, out T t);
bool
<T>
T
(JNameRef r, out T t)
JNameRef r
JNameRef
out T t
T
public bool GetName(JNameRef r, out object o) => GetNameV(r, out o);
bool
(JNameRef r, out object o)
JNameRef r
JNameRef
out object o
object
=> GetNameV(r, out o)
GetNameV(r, out o)
GetNameV
(r, out o)
r
r
out o
o
public interface IContextMerger : Reader.IJILVisitor {
    public JStringRef GetNewString(JStringRef str);
    public int GetNewType(int oldType);
    public int GetNewModule(int oldModule);
}
: Reader.IJILVisitor
Reader.IJILVisitor
Reader.IJILVisitor
Reader
IJILVisitor
public JStringRef GetNewString(JStringRef str);
JStringRef
(JStringRef str)
JStringRef str
JStringRef
public int GetNewType(int oldType);
int
(int oldType)
int oldType
int
public int GetNewModule(int oldModule);
int
(int oldModule)
int oldModule
int
public interface IJExpr {
    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; }
    public IJModule Module => Parent.Module;
    public IJCodeContext Context => Parent.Context;
    public bool VisitVariables(Func<IJField, bool> v);
    public bool VisitNames(Func<IJField, object, bool> v);
    public IJField GetNameField(JNameRef nameRef) => Context.GetNameField(this, nameRef);
    internal IJField GetNameFieldImpl(JNameRef nameRef);
    
    public bool GetNameRef(string name, out JNameRef nameRef) => Context.GetNameRef(this, name, out nameRef);
    internal bool GetNameRefImpl(string name, out JNameRef nameRef);
    public JNameRef GetNameRef(string name) {
        if (GetNameRef(name, out var nameRef))
            return nameRef;
        throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");
    }

    protected internal void UpdateContext(IContextMerger merger){}
}
public JExprFlags Modifiers { get; }
JExprFlags
{ get; }
get;
public IJExpr Parent { get; }
IJExpr
{ get; }
get;
public IJModule Module => Parent.Module;
IJModule
=> Parent.Module
Parent.Module
Parent
Module
public IJCodeContext Context => Parent.Context;
IJCodeContext
=> Parent.Context
Parent.Context
Parent
Context
public bool VisitVariables(Func<IJField, bool> v);
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
public bool VisitNames(Func<IJField, object, bool> v);
bool
(Func<IJField, object, bool> v)
Func<IJField, object, bool> v
Func<IJField, object, bool>
<IJField, object, bool>
IJField
object
bool
public IJField GetNameField(JNameRef nameRef) => Context.GetNameField(this, nameRef);
IJField
(JNameRef nameRef)
JNameRef nameRef
JNameRef
=> Context.GetNameField(this, nameRef)
Context.GetNameField(this, nameRef)
Context.GetNameField
Context
GetNameField
(this, nameRef)
this
this
nameRef
nameRef
internal IJField GetNameFieldImpl(JNameRef nameRef);
IJField
(JNameRef nameRef)
JNameRef nameRef
JNameRef
public bool GetNameRef(string name, out JNameRef nameRef) => Context.GetNameRef(this, name, out nameRef);
bool
(string name, out JNameRef nameRef)
string name
string
out JNameRef nameRef
JNameRef
=> Context.GetNameRef(this, name, out nameRef)
Context.GetNameRef(this, name, out nameRef)
Context.GetNameRef
Context
GetNameRef
(this, name, out nameRef)
this
this
name
name
out nameRef
nameRef
internal bool GetNameRefImpl(string name, out JNameRef nameRef);
bool
(string name, out JNameRef nameRef)
string name
string
out JNameRef nameRef
JNameRef
public JNameRef GetNameRef(string name) {
        if (GetNameRef(name, out var nameRef))
            return nameRef;
        throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");
    }
JNameRef
(string name)
string name
string
{
        if (GetNameRef(name, out var nameRef))
            return nameRef;
        throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");
    }
if (GetNameRef(name, out var nameRef))
            return nameRef;
GetNameRef(name, out var nameRef)
GetNameRef
(name, out var nameRef)
name
name
out var nameRef
var nameRef
var
nameRef
return nameRef;
nameRef
throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");
new JuliaException("Unable to Create Name Reference \"" + name + "\"")
JuliaException
("Unable to Create Name Reference \"" + name + "\"")
"Unable to Create Name Reference \"" + name + "\""
"Unable to Create Name Reference \"" + name + "\""
"Unable to Create Name Reference \"" + name
"Unable to Create Name Reference \""
name
"\""
protected internal void UpdateContext(IContextMerger merger){}
void
(IContextMerger merger)
IContextMerger merger
IContextMerger
{}
public interface IJMethod : IJExpr{
    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v);
    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);
}
: IJExpr
IJExpr
IJExpr
public JMethodFlags MethodModifiers { get; }
JMethodFlags
{ get; }
get;
public bool VisitParameters(Func<IJField, bool> v);
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);
bool
=> MethodModifiers.HasFlag(JMethodFlags.Inline)
MethodModifiers.HasFlag(JMethodFlags.Inline)
MethodModifiers.HasFlag
MethodModifiers
HasFlag
(JMethodFlags.Inline)
JMethodFlags.Inline
JMethodFlags.Inline
JMethodFlags
Inline
public interface IJType : IJExpr{
    public string Name { get; }
    public JTypeType Type { get; }
    public bool VisitFields(Func<IJField, bool> v);
    public bool VisitConstructors(Func<IJMethod, bool> v);
}
: IJExpr
IJExpr
IJExpr
public string Name { get; }
string
{ get; }
get;
public JTypeType Type { get; }
JTypeType
{ get; }
get;
public bool VisitFields(Func<IJField, bool> v);
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
public bool VisitConstructors(Func<IJMethod, bool> v);
bool
(Func<IJMethod, bool> v)
Func<IJMethod, bool> v
Func<IJMethod, bool>
<IJMethod, bool>
IJMethod
bool
public interface IJField {
    public string Name { get; }
    public IJType Type { get; }
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; }
    protected internal void UpdateContext(JStringRef[] str2strmap, int typeOffset, int moduleOffset){}
    public bool IsConst => Modifiers.HasFlag(JFieldFlags.Const);

    public bool IsGlobal => Modifiers.HasFlag(JFieldFlags.Global);

    public bool IsLocal => !IsGlobal;
}
public string Name { get; }
string
{ get; }
get;
public IJType Type { get; }
IJType
{ get; }
get;
public JFieldFlags Modifiers { get; }
JFieldFlags
{ get; }
get;
public IJExpr Parent { get; }
IJExpr
{ get; }
get;
protected internal void UpdateContext(JStringRef[] str2strmap, int typeOffset, int moduleOffset){}
void
(JStringRef[] str2strmap, int typeOffset, int moduleOffset)
JStringRef[] str2strmap
JStringRef[]
JStringRef
[]

int typeOffset
int
int moduleOffset
int
{}
public bool IsConst => Modifiers.HasFlag(JFieldFlags.Const);
bool
=> Modifiers.HasFlag(JFieldFlags.Const)
Modifiers.HasFlag(JFieldFlags.Const)
Modifiers.HasFlag
Modifiers
HasFlag
(JFieldFlags.Const)
JFieldFlags.Const
JFieldFlags.Const
JFieldFlags
Const
public bool IsGlobal => Modifiers.HasFlag(JFieldFlags.Global);
bool
=> Modifiers.HasFlag(JFieldFlags.Global)
Modifiers.HasFlag(JFieldFlags.Global)
Modifiers.HasFlag
Modifiers
HasFlag
(JFieldFlags.Global)
JFieldFlags.Global
JFieldFlags.Global
JFieldFlags
Global
public bool IsLocal => !IsGlobal;
bool
=> !IsGlobal
!IsGlobal
IsGlobal
public interface IJFunction {
    public string Name { get; }

    public bool VisitMethods(Func<IJMethod, bool> v);
}
public string Name { get; }
string
{ get; }
get;
public bool VisitMethods(Func<IJMethod, bool> v);
bool
(Func<IJMethod, bool> v)
Func<IJMethod, bool> v
Func<IJMethod, bool>
<IJMethod, bool>
IJMethod
bool
public interface IJName : IJField {
    public object ObjectValue { get; set; }
    public JNameRef NameRef { get; }
    IJExpr IJField.Parent => Type.Parent;
}
: IJField
IJField
IJField
public object ObjectValue { get; set; }
object
{ get; set; }
get;
set;
public JNameRef NameRef { get; }
JNameRef
{ get; }
get;
IJExpr IJField.Parent => Type.Parent;
IJExpr
IJField.
IJField
=> Type.Parent
Type.Parent
Type
Parent
public interface IJName<T> : IJName
{
    public T Value { get; set; }
}
<T>
T
: IJName
IJName
IJName
public T Value { get; set; }
T
{ get; set; }
get;
set;
using System;
using runtime.core.JIL;
using runtime.Utils;

namespace runtime.core.Runtime;

public class JRuntimeContext : JObject, IJCodeContext {

    internal MInternContainer<string> Strings { get; }
    internal IJModule[] Modules;
    internal IJType[] Types;

    public JRuntimeContext(string[] strings, IJModule[] modules, IJType[] types) {
        Strings = new(new(strings));
        Modules = modules;
        Types = types;
    }

    public string GetString(int i) => Strings.Get(i);
    public IJModule GetCtxModule(int i) => Modules[i];
    public IJType GetCtxType(int i) => Types[i];
    public int GetStringIndex(string s) => throw new NotImplementedException();

    public void MergeContext(string[] strings, IJModule[] modules, IJType[] types) {
        lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
    }
    
    
}

internal class JRuntimeMerger : IContextMerger {
    private readonly int[] _s;
    private readonly int _mDelta;
    private readonly int _tyDelta;

    internal JRuntimeMerger(int[] s, int mDelta, int tyDelta) {
        _s = s;
        _mDelta = mDelta;
        _tyDelta = tyDelta;
    }
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => loadedTypeIndex = GetNewType(loadedTypeIndex);

    public JStringRef GetNewString(JStringRef str) => _s[str];
    public int GetNewType(int oldType) => oldType + _tyDelta;
    public int GetNewModule(int oldModule) => oldModule + _mDelta;
}


using System;
System
using runtime.core.JIL;
runtime.core.JIL
runtime.core
runtime
core
JIL
using runtime.Utils;
runtime.Utils
runtime
Utils
namespace runtime.core.Runtime;

public class JRuntimeContext : JObject, IJCodeContext {

    internal MInternContainer<string> Strings { get; }
    internal IJModule[] Modules;
    internal IJType[] Types;

    public JRuntimeContext(string[] strings, IJModule[] modules, IJType[] types) {
        Strings = new(new(strings));
        Modules = modules;
        Types = types;
    }

    public string GetString(int i) => Strings.Get(i);
    public IJModule GetCtxModule(int i) => Modules[i];
    public IJType GetCtxType(int i) => Types[i];
    public int GetStringIndex(string s) => throw new NotImplementedException();

    public void MergeContext(string[] strings, IJModule[] modules, IJType[] types) {
        lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
    }
    
    
}

internal class JRuntimeMerger : IContextMerger {
    private readonly int[] _s;
    private readonly int _mDelta;
    private readonly int _tyDelta;

    internal JRuntimeMerger(int[] s, int mDelta, int tyDelta) {
        _s = s;
        _mDelta = mDelta;
        _tyDelta = tyDelta;
    }
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => loadedTypeIndex = GetNewType(loadedTypeIndex);

    public JStringRef GetNewString(JStringRef str) => _s[str];
    public int GetNewType(int oldType) => oldType + _tyDelta;
    public int GetNewModule(int oldModule) => oldModule + _mDelta;
}
runtime.core.Runtime
runtime.core
runtime
core
Runtime
public class JRuntimeContext : JObject, IJCodeContext {

    internal MInternContainer<string> Strings { get; }
    internal IJModule[] Modules;
    internal IJType[] Types;

    public JRuntimeContext(string[] strings, IJModule[] modules, IJType[] types) {
        Strings = new(new(strings));
        Modules = modules;
        Types = types;
    }

    public string GetString(int i) => Strings.Get(i);
    public IJModule GetCtxModule(int i) => Modules[i];
    public IJType GetCtxType(int i) => Types[i];
    public int GetStringIndex(string s) => throw new NotImplementedException();

    public void MergeContext(string[] strings, IJModule[] modules, IJType[] types) {
        lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
    }
    
    
}
: JObject, IJCodeContext
JObject
JObject
IJCodeContext
IJCodeContext
internal MInternContainer<string> Strings { get; }
MInternContainer<string>
<string>
string
{ get; }
get;
internal IJModule[] Modules;
IJModule[] Modules
IJModule[]
IJModule
[]

Modules
internal IJType[] Types;
IJType[] Types
IJType[]
IJType
[]

Types
public JRuntimeContext(string[] strings, IJModule[] modules, IJType[] types) {
        Strings = new(new(strings));
        Modules = modules;
        Types = types;
    }
(string[] strings, IJModule[] modules, IJType[] types)
string[] strings
string[]
string
[]

IJModule[] modules
IJModule[]
IJModule
[]

IJType[] types
IJType[]
IJType
[]

{
        Strings = new(new(strings));
        Modules = modules;
        Types = types;
    }
Strings = new(new(strings));
Strings = new(new(strings))
Strings
new(new(strings))
(new(strings))
new(strings)
new(strings)
(strings)
strings
strings
Modules = modules;
Modules = modules
Modules
modules
Types = types;
Types = types
Types
types
public string GetString(int i) => Strings.Get(i);
string
(int i)
int i
int
=> Strings.Get(i)
Strings.Get(i)
Strings.Get
Strings
Get
(i)
i
i
public IJModule GetCtxModule(int i) => Modules[i];
IJModule
(int i)
int i
int
=> Modules[i]
Modules[i]
Modules
[i]
i
i
public IJType GetCtxType(int i) => Types[i];
IJType
(int i)
int i
int
=> Types[i]
Types[i]
Types
[i]
i
i
public int GetStringIndex(string s) => throw new NotImplementedException();
int
(string s)
string s
string
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public void MergeContext(string[] strings, IJModule[] modules, IJType[] types) {
        lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
    }
void
(string[] strings, IJModule[] modules, IJType[] types)
string[] strings
string[]
string
[]

IJModule[] modules
IJModule[]
IJModule
[]

IJType[] types
IJType[]
IJType
[]

{
        lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
    }
lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
Strings
{
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
JStringRef[] str2strmap = new JStringRef[strings.Length];
JStringRef[] str2strmap = new JStringRef[strings.Length]
JStringRef[]
JStringRef
[]

str2strmap = new JStringRef[strings.Length]
= new JStringRef[strings.Length]
new JStringRef[strings.Length]
JStringRef[strings.Length]
JStringRef
[strings.Length]
strings.Length
strings
Length
for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);
int i = 0
int
i = 0
= 0
0
i < str2strmap.Length
i
str2strmap.Length
str2strmap
Length
i++
i
str2strmap[i] = Strings.Load(strings[i]);
str2strmap[i] = Strings.Load(strings[i])
str2strmap[i]
str2strmap
[i]
i
i
Strings.Load(strings[i])
Strings.Load
Strings
Load
(strings[i])
strings[i]
strings[i]
strings
[i]
i
i
var oldModLen = Modules.Length;
var oldModLen = Modules.Length
var
oldModLen = Modules.Length
= Modules.Length
Modules.Length
Modules
Length
Array.Resize(ref Modules, oldModLen + modules.Length);
Array.Resize(ref Modules, oldModLen + modules.Length)
Array.Resize
Array
Resize
(ref Modules, oldModLen + modules.Length)
ref Modules
Modules
oldModLen + modules.Length
oldModLen + modules.Length
oldModLen
modules.Length
modules
Length
modules.CopyTo(Modules, oldModLen);
modules.CopyTo(Modules, oldModLen)
modules.CopyTo
modules
CopyTo
(Modules, oldModLen)
Modules
Modules
oldModLen
oldModLen
var oldTyLen = Types.Length;
var oldTyLen = Types.Length
var
oldTyLen = Types.Length
= Types.Length
Types.Length
Types
Length
Array.Resize(ref Types, oldTyLen + types.Length);
Array.Resize(ref Types, oldTyLen + types.Length)
Array.Resize
Array
Resize
(ref Types, oldTyLen + types.Length)
ref Types
Types
oldTyLen + types.Length
oldTyLen + types.Length
oldTyLen
types.Length
types
Length
types.CopyTo(Types, oldTyLen);
types.CopyTo(Types, oldTyLen)
types.CopyTo
types
CopyTo
(Types, oldTyLen)
Types
Types
oldTyLen
oldTyLen
Console.WriteLine(this);
Console.WriteLine(this)
Console.WriteLine
Console
WriteLine
(this)
this
this
JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);
JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen)
JRuntimeMerger
merger = new(str2strmap, oldModLen, oldTyLen)
= new(str2strmap, oldModLen, oldTyLen)
new(str2strmap, oldModLen, oldTyLen)
(str2strmap, oldModLen, oldTyLen)
str2strmap
str2strmap
oldModLen
oldModLen
oldTyLen
oldTyLen
foreach (var t in types)
                t.UpdateContext(merger);
var
types
t.UpdateContext(merger);
t.UpdateContext(merger)
t.UpdateContext
t
UpdateContext
(merger)
merger
merger
foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
var
modules
{
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
var jm = (JILModule) m;
var jm = (JILModule) m
var
jm = (JILModule) m
= (JILModule) m
(JILModule) m
JILModule
m
m.UpdateContext(merger);
m.UpdateContext(merger)
m.UpdateContext
m
UpdateContext
(merger)
merger
merger
jm.Ctx = this;
jm.Ctx = this
jm.Ctx
jm
Ctx
this
internal class JRuntimeMerger : IContextMerger {
    private readonly int[] _s;
    private readonly int _mDelta;
    private readonly int _tyDelta;

    internal JRuntimeMerger(int[] s, int mDelta, int tyDelta) {
        _s = s;
        _mDelta = mDelta;
        _tyDelta = tyDelta;
    }
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => loadedTypeIndex = GetNewType(loadedTypeIndex);

    public JStringRef GetNewString(JStringRef str) => _s[str];
    public int GetNewType(int oldType) => oldType + _tyDelta;
    public int GetNewModule(int oldModule) => oldModule + _mDelta;
}
: IContextMerger
IContextMerger
IContextMerger
private readonly int[] _s;
int[] _s
int[]
int
[]

_s
private readonly int _mDelta;
int _mDelta
int
_mDelta
private readonly int _tyDelta;
int _tyDelta
int
_tyDelta
internal JRuntimeMerger(int[] s, int mDelta, int tyDelta) {
        _s = s;
        _mDelta = mDelta;
        _tyDelta = tyDelta;
    }
(int[] s, int mDelta, int tyDelta)
int[] s
int[]
int
[]

int mDelta
int
int tyDelta
int
{
        _s = s;
        _mDelta = mDelta;
        _tyDelta = tyDelta;
    }
_s = s;
_s = s
_s
s
_mDelta = mDelta;
_mDelta = mDelta
_mDelta
mDelta
_tyDelta = tyDelta;
_tyDelta = tyDelta
_tyDelta
tyDelta
public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => loadedTypeIndex = GetNewType(loadedTypeIndex);
void
(IJType loadedType, ref int loadedTypeIndex)
IJType loadedType
IJType
ref int loadedTypeIndex
int
=> loadedTypeIndex = GetNewType(loadedTypeIndex)
loadedTypeIndex = GetNewType(loadedTypeIndex)
loadedTypeIndex
GetNewType(loadedTypeIndex)
GetNewType
(loadedTypeIndex)
loadedTypeIndex
loadedTypeIndex
public JStringRef GetNewString(JStringRef str) => _s[str];
JStringRef
(JStringRef str)
JStringRef str
JStringRef
=> _s[str]
_s[str]
_s
[str]
str
str
public int GetNewType(int oldType) => oldType + _tyDelta;
int
(int oldType)
int oldType
int
=> oldType + _tyDelta
oldType + _tyDelta
oldType
_tyDelta
public int GetNewModule(int oldModule) => oldModule + _mDelta;
int
(int oldModule)
int oldModule
int
=> oldModule + _mDelta
oldModule + _mDelta
oldModule
_mDelta
using System;
using System.IO;

namespace runtime.core;

public interface IJObject{
    public virtual void Print(TextWriter tw)
    {
        var ty = GetType();
        tw.Write(ty.Name);
        tw.Write("[");
        foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
        tw.Write("]");
    }
    

    public void PrintLn(TextWriter tw) {
        tw ??= new StringWriter();
        Print(tw);
        tw.WriteLine();
    }

    [Obsolete]
    public string ToStringImpl()
    {
        var sw = new StringWriter();
        Print(sw);
        return sw.ToString();
    }
}

public class JObject : IJObject
{
    public override string ToString() => ((IJObject) this).ToStringImpl();
}
using System;
System
using System.IO;
System.IO
System
IO
namespace runtime.core;

public interface IJObject{
    public virtual void Print(TextWriter tw)
    {
        var ty = GetType();
        tw.Write(ty.Name);
        tw.Write("[");
        foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
        tw.Write("]");
    }
    

    public void PrintLn(TextWriter tw) {
        tw ??= new StringWriter();
        Print(tw);
        tw.WriteLine();
    }

    [Obsolete]
    public string ToStringImpl()
    {
        var sw = new StringWriter();
        Print(sw);
        return sw.ToString();
    }
}

public class JObject : IJObject
{
    public override string ToString() => ((IJObject) this).ToStringImpl();
}
runtime.core
runtime
core
public interface IJObject{
    public virtual void Print(TextWriter tw)
    {
        var ty = GetType();
        tw.Write(ty.Name);
        tw.Write("[");
        foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
        tw.Write("]");
    }
    

    public void PrintLn(TextWriter tw) {
        tw ??= new StringWriter();
        Print(tw);
        tw.WriteLine();
    }

    [Obsolete]
    public string ToStringImpl()
    {
        var sw = new StringWriter();
        Print(sw);
        return sw.ToString();
    }
}
public virtual void Print(TextWriter tw)
    {
        var ty = GetType();
        tw.Write(ty.Name);
        tw.Write("[");
        foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
        tw.Write("]");
    }
void
(TextWriter tw)
TextWriter tw
TextWriter
{
        var ty = GetType();
        tw.Write(ty.Name);
        tw.Write("[");
        foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
        tw.Write("]");
    }
var ty = GetType();
var ty = GetType()
var
ty = GetType()
= GetType()
GetType()
GetType
()
tw.Write(ty.Name);
tw.Write(ty.Name)
tw.Write
tw
Write
(ty.Name)
ty.Name
ty.Name
ty
Name
tw.Write("[");
tw.Write("[")
tw.Write
tw
Write
("[")
"["
"["
foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
var
ty.GetFields()
ty.GetFields
ty
GetFields
()
{
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
if (f.IsStatic) continue;
f.IsStatic
f
IsStatic
continue;
tw.Write(f.Name);
tw.Write(f.Name)
tw.Write
tw
Write
(f.Name)
f.Name
f.Name
f
Name
tw.Write("=");
tw.Write("=")
tw.Write
tw
Write
("=")
"="
"="
var o = f.GetValue(this);
var o = f.GetValue(this)
var
o = f.GetValue(this)
= f.GetValue(this)
f.GetValue(this)
f.GetValue
f
GetValue
(this)
this
this
if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
o is IJObject j
o
IJObject j
IJObject
j
j.Print(tw);
j.Print(tw)
j.Print
j
Print
(tw)
tw
tw
else 
                tw.Write(o);
tw.Write(o);
tw.Write(o)
tw.Write
tw
Write
(o)
o
o
tw.Write("]");
tw.Write("]")
tw.Write
tw
Write
("]")
"]"
"]"
public void PrintLn(TextWriter tw) {
        tw ??= new StringWriter();
        Print(tw);
        tw.WriteLine();
    }
void
(TextWriter tw)
TextWriter tw
TextWriter
{
        tw ??= new StringWriter();
        Print(tw);
        tw.WriteLine();
    }
tw ??= new StringWriter();
tw ??= new StringWriter()
tw
new StringWriter()
StringWriter
()
Print(tw);
Print(tw)
Print
(tw)
tw
tw
tw.WriteLine();
tw.WriteLine()
tw.WriteLine
tw
WriteLine
()
[Obsolete]
    public string ToStringImpl()
    {
        var sw = new StringWriter();
        Print(sw);
        return sw.ToString();
    }
[Obsolete]
Obsolete
Obsolete
string
()
{
        var sw = new StringWriter();
        Print(sw);
        return sw.ToString();
    }
var sw = new StringWriter();
var sw = new StringWriter()
var
sw = new StringWriter()
= new StringWriter()
new StringWriter()
StringWriter
()
Print(sw);
Print(sw)
Print
(sw)
sw
sw
return sw.ToString();
sw.ToString()
sw.ToString
sw
ToString
()
public class JObject : IJObject
{
    public override string ToString() => ((IJObject) this).ToStringImpl();
}
: IJObject
IJObject
IJObject
public override string ToString() => ((IJObject) this).ToStringImpl();
string
()
=> ((IJObject) this).ToStringImpl()
((IJObject) this).ToStringImpl()
((IJObject) this).ToStringImpl
((IJObject) this)
(IJObject) this
IJObject
this
ToStringImpl
()
global using JContextTypeRef = System.Int32;
global using JContextModuleRef = System.Int32;
using System;
using System.Collections.Generic;
using System.Linq;
using runtime.core.Runtime;
using runtime.Utils;

namespace runtime.core.JIL;

public class JILILGenerator : JObject
{
    public readonly UnsafeStream Code = new();

    private void WriteS<T>(byte p, T data) where T : unmanaged
    {
        Code.Write(p);
        Code.Write(data);
    }

    public void InstantiateType(JILTypeBuilder tb) => WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex);

    internal byte[] Create() => Code.ToByteArray();
}

public class JILExprBuilder : JObject, IJExpr
{
    public readonly JILILGenerator Code = new();
    protected JILExpr CreatedExpr;
    protected readonly MInternContainer<string> Namesnames = new();
    protected readonly List<JILFieldBuilder> Names = new();
    protected readonly List<JILFieldBuilder> Vars = new();

    public IJExpr Parent { get; }
    public JExprFlags Modifiers { get; set; }

    internal JILExprBuilder(IJExpr parent) => Parent = parent;

    public JNameRef AddVariable(JILFieldBuilder f)
    {
        var var = AddName(f.Name);
        Vars.Add(f);
        return var;
    }

    public JNameRef AddName(string name, bool isConst = false, bool isGlobal = false)
    {
        JILFieldBuilder fb = new(name, this);
        fb.IsConst = isConst;
        fb.IsGlobal = isGlobal;
        return AddName(fb);
    }

    public JNameRef AddName(JILFieldBuilder fb)
    {
        var idx = Namesnames.GetIndex(fb.Name);
        if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
        //@DUMP("Adding Name:" + fb.Name + " to " + this)
        Names.Add(fb);
        return new(Namesnames.Load(fb.Name), 0);
    }

    public bool VisitVariables(Func<IJField, bool> v) => Vars.Visit(x => v(x));

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        foreach (var t in Names)
            if (!v(t, null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef)
    {
        var nf = Namesnames.GetIndex(name);
        if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }

        nameRef = default;
        return false;
    }

    internal JILExpr Create()
    {
        if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return CreatedExpr;
    }
}

public struct JILFieldBuilder : IJField
{
    public string Name { get; }
    public IJExpr Parent { get; }
    public JFieldFlags Modifiers { get; set; }
    public JNameRef TypeRef { get; internal set; }

    internal JILFieldBuilder(string name, IJExpr parent)
    {
        Name = name;
        Parent = parent;
        Modifiers = JFieldFlags.None;
        TypeRef = default;
    }

    internal JILField Create() => new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null);

    public IJType Type => throw new JuliaException();

    public bool IsConst
    {
        get => Modifiers.HasFlag(JFieldFlags.Const);
        set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);
    }

    public bool IsGlobal
    {
        set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);
    }

    public bool IsLocal
    {
        set => IsGlobal = !value;
    }

    public override int GetHashCode() => Name.GetHashCode();
    public override string ToString() => Name;
}

public sealed class JILMethodBuilder : JILExprBuilder, IJMethod
{
    private readonly List<JILFieldBuilder> _parameters = new();

    public JMethodFlags MethodModifiers { get; set; }

    internal JILMethodBuilder(IJExpr parent) : base(parent) => MethodModifiers = JMethodFlags.None;

    public JNameRef AddParameter(JILFieldBuilder f)
    {
        //@DUMP("(Parameter)")
        _parameters.Add(f);
        return AddName(f.Name);
    }

    internal new JILMethod Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return (JILMethod)CreatedExpr;
    }

    public bool VisitParameters(Func<IJField, bool> v) => _parameters.Visit(x => v(x));
}

public class JILModuleBuilder : JILExprBuilder, IJModule
{
    public readonly JContextModuleRef CtxModuleIndex;

    public string Name { get; }
    public IJCodeContext Context { get; }
    internal JILContextWriter ContextWriter => Context as JILContextWriter;
    public JModuleFlags ModuleModifiers { get; set; }

    IJModule IJModule.ParentModule => Parent.Module;

    public bool IsBare
    {
        set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);
    }

    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotImplementedException();

    public JILTypeBuilder DefineType(string name)
    {
        //@DUMP("(Type) ")
        var tb = new JILTypeBuilder(name, this);
        AddName(name, true);
        return tb;
    }

    public JILMethodBuilder DefineMethod(string name)
    {
        //@DUMP("(Method) ")
        var mb = new JILMethodBuilder(this);
        AddName(name, true);
        return mb;
    }

    public JILModuleBuilder DefineModule(string name)
    {
        //@DUMP("(Module) ")
        var mb = new JILModuleBuilder(name, this, ContextWriter);
        AddName(name, true);
        return mb;
    }

    internal new JILModule Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }

        return CreatedExpr as JILModule;
    }

    bool IJExpr.GetNameRef(string name, out JNameRef nameRef)
    {
        nameRef = AddName(name);
        return true;
    }

    internal JILModuleBuilder(string name, IJModule parent, JILContextWriter cw) : base(parent)
    {
        Name = name;
        Context = cw;
        ModuleModifiers = JModuleFlags.None;
        CtxModuleIndex = ContextWriter.WriteCtxModule(this);
    }
    
    public override string ToString() => Name;
}

public sealed class JILTypeBuilder : IJType
{
    public readonly JContextTypeRef CtxTypeIndex;
    private readonly List<JILFieldBuilder> _fields = new();
    private readonly List<JILMethodBuilder> _constructors = new();
    private JILType _createdType;

    public IJModule Module { get; }
    public IJExpr Parent => Module;
    public string Name { get; }
    public JTypeType Type { get; set; }

    internal JILTypeBuilder(string name, IJModule parent)
    {
        Name = name;
        CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);
        Type = JTypeType.None;
        Module = parent;
    }

    internal JILContextWriter ContextWriter => Parent.Context as JILContextWriter;

    public bool VisitFields(Func<IJField, bool> v) => _fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.Visit(x => v(x));

    public JNameRef AddField(JILFieldBuilder f)
    {
        var idx = _fields.Count;
        _fields.Add(f);
        return new(idx, 0);
    }

    public JNameRef AddConstructor(JILMethodBuilder c)
    {
        var idx = _constructors.Count;
        _constructors.Add(c);
        return new(-idx, 0);
    }

    internal JILType Create()
    {
        if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }

        return _createdType;
    }

    public JExprFlags Modifiers => JExprFlags.None;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => _fields[nameRef.CompileTimeExprStackDelta];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public override string ToString() => Name;
}

internal class JILContextWriter : JObject, IJCodeContext
{
    public JRuntimeModule ParentModule { get; }
    private readonly MInternContainer<string> _strings = new();
    private readonly List<JILModuleBuilder> _modules = new();
    private readonly List<JILTypeBuilder> _types = new();

    internal JILContextWriter(JRuntimeModule parentModule) => ParentModule = parentModule;

    public JStringRef WriteString(string s) => _strings.Load(s);

    public int WriteCtxModule(JILModuleBuilder mb)
    {
        var midx = _modules.Count;
        _modules.Add(mb);
        return midx;
    }

    public JContextTypeRef WriteCtxType(JILTypeBuilder tb)
    {
        var tidx = _types.Count;
        _types.Add(tb);
        return tidx;
    }

    public void CreateContext(out string[] strings, out IJModule[] modules, out IJType[] types) {
        //@DUMP("Creating Context:" + this)
        modules = _modules.Select(x => (IJModule)x.Create()).ToArray();
        types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();
        strings = _strings.Data.ToArray();
    }

    public string GetString(int i) => _strings.Get(i);
    public IJModule GetCtxModule(int i) => _modules[i];
    public IJType GetCtxType(int i) => _types[i];
    public int GetStringIndex(string s) => _strings.GetIndex(s);
}

public class JILBuilder : JILModuleBuilder {
    public JILBuilder(JRuntimeModule m) : base(m.Name, m, new JILContextWriter(m)) {}

    public JRuntimeExpr CreateExpression() {
        //@DUMP("Generating Runtime Expr:" + this)
        var expr = Create();
        (Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);
        (Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);
        return new JRuntimeExpr(expr, Parent);
    }
}
global using JContextTypeRef = System.Int32;
JContextTypeRef =
JContextTypeRef
System.Int32
System
Int32
global using JContextModuleRef = System.Int32;
JContextModuleRef =
JContextModuleRef
System.Int32
System
Int32
using System;
System
using System.Collections.Generic;
System.Collections.Generic
System.Collections
System
Collections
Generic
using System.Linq;
System.Linq
System
Linq
using runtime.core.Runtime;
runtime.core.Runtime
runtime.core
runtime
core
Runtime
using runtime.Utils;
runtime.Utils
runtime
Utils
namespace runtime.core.JIL;

public class JILILGenerator : JObject
{
    public readonly UnsafeStream Code = new();

    private void WriteS<T>(byte p, T data) where T : unmanaged
    {
        Code.Write(p);
        Code.Write(data);
    }

    public void InstantiateType(JILTypeBuilder tb) => WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex);

    internal byte[] Create() => Code.ToByteArray();
}

public class JILExprBuilder : JObject, IJExpr
{
    public readonly JILILGenerator Code = new();
    protected JILExpr CreatedExpr;
    protected readonly MInternContainer<string> Namesnames = new();
    protected readonly List<JILFieldBuilder> Names = new();
    protected readonly List<JILFieldBuilder> Vars = new();

    public IJExpr Parent { get; }
    public JExprFlags Modifiers { get; set; }

    internal JILExprBuilder(IJExpr parent) => Parent = parent;

    public JNameRef AddVariable(JILFieldBuilder f)
    {
        var var = AddName(f.Name);
        Vars.Add(f);
        return var;
    }

    public JNameRef AddName(string name, bool isConst = false, bool isGlobal = false)
    {
        JILFieldBuilder fb = new(name, this);
        fb.IsConst = isConst;
        fb.IsGlobal = isGlobal;
        return AddName(fb);
    }

    public JNameRef AddName(JILFieldBuilder fb)
    {
        var idx = Namesnames.GetIndex(fb.Name);
        if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
        //@DUMP("Adding Name:" + fb.Name + " to " + this)
        Names.Add(fb);
        return new(Namesnames.Load(fb.Name), 0);
    }

    public bool VisitVariables(Func<IJField, bool> v) => Vars.Visit(x => v(x));

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        foreach (var t in Names)
            if (!v(t, null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef)
    {
        var nf = Namesnames.GetIndex(name);
        if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }

        nameRef = default;
        return false;
    }

    internal JILExpr Create()
    {
        if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return CreatedExpr;
    }
}

public struct JILFieldBuilder : IJField
{
    public string Name { get; }
    public IJExpr Parent { get; }
    public JFieldFlags Modifiers { get; set; }
    public JNameRef TypeRef { get; internal set; }

    internal JILFieldBuilder(string name, IJExpr parent)
    {
        Name = name;
        Parent = parent;
        Modifiers = JFieldFlags.None;
        TypeRef = default;
    }

    internal JILField Create() => new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null);

    public IJType Type => throw new JuliaException();

    public bool IsConst
    {
        get => Modifiers.HasFlag(JFieldFlags.Const);
        set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);
    }

    public bool IsGlobal
    {
        set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);
    }

    public bool IsLocal
    {
        set => IsGlobal = !value;
    }

    public override int GetHashCode() => Name.GetHashCode();
    public override string ToString() => Name;
}

public sealed class JILMethodBuilder : JILExprBuilder, IJMethod
{
    private readonly List<JILFieldBuilder> _parameters = new();

    public JMethodFlags MethodModifiers { get; set; }

    internal JILMethodBuilder(IJExpr parent) : base(parent) => MethodModifiers = JMethodFlags.None;

    public JNameRef AddParameter(JILFieldBuilder f)
    {
        //@DUMP("(Parameter)")
        _parameters.Add(f);
        return AddName(f.Name);
    }

    internal new JILMethod Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return (JILMethod)CreatedExpr;
    }

    public bool VisitParameters(Func<IJField, bool> v) => _parameters.Visit(x => v(x));
}

public class JILModuleBuilder : JILExprBuilder, IJModule
{
    public readonly JContextModuleRef CtxModuleIndex;

    public string Name { get; }
    public IJCodeContext Context { get; }
    internal JILContextWriter ContextWriter => Context as JILContextWriter;
    public JModuleFlags ModuleModifiers { get; set; }

    IJModule IJModule.ParentModule => Parent.Module;

    public bool IsBare
    {
        set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);
    }

    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotImplementedException();

    public JILTypeBuilder DefineType(string name)
    {
        //@DUMP("(Type) ")
        var tb = new JILTypeBuilder(name, this);
        AddName(name, true);
        return tb;
    }

    public JILMethodBuilder DefineMethod(string name)
    {
        //@DUMP("(Method) ")
        var mb = new JILMethodBuilder(this);
        AddName(name, true);
        return mb;
    }

    public JILModuleBuilder DefineModule(string name)
    {
        //@DUMP("(Module) ")
        var mb = new JILModuleBuilder(name, this, ContextWriter);
        AddName(name, true);
        return mb;
    }

    internal new JILModule Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }

        return CreatedExpr as JILModule;
    }

    bool IJExpr.GetNameRef(string name, out JNameRef nameRef)
    {
        nameRef = AddName(name);
        return true;
    }

    internal JILModuleBuilder(string name, IJModule parent, JILContextWriter cw) : base(parent)
    {
        Name = name;
        Context = cw;
        ModuleModifiers = JModuleFlags.None;
        CtxModuleIndex = ContextWriter.WriteCtxModule(this);
    }
    
    public override string ToString() => Name;
}

public sealed class JILTypeBuilder : IJType
{
    public readonly JContextTypeRef CtxTypeIndex;
    private readonly List<JILFieldBuilder> _fields = new();
    private readonly List<JILMethodBuilder> _constructors = new();
    private JILType _createdType;

    public IJModule Module { get; }
    public IJExpr Parent => Module;
    public string Name { get; }
    public JTypeType Type { get; set; }

    internal JILTypeBuilder(string name, IJModule parent)
    {
        Name = name;
        CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);
        Type = JTypeType.None;
        Module = parent;
    }

    internal JILContextWriter ContextWriter => Parent.Context as JILContextWriter;

    public bool VisitFields(Func<IJField, bool> v) => _fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.Visit(x => v(x));

    public JNameRef AddField(JILFieldBuilder f)
    {
        var idx = _fields.Count;
        _fields.Add(f);
        return new(idx, 0);
    }

    public JNameRef AddConstructor(JILMethodBuilder c)
    {
        var idx = _constructors.Count;
        _constructors.Add(c);
        return new(-idx, 0);
    }

    internal JILType Create()
    {
        if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }

        return _createdType;
    }

    public JExprFlags Modifiers => JExprFlags.None;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => _fields[nameRef.CompileTimeExprStackDelta];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public override string ToString() => Name;
}

internal class JILContextWriter : JObject, IJCodeContext
{
    public JRuntimeModule ParentModule { get; }
    private readonly MInternContainer<string> _strings = new();
    private readonly List<JILModuleBuilder> _modules = new();
    private readonly List<JILTypeBuilder> _types = new();

    internal JILContextWriter(JRuntimeModule parentModule) => ParentModule = parentModule;

    public JStringRef WriteString(string s) => _strings.Load(s);

    public int WriteCtxModule(JILModuleBuilder mb)
    {
        var midx = _modules.Count;
        _modules.Add(mb);
        return midx;
    }

    public JContextTypeRef WriteCtxType(JILTypeBuilder tb)
    {
        var tidx = _types.Count;
        _types.Add(tb);
        return tidx;
    }

    public void CreateContext(out string[] strings, out IJModule[] modules, out IJType[] types) {
        //@DUMP("Creating Context:" + this)
        modules = _modules.Select(x => (IJModule)x.Create()).ToArray();
        types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();
        strings = _strings.Data.ToArray();
    }

    public string GetString(int i) => _strings.Get(i);
    public IJModule GetCtxModule(int i) => _modules[i];
    public IJType GetCtxType(int i) => _types[i];
    public int GetStringIndex(string s) => _strings.GetIndex(s);
}

public class JILBuilder : JILModuleBuilder {
    public JILBuilder(JRuntimeModule m) : base(m.Name, m, new JILContextWriter(m)) {}

    public JRuntimeExpr CreateExpression() {
        //@DUMP("Generating Runtime Expr:" + this)
        var expr = Create();
        (Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);
        (Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);
        return new JRuntimeExpr(expr, Parent);
    }
}
runtime.core.JIL
runtime.core
runtime
core
JIL
public class JILILGenerator : JObject
{
    public readonly UnsafeStream Code = new();

    private void WriteS<T>(byte p, T data) where T : unmanaged
    {
        Code.Write(p);
        Code.Write(data);
    }

    public void InstantiateType(JILTypeBuilder tb) => WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex);

    internal byte[] Create() => Code.ToByteArray();
}
: JObject
JObject
JObject
public readonly UnsafeStream Code = new();
UnsafeStream Code = new()
UnsafeStream
Code = new()
= new()
new()
()
private void WriteS<T>(byte p, T data) where T : unmanaged
    {
        Code.Write(p);
        Code.Write(data);
    }
void
<T>
T
(byte p, T data)
byte p
byte
T data
T
where T : unmanaged
T
unmanaged
unmanaged
{
        Code.Write(p);
        Code.Write(data);
    }
Code.Write(p);
Code.Write(p)
Code.Write
Code
Write
(p)
p
p
Code.Write(data);
Code.Write(data)
Code.Write
Code
Write
(data)
data
data
public void InstantiateType(JILTypeBuilder tb) => WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex);
void
(JILTypeBuilder tb)
JILTypeBuilder tb
JILTypeBuilder
=> WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex)
WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex)
WriteS
(JOp.LoadTypeOp, tb.CtxTypeIndex)
JOp.LoadTypeOp
JOp.LoadTypeOp
JOp
LoadTypeOp
tb.CtxTypeIndex
tb.CtxTypeIndex
tb
CtxTypeIndex
internal byte[] Create() => Code.ToByteArray();
byte[]
byte
[]

()
=> Code.ToByteArray()
Code.ToByteArray()
Code.ToByteArray
Code
ToByteArray
()
public class JILExprBuilder : JObject, IJExpr
{
    public readonly JILILGenerator Code = new();
    protected JILExpr CreatedExpr;
    protected readonly MInternContainer<string> Namesnames = new();
    protected readonly List<JILFieldBuilder> Names = new();
    protected readonly List<JILFieldBuilder> Vars = new();

    public IJExpr Parent { get; }
    public JExprFlags Modifiers { get; set; }

    internal JILExprBuilder(IJExpr parent) => Parent = parent;

    public JNameRef AddVariable(JILFieldBuilder f)
    {
        var var = AddName(f.Name);
        Vars.Add(f);
        return var;
    }

    public JNameRef AddName(string name, bool isConst = false, bool isGlobal = false)
    {
        JILFieldBuilder fb = new(name, this);
        fb.IsConst = isConst;
        fb.IsGlobal = isGlobal;
        return AddName(fb);
    }

    public JNameRef AddName(JILFieldBuilder fb)
    {
        var idx = Namesnames.GetIndex(fb.Name);
        if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
        //@DUMP("Adding Name:" + fb.Name + " to " + this)
        Names.Add(fb);
        return new(Namesnames.Load(fb.Name), 0);
    }

    public bool VisitVariables(Func<IJField, bool> v) => Vars.Visit(x => v(x));

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        foreach (var t in Names)
            if (!v(t, null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef)
    {
        var nf = Namesnames.GetIndex(name);
        if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }

        nameRef = default;
        return false;
    }

    internal JILExpr Create()
    {
        if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return CreatedExpr;
    }
}
: JObject, IJExpr
JObject
JObject
IJExpr
IJExpr
public readonly JILILGenerator Code = new();
JILILGenerator Code = new()
JILILGenerator
Code = new()
= new()
new()
()
protected JILExpr CreatedExpr;
JILExpr CreatedExpr
JILExpr
CreatedExpr
protected readonly MInternContainer<string> Namesnames = new();
MInternContainer<string> Namesnames = new()
MInternContainer<string>
<string>
string
Namesnames = new()
= new()
new()
()
protected readonly List<JILFieldBuilder> Names = new();
List<JILFieldBuilder> Names = new()
List<JILFieldBuilder>
<JILFieldBuilder>
JILFieldBuilder
Names = new()
= new()
new()
()
protected readonly List<JILFieldBuilder> Vars = new();
List<JILFieldBuilder> Vars = new()
List<JILFieldBuilder>
<JILFieldBuilder>
JILFieldBuilder
Vars = new()
= new()
new()
()
public IJExpr Parent { get; }
IJExpr
{ get; }
get;
public JExprFlags Modifiers { get; set; }
JExprFlags
{ get; set; }
get;
set;
internal JILExprBuilder(IJExpr parent) => Parent = parent;
(IJExpr parent)
IJExpr parent
IJExpr
=> Parent = parent
Parent = parent
Parent
parent
public JNameRef AddVariable(JILFieldBuilder f)
    {
        var var = AddName(f.Name);
        Vars.Add(f);
        return var;
    }
JNameRef
(JILFieldBuilder f)
JILFieldBuilder f
JILFieldBuilder
{
        var var = AddName(f.Name);
        Vars.Add(f);
        return var;
    }
var var = AddName(f.Name);
var var = AddName(f.Name)
var
var = AddName(f.Name)
= AddName(f.Name)
AddName(f.Name)
AddName
(f.Name)
f.Name
f.Name
f
Name
Vars.Add(f);
Vars.Add(f)
Vars.Add
Vars
Add
(f)
f
f
return var;
var
public JNameRef AddName(string name, bool isConst = false, bool isGlobal = false)
    {
        JILFieldBuilder fb = new(name, this);
        fb.IsConst = isConst;
        fb.IsGlobal = isGlobal;
        return AddName(fb);
    }
JNameRef
(string name, bool isConst = false, bool isGlobal = false)
string name
string
bool isConst = false
bool
= false
false
bool isGlobal = false
bool
= false
false
{
        JILFieldBuilder fb = new(name, this);
        fb.IsConst = isConst;
        fb.IsGlobal = isGlobal;
        return AddName(fb);
    }
JILFieldBuilder fb = new(name, this);
JILFieldBuilder fb = new(name, this)
JILFieldBuilder
fb = new(name, this)
= new(name, this)
new(name, this)
(name, this)
name
name
this
this
fb.IsConst = isConst;
fb.IsConst = isConst
fb.IsConst
fb
IsConst
isConst
fb.IsGlobal = isGlobal;
fb.IsGlobal = isGlobal
fb.IsGlobal
fb
IsGlobal
isGlobal
return AddName(fb);
AddName(fb)
AddName
(fb)
fb
fb
public JNameRef AddName(JILFieldBuilder fb)
    {
        var idx = Namesnames.GetIndex(fb.Name);
        if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
        //@DUMP("Adding Name:" + fb.Name + " to " + this)
        Names.Add(fb);
        return new(Namesnames.Load(fb.Name), 0);
    }
JNameRef
(JILFieldBuilder fb)
JILFieldBuilder fb
JILFieldBuilder
{
        var idx = Namesnames.GetIndex(fb.Name);
        if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
        //@DUMP("Adding Name:" + fb.Name + " to " + this)
        Names.Add(fb);
        return new(Namesnames.Load(fb.Name), 0);
    }
var idx = Namesnames.GetIndex(fb.Name);
var idx = Namesnames.GetIndex(fb.Name)
var
idx = Namesnames.GetIndex(fb.Name)
= Namesnames.GetIndex(fb.Name)
Namesnames.GetIndex(fb.Name)
Namesnames.GetIndex
Namesnames
GetIndex
(fb.Name)
fb.Name
fb.Name
fb
Name
if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
idx != -1
idx
-1
1
{
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
Names[idx].IsConst
Names[idx]
Names
[idx]
idx
idx
IsConst
throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
new JuliaException("Cannot redefine constant \"" + fb.Name + "\"")
JuliaException
("Cannot redefine constant \"" + fb.Name + "\"")
"Cannot redefine constant \"" + fb.Name + "\""
"Cannot redefine constant \"" + fb.Name + "\""
"Cannot redefine constant \"" + fb.Name
"Cannot redefine constant \""
fb.Name
fb
Name
"\""
Names.Add(fb);
Names.Add(fb)
Names.Add
Names
Add
(fb)
fb
fb
return new(Namesnames.Load(fb.Name), 0);
new(Namesnames.Load(fb.Name), 0)
(Namesnames.Load(fb.Name), 0)
Namesnames.Load(fb.Name)
Namesnames.Load(fb.Name)
Namesnames.Load
Namesnames
Load
(fb.Name)
fb.Name
fb.Name
fb
Name
0
0
public bool VisitVariables(Func<IJField, bool> v) => Vars.Visit(x => v(x));
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
=> Vars.Visit(x => v(x))
Vars.Visit(x => v(x))
Vars.Visit
Vars
Visit
(x => v(x))
x => v(x)
x => v(x)
x
v(x)
v
(x)
x
x
public bool VisitNames(Func<IJField, object, bool> v)
    {
        foreach (var t in Names)
            if (!v(t, null))
                return false;
        return true;
    }
bool
(Func<IJField, object, bool> v)
Func<IJField, object, bool> v
Func<IJField, object, bool>
<IJField, object, bool>
IJField
object
bool
{
        foreach (var t in Names)
            if (!v(t, null))
                return false;
        return true;
    }
foreach (var t in Names)
            if (!v(t, null))
                return false;
var
Names
if (!v(t, null))
                return false;
!v(t, null)
v(t, null)
v
(t, null)
t
t
null
null
return false;
false
return true;
true
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];
IJField
IJExpr.
IJExpr
(JNameRef nameRef)
JNameRef nameRef
JNameRef
=> Names[nameRef.CompileTimeNameRefIndex]
Names[nameRef.CompileTimeNameRefIndex]
Names
[nameRef.CompileTimeNameRefIndex]
nameRef.CompileTimeNameRefIndex
nameRef.CompileTimeNameRefIndex
nameRef
CompileTimeNameRefIndex
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef)
    {
        var nf = Namesnames.GetIndex(name);
        if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }

        nameRef = default;
        return false;
    }
bool
IJExpr.
IJExpr
(string name, out JNameRef nameRef)
string name
string
out JNameRef nameRef
JNameRef
{
        var nf = Namesnames.GetIndex(name);
        if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }

        nameRef = default;
        return false;
    }
var nf = Namesnames.GetIndex(name);
var nf = Namesnames.GetIndex(name)
var
nf = Namesnames.GetIndex(name)
= Namesnames.GetIndex(name)
Namesnames.GetIndex(name)
Namesnames.GetIndex
Namesnames
GetIndex
(name)
name
name
if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }
nf != -1
nf
-1
1
{
            nameRef = new(nf, 0);
            return true;
        }
nameRef = new(nf, 0);
nameRef = new(nf, 0)
nameRef
new(nf, 0)
(nf, 0)
nf
nf
0
0
return true;
true
nameRef = default;
nameRef = default
nameRef
default
return false;
false
internal JILExpr Create()
    {
        if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return CreatedExpr;
    }
JILExpr
()
{
        if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return CreatedExpr;
    }
if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }
CreatedExpr == null
CreatedExpr
null
{
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }
var code = Code.Create();
var code = Code.Create()
var
code = Code.Create()
= Code.Create()
Code.Create()
Code.Create
Code
Create
()
var names = Names.Select(x => x.Create()).ToArray();
var names = Names.Select(x => x.Create()).ToArray()
var
names = Names.Select(x => x.Create()).ToArray()
= Names.Select(x => x.Create()).ToArray()
Names.Select(x => x.Create()).ToArray()
Names.Select(x => x.Create()).ToArray
Names.Select(x => x.Create())
Names.Select
Names
Select
(x => x.Create())
x => x.Create()
x => x.Create()
x
x.Create()
x.Create
x
Create
()
ToArray
()
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
var
vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
= Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))
Vars.Select
Vars
Select
(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)
x
new JNameRef(Namesnames.GetIndex(x.Name), 0)
JNameRef
(Namesnames.GetIndex(x.Name), 0)
Namesnames.GetIndex(x.Name)
Namesnames.GetIndex(x.Name)
Namesnames.GetIndex
Namesnames
GetIndex
(x.Name)
x.Name
x.Name
x
Name
0
0
ToArray
()
CreatedExpr = new(Modifiers, code, vt, names, null);
CreatedExpr = new(Modifiers, code, vt, names, null)
CreatedExpr
new(Modifiers, code, vt, names, null)
(Modifiers, code, vt, names, null)
Modifiers
Modifiers
code
code
vt
vt
names
names
null
null
for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
int i = 0
int
i = 0
= 0
0
i < names.Length
i
names.Length
names
Length
i++
i
names[i].Parent = CreatedExpr;
names[i].Parent = CreatedExpr
names[i].Parent
names[i]
names
[i]
i
i
Parent
CreatedExpr
return CreatedExpr;
CreatedExpr
public struct JILFieldBuilder : IJField
{
    public string Name { get; }
    public IJExpr Parent { get; }
    public JFieldFlags Modifiers { get; set; }
    public JNameRef TypeRef { get; internal set; }

    internal JILFieldBuilder(string name, IJExpr parent)
    {
        Name = name;
        Parent = parent;
        Modifiers = JFieldFlags.None;
        TypeRef = default;
    }

    internal JILField Create() => new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null);

    public IJType Type => throw new JuliaException();

    public bool IsConst
    {
        get => Modifiers.HasFlag(JFieldFlags.Const);
        set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);
    }

    public bool IsGlobal
    {
        set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);
    }

    public bool IsLocal
    {
        set => IsGlobal = !value;
    }

    public override int GetHashCode() => Name.GetHashCode();
    public override string ToString() => Name;
}
: IJField
IJField
IJField
public string Name { get; }
string
{ get; }
get;
public IJExpr Parent { get; }
IJExpr
{ get; }
get;
public JFieldFlags Modifiers { get; set; }
JFieldFlags
{ get; set; }
get;
set;
public JNameRef TypeRef { get; internal set; }
JNameRef
{ get; internal set; }
get;
internal set;
internal JILFieldBuilder(string name, IJExpr parent)
    {
        Name = name;
        Parent = parent;
        Modifiers = JFieldFlags.None;
        TypeRef = default;
    }
(string name, IJExpr parent)
string name
string
IJExpr parent
IJExpr
{
        Name = name;
        Parent = parent;
        Modifiers = JFieldFlags.None;
        TypeRef = default;
    }
Name = name;
Name = name
Name
name
Parent = parent;
Parent = parent
Parent
parent
Modifiers = JFieldFlags.None;
Modifiers = JFieldFlags.None
Modifiers
JFieldFlags.None
JFieldFlags
None
TypeRef = default;
TypeRef = default
TypeRef
default
internal JILField Create() => new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null);
JILField
()
=> new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null)
new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null)
((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null)
(Parent.Context as JILContextWriter).WriteString(Name)
(Parent.Context as JILContextWriter).WriteString(Name)
(Parent.Context as JILContextWriter).WriteString
(Parent.Context as JILContextWriter)
Parent.Context as JILContextWriter
Parent.Context
Parent
Context
JILContextWriter
WriteString
(Name)
Name
Name
Modifiers
Modifiers
TypeRef
TypeRef
null
null
public IJType Type => throw new JuliaException();
IJType
=> throw new JuliaException()
throw new JuliaException()
new JuliaException()
JuliaException
()
public bool IsConst
    {
        get => Modifiers.HasFlag(JFieldFlags.Const);
        set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);
    }
bool
{
        get => Modifiers.HasFlag(JFieldFlags.Const);
        set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);
    }
get => Modifiers.HasFlag(JFieldFlags.Const);
=> Modifiers.HasFlag(JFieldFlags.Const)
Modifiers.HasFlag(JFieldFlags.Const)
Modifiers.HasFlag
Modifiers
HasFlag
(JFieldFlags.Const)
JFieldFlags.Const
JFieldFlags.Const
JFieldFlags
Const
set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);
=> Modifiers = Modifiers.Set(JFieldFlags.Const, value)
Modifiers = Modifiers.Set(JFieldFlags.Const, value)
Modifiers
Modifiers.Set(JFieldFlags.Const, value)
Modifiers.Set
Modifiers
Set
(JFieldFlags.Const, value)
JFieldFlags.Const
JFieldFlags.Const
JFieldFlags
Const
value
value
public bool IsGlobal
    {
        set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);
    }
bool
{
        set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);
    }
set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);
=> Modifiers = Modifiers.Set(JFieldFlags.Global, value)
Modifiers = Modifiers.Set(JFieldFlags.Global, value)
Modifiers
Modifiers.Set(JFieldFlags.Global, value)
Modifiers.Set
Modifiers
Set
(JFieldFlags.Global, value)
JFieldFlags.Global
JFieldFlags.Global
JFieldFlags
Global
value
value
public bool IsLocal
    {
        set => IsGlobal = !value;
    }
bool
{
        set => IsGlobal = !value;
    }
set => IsGlobal = !value;
=> IsGlobal = !value
IsGlobal = !value
IsGlobal
!value
value
public override int GetHashCode() => Name.GetHashCode();
int
()
=> Name.GetHashCode()
Name.GetHashCode()
Name.GetHashCode
Name
GetHashCode
()
public override string ToString() => Name;
string
()
=> Name
Name
public sealed class JILMethodBuilder : JILExprBuilder, IJMethod
{
    private readonly List<JILFieldBuilder> _parameters = new();

    public JMethodFlags MethodModifiers { get; set; }

    internal JILMethodBuilder(IJExpr parent) : base(parent) => MethodModifiers = JMethodFlags.None;

    public JNameRef AddParameter(JILFieldBuilder f)
    {
        //@DUMP("(Parameter)")
        _parameters.Add(f);
        return AddName(f.Name);
    }

    internal new JILMethod Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return (JILMethod)CreatedExpr;
    }

    public bool VisitParameters(Func<IJField, bool> v) => _parameters.Visit(x => v(x));
}
: JILExprBuilder, IJMethod
JILExprBuilder
JILExprBuilder
IJMethod
IJMethod
private readonly List<JILFieldBuilder> _parameters = new();
List<JILFieldBuilder> _parameters = new()
List<JILFieldBuilder>
<JILFieldBuilder>
JILFieldBuilder
_parameters = new()
= new()
new()
()
public JMethodFlags MethodModifiers { get; set; }
JMethodFlags
{ get; set; }
get;
set;
internal JILMethodBuilder(IJExpr parent) : base(parent) => MethodModifiers = JMethodFlags.None;
(IJExpr parent)
IJExpr parent
IJExpr
: base(parent)
(parent)
parent
parent
=> MethodModifiers = JMethodFlags.None
MethodModifiers = JMethodFlags.None
MethodModifiers
JMethodFlags.None
JMethodFlags
None
public JNameRef AddParameter(JILFieldBuilder f)
    {
        //@DUMP("(Parameter)")
        _parameters.Add(f);
        return AddName(f.Name);
    }
JNameRef
(JILFieldBuilder f)
JILFieldBuilder f
JILFieldBuilder
{
        //@DUMP("(Parameter)")
        _parameters.Add(f);
        return AddName(f.Name);
    }
_parameters.Add(f);
_parameters.Add(f)
_parameters.Add
_parameters
Add
(f)
f
f
return AddName(f.Name);
AddName(f.Name)
AddName
(f.Name)
f.Name
f.Name
f
Name
internal new JILMethod Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return (JILMethod)CreatedExpr;
    }
JILMethod
()
{
        if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return (JILMethod)CreatedExpr;
    }
if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }
CreatedExpr == null
CreatedExpr
null
{
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }
var code = Code.Create();
var code = Code.Create()
var
code = Code.Create()
= Code.Create()
Code.Create()
Code.Create
Code
Create
()
var names = Names.Select(x => x.Create()).ToArray();
var names = Names.Select(x => x.Create()).ToArray()
var
names = Names.Select(x => x.Create()).ToArray()
= Names.Select(x => x.Create()).ToArray()
Names.Select(x => x.Create()).ToArray()
Names.Select(x => x.Create()).ToArray
Names.Select(x => x.Create())
Names.Select
Names
Select
(x => x.Create())
x => x.Create()
x => x.Create()
x
x.Create()
x.Create
x
Create
()
ToArray
()
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
var
vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
= Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))
Vars.Select
Vars
Select
(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)
x
new JNameRef(Namesnames.GetIndex(x.Name), 0)
JNameRef
(Namesnames.GetIndex(x.Name), 0)
Namesnames.GetIndex(x.Name)
Namesnames.GetIndex(x.Name)
Namesnames.GetIndex
Namesnames
GetIndex
(x.Name)
x.Name
x.Name
x
Name
0
0
ToArray
()
var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
var
pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
= _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
_parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
_parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray
_parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))
_parameters.Select
_parameters
Select
(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)
x
new JNameRef(Namesnames.GetIndex(x.Name), 0)
JNameRef
(Namesnames.GetIndex(x.Name), 0)
Namesnames.GetIndex(x.Name)
Namesnames.GetIndex(x.Name)
Namesnames.GetIndex
Namesnames
GetIndex
(x.Name)
x.Name
x.Name
x
Name
0
0
ToArray
()
CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);
CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null)
CreatedExpr
new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null)
JILMethod
(MethodModifiers, pt, Modifiers, code, vt, names, null)
MethodModifiers
MethodModifiers
pt
pt
Modifiers
Modifiers
code
code
vt
vt
names
names
null
null
for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
int i = 0
int
i = 0
= 0
0
i < names.Length
i
names.Length
names
Length
i++
i
names[i].Parent = CreatedExpr;
names[i].Parent = CreatedExpr
names[i].Parent
names[i]
names
[i]
i
i
Parent
CreatedExpr
return (JILMethod)CreatedExpr;
(JILMethod)CreatedExpr
JILMethod
CreatedExpr
public bool VisitParameters(Func<IJField, bool> v) => _parameters.Visit(x => v(x));
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
=> _parameters.Visit(x => v(x))
_parameters.Visit(x => v(x))
_parameters.Visit
_parameters
Visit
(x => v(x))
x => v(x)
x => v(x)
x
v(x)
v
(x)
x
x
public class JILModuleBuilder : JILExprBuilder, IJModule
{
    public readonly JContextModuleRef CtxModuleIndex;

    public string Name { get; }
    public IJCodeContext Context { get; }
    internal JILContextWriter ContextWriter => Context as JILContextWriter;
    public JModuleFlags ModuleModifiers { get; set; }

    IJModule IJModule.ParentModule => Parent.Module;

    public bool IsBare
    {
        set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);
    }

    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotImplementedException();

    public JILTypeBuilder DefineType(string name)
    {
        //@DUMP("(Type) ")
        var tb = new JILTypeBuilder(name, this);
        AddName(name, true);
        return tb;
    }

    public JILMethodBuilder DefineMethod(string name)
    {
        //@DUMP("(Method) ")
        var mb = new JILMethodBuilder(this);
        AddName(name, true);
        return mb;
    }

    public JILModuleBuilder DefineModule(string name)
    {
        //@DUMP("(Module) ")
        var mb = new JILModuleBuilder(name, this, ContextWriter);
        AddName(name, true);
        return mb;
    }

    internal new JILModule Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }

        return CreatedExpr as JILModule;
    }

    bool IJExpr.GetNameRef(string name, out JNameRef nameRef)
    {
        nameRef = AddName(name);
        return true;
    }

    internal JILModuleBuilder(string name, IJModule parent, JILContextWriter cw) : base(parent)
    {
        Name = name;
        Context = cw;
        ModuleModifiers = JModuleFlags.None;
        CtxModuleIndex = ContextWriter.WriteCtxModule(this);
    }
    
    public override string ToString() => Name;
}
: JILExprBuilder, IJModule
JILExprBuilder
JILExprBuilder
IJModule
IJModule
public readonly JContextModuleRef CtxModuleIndex;
JContextModuleRef CtxModuleIndex
JContextModuleRef
CtxModuleIndex
public string Name { get; }
string
{ get; }
get;
public IJCodeContext Context { get; }
IJCodeContext
{ get; }
get;
internal JILContextWriter ContextWriter => Context as JILContextWriter;
JILContextWriter
=> Context as JILContextWriter
Context as JILContextWriter
Context
JILContextWriter
public JModuleFlags ModuleModifiers { get; set; }
JModuleFlags
{ get; set; }
get;
set;
IJModule IJModule.ParentModule => Parent.Module;
IJModule
IJModule.
IJModule
=> Parent.Module
Parent.Module
Parent
Module
public bool IsBare
    {
        set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);
    }
bool
{
        set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);
    }
set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);
=> ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value)
ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value)
ModuleModifiers
ModuleModifiers.Set(JModuleFlags.Bare, value)
ModuleModifiers.Set
ModuleModifiers
Set
(JModuleFlags.Bare, value)
JModuleFlags.Bare
JModuleFlags.Bare
JModuleFlags
Bare
value
value
public bool GetNameV<T>(JNameRef r, out T t) => throw new NotImplementedException();
bool
<T>
T
(JNameRef r, out T t)
JNameRef r
JNameRef
out T t
T
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public JILTypeBuilder DefineType(string name)
    {
        //@DUMP("(Type) ")
        var tb = new JILTypeBuilder(name, this);
        AddName(name, true);
        return tb;
    }
JILTypeBuilder
(string name)
string name
string
{
        //@DUMP("(Type) ")
        var tb = new JILTypeBuilder(name, this);
        AddName(name, true);
        return tb;
    }
var tb = new JILTypeBuilder(name, this);
var tb = new JILTypeBuilder(name, this)
var
tb = new JILTypeBuilder(name, this)
= new JILTypeBuilder(name, this)
new JILTypeBuilder(name, this)
JILTypeBuilder
(name, this)
name
name
this
this
AddName(name, true);
AddName(name, true)
AddName
(name, true)
name
name
true
true
return tb;
tb
public JILMethodBuilder DefineMethod(string name)
    {
        //@DUMP("(Method) ")
        var mb = new JILMethodBuilder(this);
        AddName(name, true);
        return mb;
    }
JILMethodBuilder
(string name)
string name
string
{
        //@DUMP("(Method) ")
        var mb = new JILMethodBuilder(this);
        AddName(name, true);
        return mb;
    }
var mb = new JILMethodBuilder(this);
var mb = new JILMethodBuilder(this)
var
mb = new JILMethodBuilder(this)
= new JILMethodBuilder(this)
new JILMethodBuilder(this)
JILMethodBuilder
(this)
this
this
AddName(name, true);
AddName(name, true)
AddName
(name, true)
name
name
true
true
return mb;
mb
public JILModuleBuilder DefineModule(string name)
    {
        //@DUMP("(Module) ")
        var mb = new JILModuleBuilder(name, this, ContextWriter);
        AddName(name, true);
        return mb;
    }
JILModuleBuilder
(string name)
string name
string
{
        //@DUMP("(Module) ")
        var mb = new JILModuleBuilder(name, this, ContextWriter);
        AddName(name, true);
        return mb;
    }
var mb = new JILModuleBuilder(name, this, ContextWriter);
var mb = new JILModuleBuilder(name, this, ContextWriter)
var
mb = new JILModuleBuilder(name, this, ContextWriter)
= new JILModuleBuilder(name, this, ContextWriter)
new JILModuleBuilder(name, this, ContextWriter)
JILModuleBuilder
(name, this, ContextWriter)
name
name
this
this
ContextWriter
ContextWriter
AddName(name, true);
AddName(name, true)
AddName
(name, true)
name
name
true
true
return mb;
mb
internal new JILModule Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }

        return CreatedExpr as JILModule;
    }
JILModule
()
{
        if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }

        return CreatedExpr as JILModule;
    }
if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }
CreatedExpr == null
CreatedExpr
null
{
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }
var code = Code.Create();
var code = Code.Create()
var
code = Code.Create()
= Code.Create()
Code.Create()
Code.Create
Code
Create
()
var names = Names.Select(x => x.Create()).ToArray();
var names = Names.Select(x => x.Create()).ToArray()
var
names = Names.Select(x => x.Create()).ToArray()
= Names.Select(x => x.Create()).ToArray()
Names.Select(x => x.Create()).ToArray()
Names.Select(x => x.Create()).ToArray
Names.Select(x => x.Create())
Names.Select
Names
Select
(x => x.Create())
x => x.Create()
x => x.Create()
x
x.Create()
x.Create
x
Create
()
ToArray
()
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
var
vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
= Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))
Vars.Select
Vars
Select
(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)
x
new JNameRef(Namesnames.GetIndex(x.Name), 0)
JNameRef
(Namesnames.GetIndex(x.Name), 0)
Namesnames.GetIndex(x.Name)
Namesnames.GetIndex(x.Name)
Namesnames.GetIndex
Namesnames
GetIndex
(x.Name)
x.Name
x.Name
x
Name
0
0
ToArray
()
CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null)
CreatedExpr
new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null)
JILModule
(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null)
ContextWriter.WriteString(Name)
ContextWriter.WriteString(Name)
ContextWriter.WriteString
ContextWriter
WriteString
(Name)
Name
Name
ModuleModifiers
ModuleModifiers
Modifiers
Modifiers
code
code
vt
vt
names
names
null
null
var parentModule = this is JILBuilder ? Parent : CreatedExpr;
var parentModule = this is JILBuilder ? Parent : CreatedExpr
var
parentModule = this is JILBuilder ? Parent : CreatedExpr
= this is JILBuilder ? Parent : CreatedExpr
this is JILBuilder ? Parent : CreatedExpr
this is JILBuilder
this
JILBuilder
Parent
CreatedExpr
for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
int i = 0
int
i = 0
= 0
0
i < names.Length
i
names.Length
names
Length
i++
i
{
                names[i].Parent = parentModule;
            }
names[i].Parent = parentModule;
names[i].Parent = parentModule
names[i].Parent
names[i]
names
[i]
i
i
Parent
parentModule
return CreatedExpr as JILModule;
CreatedExpr as JILModule
CreatedExpr
JILModule
bool IJExpr.GetNameRef(string name, out JNameRef nameRef)
    {
        nameRef = AddName(name);
        return true;
    }
bool
IJExpr.
IJExpr
(string name, out JNameRef nameRef)
string name
string
out JNameRef nameRef
JNameRef
{
        nameRef = AddName(name);
        return true;
    }
nameRef = AddName(name);
nameRef = AddName(name)
nameRef
AddName(name)
AddName
(name)
name
name
return true;
true
internal JILModuleBuilder(string name, IJModule parent, JILContextWriter cw) : base(parent)
    {
        Name = name;
        Context = cw;
        ModuleModifiers = JModuleFlags.None;
        CtxModuleIndex = ContextWriter.WriteCtxModule(this);
    }
(string name, IJModule parent, JILContextWriter cw)
string name
string
IJModule parent
IJModule
JILContextWriter cw
JILContextWriter
: base(parent)
(parent)
parent
parent
{
        Name = name;
        Context = cw;
        ModuleModifiers = JModuleFlags.None;
        CtxModuleIndex = ContextWriter.WriteCtxModule(this);
    }
Name = name;
Name = name
Name
name
Context = cw;
Context = cw
Context
cw
ModuleModifiers = JModuleFlags.None;
ModuleModifiers = JModuleFlags.None
ModuleModifiers
JModuleFlags.None
JModuleFlags
None
CtxModuleIndex = ContextWriter.WriteCtxModule(this);
CtxModuleIndex = ContextWriter.WriteCtxModule(this)
CtxModuleIndex
ContextWriter.WriteCtxModule(this)
ContextWriter.WriteCtxModule
ContextWriter
WriteCtxModule
(this)
this
this
public override string ToString() => Name;
string
()
=> Name
Name
public sealed class JILTypeBuilder : IJType
{
    public readonly JContextTypeRef CtxTypeIndex;
    private readonly List<JILFieldBuilder> _fields = new();
    private readonly List<JILMethodBuilder> _constructors = new();
    private JILType _createdType;

    public IJModule Module { get; }
    public IJExpr Parent => Module;
    public string Name { get; }
    public JTypeType Type { get; set; }

    internal JILTypeBuilder(string name, IJModule parent)
    {
        Name = name;
        CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);
        Type = JTypeType.None;
        Module = parent;
    }

    internal JILContextWriter ContextWriter => Parent.Context as JILContextWriter;

    public bool VisitFields(Func<IJField, bool> v) => _fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.Visit(x => v(x));

    public JNameRef AddField(JILFieldBuilder f)
    {
        var idx = _fields.Count;
        _fields.Add(f);
        return new(idx, 0);
    }

    public JNameRef AddConstructor(JILMethodBuilder c)
    {
        var idx = _constructors.Count;
        _constructors.Add(c);
        return new(-idx, 0);
    }

    internal JILType Create()
    {
        if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }

        return _createdType;
    }

    public JExprFlags Modifiers => JExprFlags.None;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => _fields[nameRef.CompileTimeExprStackDelta];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public override string ToString() => Name;
}
: IJType
IJType
IJType
public readonly JContextTypeRef CtxTypeIndex;
JContextTypeRef CtxTypeIndex
JContextTypeRef
CtxTypeIndex
private readonly List<JILFieldBuilder> _fields = new();
List<JILFieldBuilder> _fields = new()
List<JILFieldBuilder>
<JILFieldBuilder>
JILFieldBuilder
_fields = new()
= new()
new()
()
private readonly List<JILMethodBuilder> _constructors = new();
List<JILMethodBuilder> _constructors = new()
List<JILMethodBuilder>
<JILMethodBuilder>
JILMethodBuilder
_constructors = new()
= new()
new()
()
private JILType _createdType;
JILType _createdType
JILType
_createdType
public IJModule Module { get; }
IJModule
{ get; }
get;
public IJExpr Parent => Module;
IJExpr
=> Module
Module
public string Name { get; }
string
{ get; }
get;
public JTypeType Type { get; set; }
JTypeType
{ get; set; }
get;
set;
internal JILTypeBuilder(string name, IJModule parent)
    {
        Name = name;
        CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);
        Type = JTypeType.None;
        Module = parent;
    }
(string name, IJModule parent)
string name
string
IJModule parent
IJModule
{
        Name = name;
        CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);
        Type = JTypeType.None;
        Module = parent;
    }
Name = name;
Name = name
Name
name
CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);
CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this)
CtxTypeIndex
((JILContextWriter)parent.Context).WriteCtxType(this)
((JILContextWriter)parent.Context).WriteCtxType
((JILContextWriter)parent.Context)
(JILContextWriter)parent.Context
JILContextWriter
parent.Context
parent
Context
WriteCtxType
(this)
this
this
Type = JTypeType.None;
Type = JTypeType.None
Type
JTypeType.None
JTypeType
None
Module = parent;
Module = parent
Module
parent
internal JILContextWriter ContextWriter => Parent.Context as JILContextWriter;
JILContextWriter
=> Parent.Context as JILContextWriter
Parent.Context as JILContextWriter
Parent.Context
Parent
Context
JILContextWriter
public bool VisitFields(Func<IJField, bool> v) => _fields.Visit(x => v(x));
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
=> _fields.Visit(x => v(x))
_fields.Visit(x => v(x))
_fields.Visit
_fields
Visit
(x => v(x))
x => v(x)
x => v(x)
x
v(x)
v
(x)
x
x
public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.Visit(x => v(x));
bool
(Func<IJMethod, bool> v)
Func<IJMethod, bool> v
Func<IJMethod, bool>
<IJMethod, bool>
IJMethod
bool
=> _constructors.Visit(x => v(x))
_constructors.Visit(x => v(x))
_constructors.Visit
_constructors
Visit
(x => v(x))
x => v(x)
x => v(x)
x
v(x)
v
(x)
x
x
public JNameRef AddField(JILFieldBuilder f)
    {
        var idx = _fields.Count;
        _fields.Add(f);
        return new(idx, 0);
    }
JNameRef
(JILFieldBuilder f)
JILFieldBuilder f
JILFieldBuilder
{
        var idx = _fields.Count;
        _fields.Add(f);
        return new(idx, 0);
    }
var idx = _fields.Count;
var idx = _fields.Count
var
idx = _fields.Count
= _fields.Count
_fields.Count
_fields
Count
_fields.Add(f);
_fields.Add(f)
_fields.Add
_fields
Add
(f)
f
f
return new(idx, 0);
new(idx, 0)
(idx, 0)
idx
idx
0
0
public JNameRef AddConstructor(JILMethodBuilder c)
    {
        var idx = _constructors.Count;
        _constructors.Add(c);
        return new(-idx, 0);
    }
JNameRef
(JILMethodBuilder c)
JILMethodBuilder c
JILMethodBuilder
{
        var idx = _constructors.Count;
        _constructors.Add(c);
        return new(-idx, 0);
    }
var idx = _constructors.Count;
var idx = _constructors.Count
var
idx = _constructors.Count
= _constructors.Count
_constructors.Count
_constructors
Count
_constructors.Add(c);
_constructors.Add(c)
_constructors.Add
_constructors
Add
(c)
c
c
return new(-idx, 0);
new(-idx, 0)
(-idx, 0)
-idx
-idx
idx
0
0
internal JILType Create()
    {
        if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }

        return _createdType;
    }
JILType
()
{
        if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }

        return _createdType;
    }
if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }
_createdType == null
_createdType
null
{
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }
var farr = _fields.Select(x => x.Create()).ToArray();
var farr = _fields.Select(x => x.Create()).ToArray()
var
farr = _fields.Select(x => x.Create()).ToArray()
= _fields.Select(x => x.Create()).ToArray()
_fields.Select(x => x.Create()).ToArray()
_fields.Select(x => x.Create()).ToArray
_fields.Select(x => x.Create())
_fields.Select
_fields
Select
(x => x.Create())
x => x.Create()
x => x.Create()
x
x.Create()
x.Create
x
Create
()
ToArray
()
var carr = _constructors.Select(x => x.Create()).ToArray();
var carr = _constructors.Select(x => x.Create()).ToArray()
var
carr = _constructors.Select(x => x.Create()).ToArray()
= _constructors.Select(x => x.Create()).ToArray()
_constructors.Select(x => x.Create()).ToArray()
_constructors.Select(x => x.Create()).ToArray
_constructors.Select(x => x.Create())
_constructors.Select
_constructors
Select
(x => x.Create())
x => x.Create()
x => x.Create()
x
x.Create()
x.Create
x
Create
()
ToArray
()
_createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);
_createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null)
_createdType
new(ContextWriter.WriteString(Name), Type, farr, carr, null)
(ContextWriter.WriteString(Name), Type, farr, carr, null)
ContextWriter.WriteString(Name)
ContextWriter.WriteString(Name)
ContextWriter.WriteString
ContextWriter
WriteString
(Name)
Name
Name
Type
Type
farr
farr
carr
carr
null
null
for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;
int i = 0
int
i = 0
= 0
0
i < farr.Length
i
farr.Length
farr
Length
i++
i
farr[i].Parent = _createdType;
farr[i].Parent = _createdType
farr[i].Parent
farr[i]
farr
[i]
i
i
Parent
_createdType
foreach (var t in carr)
                t.Parent = _createdType;
var
carr
t.Parent = _createdType;
t.Parent = _createdType
t.Parent
t
Parent
_createdType
return _createdType;
_createdType
public JExprFlags Modifiers => JExprFlags.None;
JExprFlags
=> JExprFlags.None
JExprFlags.None
JExprFlags
None
public bool VisitVariables(Func<IJField, bool> v) => true;
bool
(Func<IJField, bool> v)
Func<IJField, bool> v
Func<IJField, bool>
<IJField, bool>
IJField
bool
=> true
true
public bool VisitNames(Func<IJField, object, bool> v)
    {
        for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;
        return true;
    }
bool
(Func<IJField, object, bool> v)
Func<IJField, object, bool> v
Func<IJField, object, bool>
<IJField, object, bool>
IJField
object
bool
{
        for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;
        return true;
    }
for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;
int i = 0
int
i = 0
= 0
0
i < _fields.Count
i
_fields.Count
_fields
Count
i++
i
if (!v(_fields[i], null))
                return false;
!v(_fields[i], null)
v(_fields[i], null)
v
(_fields[i], null)
_fields[i]
_fields[i]
_fields
[i]
i
i
null
null
return false;
false
return true;
true
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => _fields[nameRef.CompileTimeExprStackDelta];
IJField
IJExpr.
IJExpr
(JNameRef nameRef)
JNameRef nameRef
JNameRef
=> _fields[nameRef.CompileTimeExprStackDelta]
_fields[nameRef.CompileTimeExprStackDelta]
_fields
[nameRef.CompileTimeExprStackDelta]
nameRef.CompileTimeExprStackDelta
nameRef.CompileTimeExprStackDelta
nameRef
CompileTimeExprStackDelta
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
bool
IJExpr.
IJExpr
(string name, out JNameRef nameRef)
string name
string
out JNameRef nameRef
JNameRef
=> throw new NotImplementedException()
throw new NotImplementedException()
new NotImplementedException()
NotImplementedException
()
public override string ToString() => Name;
string
()
=> Name
Name
internal class JILContextWriter : JObject, IJCodeContext
{
    public JRuntimeModule ParentModule { get; }
    private readonly MInternContainer<string> _strings = new();
    private readonly List<JILModuleBuilder> _modules = new();
    private readonly List<JILTypeBuilder> _types = new();

    internal JILContextWriter(JRuntimeModule parentModule) => ParentModule = parentModule;

    public JStringRef WriteString(string s) => _strings.Load(s);

    public int WriteCtxModule(JILModuleBuilder mb)
    {
        var midx = _modules.Count;
        _modules.Add(mb);
        return midx;
    }

    public JContextTypeRef WriteCtxType(JILTypeBuilder tb)
    {
        var tidx = _types.Count;
        _types.Add(tb);
        return tidx;
    }

    public void CreateContext(out string[] strings, out IJModule[] modules, out IJType[] types) {
        //@DUMP("Creating Context:" + this)
        modules = _modules.Select(x => (IJModule)x.Create()).ToArray();
        types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();
        strings = _strings.Data.ToArray();
    }

    public string GetString(int i) => _strings.Get(i);
    public IJModule GetCtxModule(int i) => _modules[i];
    public IJType GetCtxType(int i) => _types[i];
    public int GetStringIndex(string s) => _strings.GetIndex(s);
}
: JObject, IJCodeContext
JObject
JObject
IJCodeContext
IJCodeContext
public JRuntimeModule ParentModule { get; }
JRuntimeModule
{ get; }
get;
private readonly MInternContainer<string> _strings = new();
MInternContainer<string> _strings = new()
MInternContainer<string>
<string>
string
_strings = new()
= new()
new()
()
private readonly List<JILModuleBuilder> _modules = new();
List<JILModuleBuilder> _modules = new()
List<JILModuleBuilder>
<JILModuleBuilder>
JILModuleBuilder
_modules = new()
= new()
new()
()
private readonly List<JILTypeBuilder> _types = new();
List<JILTypeBuilder> _types = new()
List<JILTypeBuilder>
<JILTypeBuilder>
JILTypeBuilder
_types = new()
= new()
new()
()
internal JILContextWriter(JRuntimeModule parentModule) => ParentModule = parentModule;
(JRuntimeModule parentModule)
JRuntimeModule parentModule
JRuntimeModule
=> ParentModule = parentModule
ParentModule = parentModule
ParentModule
parentModule
public JStringRef WriteString(string s) => _strings.Load(s);
JStringRef
(string s)
string s
string
=> _strings.Load(s)
_strings.Load(s)
_strings.Load
_strings
Load
(s)
s
s
public int WriteCtxModule(JILModuleBuilder mb)
    {
        var midx = _modules.Count;
        _modules.Add(mb);
        return midx;
    }
int
(JILModuleBuilder mb)
JILModuleBuilder mb
JILModuleBuilder
{
        var midx = _modules.Count;
        _modules.Add(mb);
        return midx;
    }
var midx = _modules.Count;
var midx = _modules.Count
var
midx = _modules.Count
= _modules.Count
_modules.Count
_modules
Count
_modules.Add(mb);
_modules.Add(mb)
_modules.Add
_modules
Add
(mb)
mb
mb
return midx;
midx
public JContextTypeRef WriteCtxType(JILTypeBuilder tb)
    {
        var tidx = _types.Count;
        _types.Add(tb);
        return tidx;
    }
JContextTypeRef
(JILTypeBuilder tb)
JILTypeBuilder tb
JILTypeBuilder
{
        var tidx = _types.Count;
        _types.Add(tb);
        return tidx;
    }
var tidx = _types.Count;
var tidx = _types.Count
var
tidx = _types.Count
= _types.Count
_types.Count
_types
Count
_types.Add(tb);
_types.Add(tb)
_types.Add
_types
Add
(tb)
tb
tb
return tidx;
tidx
public void CreateContext(out string[] strings, out IJModule[] modules, out IJType[] types) {
        //@DUMP("Creating Context:" + this)
        modules = _modules.Select(x => (IJModule)x.Create()).ToArray();
        types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();
        strings = _strings.Data.ToArray();
    }
void
(out string[] strings, out IJModule[] modules, out IJType[] types)
out string[] strings
string[]
string
[]

out IJModule[] modules
IJModule[]
IJModule
[]

out IJType[] types
IJType[]
IJType
[]

{
        //@DUMP("Creating Context:" + this)
        modules = _modules.Select(x => (IJModule)x.Create()).ToArray();
        types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();
        strings = _strings.Data.ToArray();
    }
modules = _modules.Select(x => (IJModule)x.Create()).ToArray();
modules = _modules.Select(x => (IJModule)x.Create()).ToArray()
modules
_modules.Select(x => (IJModule)x.Create()).ToArray()
_modules.Select(x => (IJModule)x.Create()).ToArray
_modules.Select(x => (IJModule)x.Create())
_modules.Select
_modules
Select
(x => (IJModule)x.Create())
x => (IJModule)x.Create()
x => (IJModule)x.Create()
x
(IJModule)x.Create()
IJModule
x.Create()
x.Create
x
Create
()
ToArray
()
types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();
types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray()
types
_types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray()
_types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray
_types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        })
_types.Select
_types
Select
(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        })
x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }
x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }
x
{
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }
var ty = x.Create();
var ty = x.Create()
var
ty = x.Create()
= x.Create()
x.Create()
x.Create
x
Create
()
if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();
x.Parent is JILBuilder jb
x.Parent
x
Parent
JILBuilder jb
JILBuilder
jb
ty.Parent = jb.Parent;
ty.Parent = jb.Parent
ty.Parent
ty
Parent
jb.Parent
jb
Parent
else ty.Parent = (x.Parent as JILModuleBuilder).Create();
ty.Parent = (x.Parent as JILModuleBuilder).Create();
ty.Parent = (x.Parent as JILModuleBuilder).Create()
ty.Parent
ty
Parent
(x.Parent as JILModuleBuilder).Create()
(x.Parent as JILModuleBuilder).Create
(x.Parent as JILModuleBuilder)
x.Parent as JILModuleBuilder
x.Parent
x
Parent
JILModuleBuilder
Create
()
return (IJType)ty;
(IJType)ty
IJType
ty
ToArray
()
strings = _strings.Data.ToArray();
strings = _strings.Data.ToArray()
strings
_strings.Data.ToArray()
_strings.Data.ToArray
_strings.Data
_strings
Data
ToArray
()
public string GetString(int i) => _strings.Get(i);
string
(int i)
int i
int
=> _strings.Get(i)
_strings.Get(i)
_strings.Get
_strings
Get
(i)
i
i
public IJModule GetCtxModule(int i) => _modules[i];
IJModule
(int i)
int i
int
=> _modules[i]
_modules[i]
_modules
[i]
i
i
public IJType GetCtxType(int i) => _types[i];
IJType
(int i)
int i
int
=> _types[i]
_types[i]
_types
[i]
i
i
public int GetStringIndex(string s) => _strings.GetIndex(s);
int
(string s)
string s
string
=> _strings.GetIndex(s)
_strings.GetIndex(s)
_strings.GetIndex
_strings
GetIndex
(s)
s
s
public class JILBuilder : JILModuleBuilder {
    public JILBuilder(JRuntimeModule m) : base(m.Name, m, new JILContextWriter(m)) {}

    public JRuntimeExpr CreateExpression() {
        //@DUMP("Generating Runtime Expr:" + this)
        var expr = Create();
        (Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);
        (Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);
        return new JRuntimeExpr(expr, Parent);
    }
}
: JILModuleBuilder
JILModuleBuilder
JILModuleBuilder
public JILBuilder(JRuntimeModule m) : base(m.Name, m, new JILContextWriter(m)) {}
(JRuntimeModule m)
JRuntimeModule m
JRuntimeModule
: base(m.Name, m, new JILContextWriter(m))
(m.Name, m, new JILContextWriter(m))
m.Name
m.Name
m
Name
m
m
new JILContextWriter(m)
new JILContextWriter(m)
JILContextWriter
(m)
m
m
{}
public JRuntimeExpr CreateExpression() {
        //@DUMP("Generating Runtime Expr:" + this)
        var expr = Create();
        (Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);
        (Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);
        return new JRuntimeExpr(expr, Parent);
    }
JRuntimeExpr
()
{
        //@DUMP("Generating Runtime Expr:" + this)
        var expr = Create();
        (Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);
        (Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);
        return new JRuntimeExpr(expr, Parent);
    }
var expr = Create();
var expr = Create()
var
expr = Create()
= Create()
Create()
Create
()
(Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);
(Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types)
(Context as JILContextWriter).CreateContext
(Context as JILContextWriter)
Context as JILContextWriter
Context
JILContextWriter
CreateContext
(out var strings, out var modules, out var types)
out var strings
var strings
var
strings
out var modules
var modules
var
modules
out var types
var types
var
types
(Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);
(Parent.Context as JRuntimeContext).MergeContext(strings, modules, types)
(Parent.Context as JRuntimeContext).MergeContext
(Parent.Context as JRuntimeContext)
Parent.Context as JRuntimeContext
Parent.Context
Parent
Context
JRuntimeContext
MergeContext
(strings, modules, types)
strings
strings
modules
modules
types
types
return new JRuntimeExpr(expr, Parent);
new JRuntimeExpr(expr, Parent)
JRuntimeExpr
(expr, Parent)
expr
expr
Parent
Parent
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace runtime.core {
    public class IO {

        public static void STOUTPrint(object o) => Console.Write(o);
        public static void STOUTPrintLn(object o) => Console.WriteLine(o);

        public static void PrintLn(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
            Console.WriteLine();
        }
        
        public static void Print(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeWrite<T>(void* destination, T v) where T: unmanaged{
            Unsafe.Write(destination, v);
            return (byte*) destination + sizeof(T);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeRead<T>(void* source, out T v) where T: unmanaged {
            v = *(T*) source;
            return (byte*) source + sizeof(T);
        }
    }
}
using System;
System
using System.Runtime.CompilerServices;
System.Runtime.CompilerServices
System.Runtime
System
Runtime
CompilerServices
using System.Runtime.InteropServices;
System.Runtime.InteropServices
System.Runtime
System
Runtime
InteropServices
namespace runtime.core {
    public class IO {

        public static void STOUTPrint(object o) => Console.Write(o);
        public static void STOUTPrintLn(object o) => Console.WriteLine(o);

        public static void PrintLn(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
            Console.WriteLine();
        }
        
        public static void Print(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeWrite<T>(void* destination, T v) where T: unmanaged{
            Unsafe.Write(destination, v);
            return (byte*) destination + sizeof(T);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeRead<T>(void* source, out T v) where T: unmanaged {
            v = *(T*) source;
            return (byte*) source + sizeof(T);
        }
    }
}
runtime.core
runtime
core
public class IO {

        public static void STOUTPrint(object o) => Console.Write(o);
        public static void STOUTPrintLn(object o) => Console.WriteLine(o);

        public static void PrintLn(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
            Console.WriteLine();
        }
        
        public static void Print(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeWrite<T>(void* destination, T v) where T: unmanaged{
            Unsafe.Write(destination, v);
            return (byte*) destination + sizeof(T);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeRead<T>(void* source, out T v) where T: unmanaged {
            v = *(T*) source;
            return (byte*) source + sizeof(T);
        }
    }
public static void STOUTPrint(object o) => Console.Write(o);
void
(object o)
object o
object
=> Console.Write(o)
Console.Write(o)
Console.Write
Console
Write
(o)
o
o
public static void STOUTPrintLn(object o) => Console.WriteLine(o);
void
(object o)
object o
object
=> Console.WriteLine(o)
Console.WriteLine(o)
Console.WriteLine
Console
WriteLine
(o)
o
o
public static void PrintLn(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
            Console.WriteLine();
        }
void
(params object[] v)
params object[] v
object[]
object
[]

{
            foreach(var t in v)
                Console.Write(t);
            Console.WriteLine();
        }
foreach(var t in v)
                Console.Write(t);
var
v
Console.Write(t);
Console.Write(t)
Console.Write
Console
Write
(t)
t
t
Console.WriteLine();
Console.WriteLine()
Console.WriteLine
Console
WriteLine
()
public static void Print(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
        }
void
(params object[] v)
params object[] v
object[]
object
[]

{
            foreach(var t in v)
                Console.Write(t);
        }
foreach(var t in v)
                Console.Write(t);
var
v
Console.Write(t);
Console.Write(t)
Console.Write
Console
Write
(t)
t
t
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeWrite<T>(void* destination, T v) where T: unmanaged{
            Unsafe.Write(destination, v);
            return (byte*) destination + sizeof(T);
        }
[MethodImpl(MethodImplOptions.AggressiveInlining)]
MethodImpl(MethodImplOptions.AggressiveInlining)
MethodImpl
(MethodImplOptions.AggressiveInlining)
MethodImplOptions.AggressiveInlining
MethodImplOptions.AggressiveInlining
MethodImplOptions
AggressiveInlining
void*
void
<T>
T
(void* destination, T v)
void* destination
void*
void
T v
T
where T: unmanaged
T
unmanaged
unmanaged
{
            Unsafe.Write(destination, v);
            return (byte*) destination + sizeof(T);
        }
Unsafe.Write(destination, v);
Unsafe.Write(destination, v)
Unsafe.Write
Unsafe
Write
(destination, v)
destination
destination
v
v
return (byte*) destination + sizeof(T);
(byte*) destination + sizeof(T)
(byte*) destination
byte*
byte
destination
sizeof(T)
T
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeRead<T>(void* source, out T v) where T: unmanaged {
            v = *(T*) source;
            return (byte*) source + sizeof(T);
        }
[MethodImpl(MethodImplOptions.AggressiveInlining)]
MethodImpl(MethodImplOptions.AggressiveInlining)
MethodImpl
(MethodImplOptions.AggressiveInlining)
MethodImplOptions.AggressiveInlining
MethodImplOptions.AggressiveInlining
MethodImplOptions
AggressiveInlining
void*
void
<T>
T
(void* source, out T v)
void* source
void*
void
out T v
T
where T: unmanaged
T
unmanaged
unmanaged
{
            v = *(T*) source;
            return (byte*) source + sizeof(T);
        }
v = *(T*) source;
v = *(T*) source
v
*(T*) source
(T*) source
T*
T
source
return (byte*) source + sizeof(T);
(byte*) source + sizeof(T)
(byte*) source
byte*
byte
source
sizeof(T)
T
using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("runtime")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("runtime")]
[assembly: System.Reflection.AssemblyTitleAttribute("runtime")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


using System;
System
using System.Reflection;
System.Reflection
System
Reflection
[assembly: System.Reflection.AssemblyCompanyAttribute("runtime")]
assembly:
System.Reflection.AssemblyCompanyAttribute("runtime")
System.Reflection.AssemblyCompanyAttribute
System.Reflection
System
Reflection
AssemblyCompanyAttribute
("runtime")
"runtime"
"runtime"
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
assembly:
System.Reflection.AssemblyConfigurationAttribute("Debug")
System.Reflection.AssemblyConfigurationAttribute
System.Reflection
System
Reflection
AssemblyConfigurationAttribute
("Debug")
"Debug"
"Debug"
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
assembly:
System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")
System.Reflection.AssemblyFileVersionAttribute
System.Reflection
System
Reflection
AssemblyFileVersionAttribute
("1.0.0.0")
"1.0.0.0"
"1.0.0.0"
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
assembly:
System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")
System.Reflection.AssemblyInformationalVersionAttribute
System.Reflection
System
Reflection
AssemblyInformationalVersionAttribute
("1.0.0")
"1.0.0"
"1.0.0"
[assembly: System.Reflection.AssemblyProductAttribute("runtime")]
assembly:
System.Reflection.AssemblyProductAttribute("runtime")
System.Reflection.AssemblyProductAttribute
System.Reflection
System
Reflection
AssemblyProductAttribute
("runtime")
"runtime"
"runtime"
[assembly: System.Reflection.AssemblyTitleAttribute("runtime")]
assembly:
System.Reflection.AssemblyTitleAttribute("runtime")
System.Reflection.AssemblyTitleAttribute
System.Reflection
System
Reflection
AssemblyTitleAttribute
("runtim
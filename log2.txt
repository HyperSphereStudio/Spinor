using runtime.core;
/**This Class Was Machine Generated. Do not Modify*/
public enum MemoryType : byte{
    None,
    //CONSTANTS//
    Signed,
    Unsigned,
    Floating,
    Pointer,
    Block,
    Array,
    String,
    //END CONSTANTS//
    
    Type,
    Module,
    Function,
    
    //VARIADICS//
    Variable,
    //END VARIADICS//
}

public enum OperationType : byte{
    None,
    Push,
    Pop,
    PushVariadic,
    PopVariadic,
    Load,
    Invoke
}

public readonly struct JOp {
    public static readonly JOp[] OpCodeTable = new JOp[22];
    public readonly byte OpCode;
    public readonly sbyte StackChange;
    public readonly byte OperandsSize;
    public readonly MemoryType Memory;
    public readonly OperationType Behaviour;

    public bool IsPush => Behaviour == OperationType.Push;
    public bool IsPop => Behaviour == OperationType.Pop;

    private unsafe JOp(byte opCode, sbyte stackChange, byte operandsSize, MemoryType memory, OperationType behaviour) {
        OpCode = opCode;
        StackChange = stackChange;
        OperandsSize = operandsSize;
        Memory = memory;
        Behaviour = behaviour;
        OpCodeTable[OpCode] = this;
    }

    public byte GetRuntimeOpCode() {
        if (Behaviour == OperationType.Push) {
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }

        throw new JuliaException("Unable To Determine OpCode!");
    }

	public const byte PushInt8Op = 0;
	public const byte PushInt16Op = 1;
	public const byte PushInt32Op = 2;
	public const byte PushInt64Op = 3;
	public const byte PushUInt8Op = 4;
	public const byte PushUInt16Op = 5;
	public const byte PushUInt32Op = 6;
	public const byte PushUInt64Op = 7;
	public const byte PushFloat32Op = 8;
	public const byte PushFloat64Op = 9;
	public const byte PushArrayOp = 10;
	public const byte PushStringOp = 11;
	public const byte Pop8Op = 12;
	public const byte Pop16Op = 13;
	public const byte Pop32Op = 14;
	public const byte Pop64Op = 15;
	public const byte PopArrayOp = 16;
	public const byte PopStringOp = 15;
	public const byte LoadTypeOp = 17;
	public const byte LoadModuleOp = 18;
	public const byte LoadMethodOp = 19;
	public const byte InvokeFunctionOp = 20;


	public static readonly JOp PushInt8 = new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt16 = new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt32 = new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt64 = new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushUInt8 = new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt16 = new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt32 = new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt64 = new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushFloat32 = new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push);
	public static readonly JOp PushFloat64 = new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push);
	public static readonly JOp PushArray = new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push);
	public static readonly JOp PushString = new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push);
	public static readonly JOp Pop8 = new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop16 = new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop32 = new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop64 = new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp PopArray = new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop);
	public static readonly JOp PopString = new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp LoadType = new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load);
	public static readonly JOp LoadModule = new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load);
	public static readonly JOp LoadMethod = new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load);
	public static readonly JOp InvokeFunction = new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke);


	public static readonly string[] OpCodeNames = {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"};
	public string Name => OpCodeNames[OpCode];
}
		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using runtime.core;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public enum MemoryType : byte{
    None,
    //CONSTANTS//
    Signed,
    Unsigned,
    Floating,
    Pointer,
    Block,
    Array,
    String,
    //END CONSTANTS//
    
    Type,
    Module,
    Function,
    
    //VARIADICS//
    Variable,
    //END VARIADICS//
}		Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax
: byte		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Signed		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Floating		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Pointer		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Block		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
String		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Variable		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
public enum OperationType : byte{
    None,
    Push,
    Pop,
    PushVariadic,
    PopVariadic,
    Load,
    Invoke
}		Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax
: byte		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Pop		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
PushVariadic		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
PopVariadic		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Load		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
public readonly struct JOp {
    public static readonly JOp[] OpCodeTable = new JOp[22];
    public readonly byte OpCode;
    public readonly sbyte StackChange;
    public readonly byte OperandsSize;
    public readonly MemoryType Memory;
    public readonly OperationType Behaviour;

    public bool IsPush => Behaviour == OperationType.Push;
    public bool IsPop => Behaviour == OperationType.Pop;

    private unsafe JOp(byte opCode, sbyte stackChange, byte operandsSize, MemoryType memory, OperationType behaviour) {
        OpCode = opCode;
        StackChange = stackChange;
        OperandsSize = operandsSize;
        Memory = memory;
        Behaviour = behaviour;
        OpCodeTable[OpCode] = this;
    }

    public byte GetRuntimeOpCode() {
        if (Behaviour == OperationType.Push) {
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }

        throw new JuliaException("Unable To Determine OpCode!");
    }

	public const byte PushInt8Op = 0;
	public const byte PushInt16Op = 1;
	public const byte PushInt32Op = 2;
	public const byte PushInt64Op = 3;
	public const byte PushUInt8Op = 4;
	public const byte PushUInt16Op = 5;
	public const byte PushUInt32Op = 6;
	public const byte PushUInt64Op = 7;
	public const byte PushFloat32Op = 8;
	public const byte PushFloat64Op = 9;
	public const byte PushArrayOp = 10;
	public const byte PushStringOp = 11;
	public const byte Pop8Op = 12;
	public const byte Pop16Op = 13;
	public const byte Pop32Op = 14;
	public const byte Pop64Op = 15;
	public const byte PopArrayOp = 16;
	public const byte PopStringOp = 15;
	public const byte LoadTypeOp = 17;
	public const byte LoadModuleOp = 18;
	public const byte LoadMethodOp = 19;
	public const byte InvokeFunctionOp = 20;


	public static readonly JOp PushInt8 = new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt16 = new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt32 = new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushInt64 = new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push);
	public static readonly JOp PushUInt8 = new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt16 = new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt32 = new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushUInt64 = new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push);
	public static readonly JOp PushFloat32 = new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push);
	public static readonly JOp PushFloat64 = new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push);
	public static readonly JOp PushArray = new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push);
	public static readonly JOp PushString = new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push);
	public static readonly JOp Pop8 = new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop16 = new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop32 = new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp Pop64 = new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp PopArray = new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop);
	public static readonly JOp PopString = new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop);
	public static readonly JOp LoadType = new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load);
	public static readonly JOp LoadModule = new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load);
	public static readonly JOp LoadMethod = new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load);
	public static readonly JOp InvokeFunction = new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke);


	public static readonly string[] OpCodeNames = {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"};
	public string Name => OpCodeNames[OpCode];
}		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
public static readonly JOp[] OpCodeTable = new JOp[22];		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp[] OpCodeTable = new JOp[22]		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
OpCodeTable = new JOp[22]		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new JOp[22]		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new JOp[22]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax
JOp[22]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[22]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public readonly byte OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly sbyte StackChange;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
sbyte StackChange		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
sbyte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
StackChange		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly byte OperandsSize;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte OperandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
OperandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly MemoryType Memory;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
MemoryType Memory		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Memory		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly OperationType Behaviour;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
OperationType Behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public bool IsPush => Behaviour == OperationType.Push;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Behaviour == OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Behaviour == OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool IsPop => Behaviour == OperationType.Pop;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Behaviour == OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Behaviour == OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private unsafe JOp(byte opCode, sbyte stackChange, byte operandsSize, MemoryType memory, OperationType behaviour) {
        OpCode = opCode;
        StackChange = stackChange;
        OperandsSize = operandsSize;
        Memory = memory;
        Behaviour = behaviour;
        OpCodeTable[OpCode] = this;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(byte opCode, sbyte stackChange, byte operandsSize, MemoryType memory, OperationType behaviour)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
byte opCode		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
sbyte stackChange		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
sbyte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
byte operandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
MemoryType memory		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        OpCode = opCode;
        StackChange = stackChange;
        OperandsSize = operandsSize;
        Memory = memory;
        Behaviour = behaviour;
        OpCodeTable[OpCode] = this;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
OpCode = opCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
OpCode = opCode		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
opCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StackChange = stackChange;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
StackChange = stackChange		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
StackChange		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
stackChange		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperandsSize = operandsSize;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
OperandsSize = operandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
OperandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
operandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Memory = memory;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Memory = memory		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Memory		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
memory		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Behaviour = behaviour;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Behaviour = behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodeTable[OpCode] = this;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
OpCodeTable[OpCode] = this		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
OpCodeTable[OpCode]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
OpCodeTable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[OpCode]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public byte GetRuntimeOpCode() {
        if (Behaviour == OperationType.Push) {
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }

        throw new JuliaException("Unable To Determine OpCode!");
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
        if (Behaviour == OperationType.Push) {
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }

        throw new JuliaException("Unable To Determine OpCode!");
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (Behaviour == OperationType.Push) {
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
Behaviour == OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (Memory == MemoryType.Signed) {
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
Memory == MemoryType.Signed		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Memory		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MemoryType.Signed		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Signed		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
switch (OperandsSize) {
                    case 1: return PushInt8.OpCode;
                    case 2: return PushInt16.OpCode;
                    case 4: return PushInt32.OpCode;
                    case 8: return PushInt64.OpCode;
                }		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
OperandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 1: return PushInt8.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 1:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return PushInt8.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushInt8.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushInt8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 2: return PushInt16.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 2:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return PushInt16.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushInt16.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushInt16		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 4: return PushInt32.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 4:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return PushInt32.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushInt32.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 8: return PushInt64.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 8:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return PushInt64.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushInt64.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (Memory == MemoryType.Unsigned) {
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
Memory == MemoryType.Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Memory		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MemoryType.Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }   
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
switch (OperandsSize) {
                    case 1: return PushUInt8.OpCode;
                    case 2: return PushUInt16.OpCode;
                    case 4: return PushUInt32.OpCode;
                    case 8: return PushUInt64.OpCode;
                }		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
OperandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 1: return PushUInt8.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 1:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return PushUInt8.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushUInt8.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushUInt8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 2: return PushUInt16.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 2:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return PushUInt16.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushUInt16.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushUInt16		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 4: return PushUInt32.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 4:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return PushUInt32.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushUInt32.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushUInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 8: return PushUInt64.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 8:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return PushUInt64.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushUInt64.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushUInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (Memory == MemoryType.Floating)
            {
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
Memory == MemoryType.Floating		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Memory		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MemoryType.Floating		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Floating		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                if (OperandsSize == 4) return PushFloat32.OpCode;
                if (OperandsSize == 8) return PushFloat64.OpCode;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (OperandsSize == 4) return PushFloat32.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
OperandsSize == 4		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
OperandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return PushFloat32.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushFloat32.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushFloat32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (OperandsSize == 8) return PushFloat64.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
OperandsSize == 8		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
OperandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return PushFloat64.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushFloat64.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushFloat64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (Memory == MemoryType.String)
                return PushString.OpCode;
            else if (Memory == MemoryType.Array)
                return PushArray.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
Memory == MemoryType.String		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Memory		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MemoryType.String		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
String		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return PushString.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushString.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (Memory == MemoryType.Array)
                return PushArray.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (Memory == MemoryType.Array)
                return PushArray.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
Memory == MemoryType.Array		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Memory		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MemoryType.Array		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return PushArray.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PushArray.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PushArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (Behaviour == OperationType.Pop) {
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
Behaviour == OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }
            switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (Memory == MemoryType.Array) {
                return PopArray.OpCode;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
Memory == MemoryType.Array		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Memory		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MemoryType.Array		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                return PopArray.OpCode;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return PopArray.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
PopArray.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
PopArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
switch (OperandsSize) {
                case 1: return Pop8.OpCode;
                case 2: return Pop16.OpCode;
                case 4: return Pop32.OpCode;
                case 8: return Pop64.OpCode;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
OperandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 1: return Pop8.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 1:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return Pop8.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
Pop8.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Pop8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 2: return Pop16.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 2:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return Pop16.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
Pop16.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Pop16		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 4: return Pop32.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 4:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return Pop32.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
Pop32.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Pop32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 8: return Pop64.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 8:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return Pop64.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
Pop64.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Pop64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (Behaviour == OperationType.Load) {
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
Behaviour == OperationType.Load		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Load		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Load		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
switch (Memory) {
                case MemoryType.Type: return LoadType.OpCode;
                case MemoryType.Module: return LoadModule.OpCode;
                case MemoryType.Function: return LoadMethod.OpCode;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
Memory		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case MemoryType.Type: return LoadType.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case MemoryType.Type:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
MemoryType.Type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return LoadType.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
LoadType.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
LoadType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case MemoryType.Module: return LoadModule.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case MemoryType.Module:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
MemoryType.Module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return LoadModule.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
LoadModule.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
LoadModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case MemoryType.Function: return LoadMethod.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case MemoryType.Function:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
MemoryType.Function		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return LoadMethod.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
LoadMethod.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
LoadMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (Behaviour == OperationType.Invoke) {
            return InvokeFunction.OpCode;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
Behaviour == OperationType.Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Behaviour		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            return InvokeFunction.OpCode;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return InvokeFunction.OpCode;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
InvokeFunction.OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
InvokeFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
throw new JuliaException("Unable To Determine OpCode!");		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new JuliaException("Unable To Determine OpCode!")		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Unable To Determine OpCode!")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Unable To Determine OpCode!"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Unable To Determine OpCode!"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushInt8Op = 0;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushInt8Op = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushInt8Op = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushInt16Op = 1;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushInt16Op = 1		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushInt16Op = 1		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 1		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushInt32Op = 2;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushInt32Op = 2		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushInt32Op = 2		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 2		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushInt64Op = 3;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushInt64Op = 3		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushInt64Op = 3		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 3		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushUInt8Op = 4;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushUInt8Op = 4		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushUInt8Op = 4		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 4		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushUInt16Op = 5;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushUInt16Op = 5		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushUInt16Op = 5		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 5		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushUInt32Op = 6;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushUInt32Op = 6		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushUInt32Op = 6		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 6		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushUInt64Op = 7;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushUInt64Op = 7		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushUInt64Op = 7		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 7		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushFloat32Op = 8;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushFloat32Op = 8		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushFloat32Op = 8		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 8		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushFloat64Op = 9;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushFloat64Op = 9		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushFloat64Op = 9		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 9		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushArrayOp = 10;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushArrayOp = 10		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushArrayOp = 10		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 10		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PushStringOp = 11;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PushStringOp = 11		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PushStringOp = 11		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 11		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte Pop8Op = 12;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte Pop8Op = 12		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Pop8Op = 12		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 12		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte Pop16Op = 13;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte Pop16Op = 13		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Pop16Op = 13		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 13		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte Pop32Op = 14;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte Pop32Op = 14		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Pop32Op = 14		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 14		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte Pop64Op = 15;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte Pop64Op = 15		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Pop64Op = 15		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 15		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PopArrayOp = 16;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PopArrayOp = 16		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PopArrayOp = 16		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 16		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte PopStringOp = 15;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte PopStringOp = 15		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
PopStringOp = 15		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 15		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte LoadTypeOp = 17;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte LoadTypeOp = 17		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
LoadTypeOp = 17		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 17		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte LoadModuleOp = 18;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte LoadModuleOp = 18		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
LoadModuleOp = 18		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 18		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte LoadMethodOp = 19;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte LoadMethodOp = 19		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
LoadMethodOp = 19		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 19		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const byte InvokeFunctionOp = 20;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte InvokeFunctionOp = 20		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
InvokeFunctionOp = 20		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 20		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static readonly JOp PushInt8 = new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushInt8 = new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushInt8 = new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushInt8Op, 1, 2, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushInt8Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushInt8Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Signed		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Signed		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Signed		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PushInt16 = new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushInt16 = new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushInt16 = new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushInt16Op, 2, 3, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushInt16Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushInt16Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Signed		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Signed		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Signed		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PushInt32 = new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushInt32 = new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushInt32 = new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushInt32Op, 4, 5, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushInt32Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushInt32Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Signed		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Signed		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Signed		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PushInt64 = new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushInt64 = new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushInt64 = new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushInt64Op, 8, 9, MemoryType.Signed, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushInt64Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushInt64Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Signed		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Signed		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Signed		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PushUInt8 = new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushUInt8 = new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushUInt8 = new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushUInt8Op, 1, 2, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushUInt8Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushUInt8Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PushUInt16 = new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushUInt16 = new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushUInt16 = new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushUInt16Op, 2, 3, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushUInt16Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushUInt16Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PushUInt32 = new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushUInt32 = new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushUInt32 = new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushUInt32Op, 4, 5, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushUInt32Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushUInt32Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PushUInt64 = new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushUInt64 = new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushUInt64 = new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushUInt64Op, 8, 9, MemoryType.Unsigned, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushUInt64Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushUInt64Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Unsigned		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PushFloat32 = new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushFloat32 = new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushFloat32 = new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushFloat32Op, 4, 5, MemoryType.Floating, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushFloat32Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushFloat32Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Floating		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Floating		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Floating		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PushFloat64 = new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushFloat64 = new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushFloat64 = new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushFloat64Op, 8, 9, MemoryType.Floating, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushFloat64Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushFloat64Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Floating		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Floating		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Floating		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PushArray = new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushArray = new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushArray = new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushArrayOp, 12, 13, MemoryType.Array, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushArrayOp		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushArrayOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Array		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Array		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PushString = new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PushString = new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PushString = new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PushStringOp, 8, 5, MemoryType.String, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PushStringOp, 8, 5, MemoryType.String, OperationType.Push)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PushStringOp		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PushStringOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.String		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.String		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
String		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Push		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Push		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp Pop8 = new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp Pop8 = new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop8 = new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(Pop8Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Pop8Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Pop8Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Block		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Block		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Block		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp Pop16 = new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp Pop16 = new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop16 = new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(Pop16Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Pop16Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Pop16Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Block		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Block		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Block		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp Pop32 = new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp Pop32 = new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop32 = new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(Pop32Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Pop32Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Pop32Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Block		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Block		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Block		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp Pop64 = new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp Pop64 = new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop64 = new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(Pop64Op, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Pop64Op		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Pop64Op		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Block		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Block		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Block		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PopArray = new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PopArray = new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PopArray = new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PopArrayOp, -12, 13, MemoryType.Array, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PopArrayOp		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PopArrayOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-12		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
-12		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Array		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Array		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp PopString = new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp PopString = new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PopString = new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(PopStringOp, -1, 2, MemoryType.Block, OperationType.Pop)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
PopStringOp		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
PopStringOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Block		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Block		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Block		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Pop		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Pop		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp LoadType = new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp LoadType = new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LoadType = new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(LoadTypeOp, 8, 5, MemoryType.Type, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
LoadTypeOp		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
LoadTypeOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Type		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Load		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Load		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Load		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp LoadModule = new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp LoadModule = new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LoadModule = new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(LoadModuleOp, 8, 5, MemoryType.Module, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
LoadModuleOp		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
LoadModuleOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Module		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Load		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Load		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Load		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp LoadMethod = new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp LoadMethod = new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LoadMethod = new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(LoadMethodOp, 8, 5, MemoryType.Function, OperationType.Load)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
LoadMethodOp		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
LoadMethodOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Function		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Function		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Load		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Load		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Load		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly JOp InvokeFunction = new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JOp InvokeFunction = new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
InvokeFunction = new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(InvokeFunctionOp, 0, 9, MemoryType.Function, OperationType.Invoke)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
InvokeFunctionOp		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
InvokeFunctionOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
MemoryType.Function		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MemoryType.Function		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MemoryType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperationType.Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OperationType.Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OperationType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static readonly string[] OpCodeNames = {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"};		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
string[] OpCodeNames = {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
OpCodeNames = {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= {"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"}		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
{"PushInt8", "PushInt16", "PushInt32", "PushInt64", "PushUInt8", "PushUInt16", "PushUInt32", "PushUInt64", "PushFloat32", "PushFloat64", "PushArray", "PushString", "Pop8", "Pop16", "Pop32", "Pop64", "PopArray", "PopString", "LoadType", "LoadModule", "LoadMethod", "InvokeFunction"}		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
"PushInt8"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PushInt16"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PushInt32"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PushInt64"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PushUInt8"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PushUInt16"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PushUInt32"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PushUInt64"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PushFloat32"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PushFloat64"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PushArray"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PushString"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Pop8"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Pop16"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Pop32"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Pop64"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PopArray"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"PopString"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LoadType"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LoadModule"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LoadMethod"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"InvokeFunction"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public string Name => OpCodeNames[OpCode];		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> OpCodeNames[OpCode]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
OpCodeNames[OpCode]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
OpCodeNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[OpCode]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core.JIL;

public class JILCompiler : Reader.IJILBaseVisitor
{
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        
    }
    
    
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
namespace runtime.core.JIL;

public class JILCompiler : Reader.IJILBaseVisitor
{
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        
    }
    
    
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JILCompiler : Reader.IJILBaseVisitor
{
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        
    }
    
    
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: Reader.IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
Reader.IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
Reader.IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Reader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJType loadedType, ref int loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJType loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ref int loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
using System.Collections.Generic;
using System.Linq;
using runtime.core.Runtime;

namespace runtime.core.JIL;

public class JILInterpreter : JRuntimeContext, Reader.IJILBaseVisitor, IJCodeExecutionContext {
    private readonly List<IJExpr> _expressionStack = new();
    private readonly List<IJModule> _moduleStack = new();
    private int _exprStackEnd;
    private int _moduleStackEnd;
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {}


    public JILInterpreter(string[] strings, IJModule[] modules, IJType[] types) : base(strings, modules, types) {}
    
    public IJExpr GetExpr(int i) => _expressionStack[i];
    public IJModule GetModule(int i) => _moduleStack[i];
    public IJField GetNameField(IJExpr e, JNameRef nameRef) => _expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef);
    
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
        nameRef = default;
        return false;
    }
    
    
    IJModule IJCodeExecutionContext.CurrentModule => _moduleStack.First();
    IJExpr IJCodeExecutionContext.CurrentExpr => _expressionStack.First();

    void IJCodeExecutionContext.EnterModule(IJModule m) {
        _moduleStack.Add(m);
        _moduleStackEnd++;
    }

    void IJCodeExecutionContext.ExitModule() => _moduleStack.RemoveAt(_moduleStackEnd--);

    void IJCodeExecutionContext.EnterExpr(IJExpr e) {
        _expressionStack.Add(e);
        _exprStackEnd++;
    }
    
    void IJCodeExecutionContext.ExitExpr() => _expressionStack.RemoveAt(_exprStackEnd--);
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System.Collections.Generic;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Collections.Generic		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Collections		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Collections		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Generic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Linq;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Linq		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Linq		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.Runtime;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core.JIL;

public class JILInterpreter : JRuntimeContext, Reader.IJILBaseVisitor, IJCodeExecutionContext {
    private readonly List<IJExpr> _expressionStack = new();
    private readonly List<IJModule> _moduleStack = new();
    private int _exprStackEnd;
    private int _moduleStackEnd;
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {}


    public JILInterpreter(string[] strings, IJModule[] modules, IJType[] types) : base(strings, modules, types) {}
    
    public IJExpr GetExpr(int i) => _expressionStack[i];
    public IJModule GetModule(int i) => _moduleStack[i];
    public IJField GetNameField(IJExpr e, JNameRef nameRef) => _expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef);
    
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
        nameRef = default;
        return false;
    }
    
    
    IJModule IJCodeExecutionContext.CurrentModule => _moduleStack.First();
    IJExpr IJCodeExecutionContext.CurrentExpr => _expressionStack.First();

    void IJCodeExecutionContext.EnterModule(IJModule m) {
        _moduleStack.Add(m);
        _moduleStackEnd++;
    }

    void IJCodeExecutionContext.ExitModule() => _moduleStack.RemoveAt(_moduleStackEnd--);

    void IJCodeExecutionContext.EnterExpr(IJExpr e) {
        _expressionStack.Add(e);
        _exprStackEnd++;
    }
    
    void IJCodeExecutionContext.ExitExpr() => _expressionStack.RemoveAt(_exprStackEnd--);
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JILInterpreter : JRuntimeContext, Reader.IJILBaseVisitor, IJCodeExecutionContext {
    private readonly List<IJExpr> _expressionStack = new();
    private readonly List<IJModule> _moduleStack = new();
    private int _exprStackEnd;
    private int _moduleStackEnd;
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {}


    public JILInterpreter(string[] strings, IJModule[] modules, IJType[] types) : base(strings, modules, types) {}
    
    public IJExpr GetExpr(int i) => _expressionStack[i];
    public IJModule GetModule(int i) => _moduleStack[i];
    public IJField GetNameField(IJExpr e, JNameRef nameRef) => _expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef);
    
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
        nameRef = default;
        return false;
    }
    
    
    IJModule IJCodeExecutionContext.CurrentModule => _moduleStack.First();
    IJExpr IJCodeExecutionContext.CurrentExpr => _expressionStack.First();

    void IJCodeExecutionContext.EnterModule(IJModule m) {
        _moduleStack.Add(m);
        _moduleStackEnd++;
    }

    void IJCodeExecutionContext.ExitModule() => _moduleStack.RemoveAt(_moduleStackEnd--);

    void IJCodeExecutionContext.EnterExpr(IJExpr e) {
        _expressionStack.Add(e);
        _exprStackEnd++;
    }
    
    void IJCodeExecutionContext.ExitExpr() => _expressionStack.RemoveAt(_exprStackEnd--);
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JRuntimeContext, Reader.IJILBaseVisitor, IJCodeExecutionContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JRuntimeContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JRuntimeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reader.IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
Reader.IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Reader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJCodeExecutionContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJCodeExecutionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private readonly List<IJExpr> _expressionStack = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<IJExpr> _expressionStack = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<IJExpr>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJExpr>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_expressionStack = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
private readonly List<IJModule> _moduleStack = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<IJModule> _moduleStack = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<IJModule>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJModule>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_moduleStack = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
private int _exprStackEnd;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int _exprStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_exprStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private int _moduleStackEnd;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int _moduleStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_moduleStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJType loadedType, ref int loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJType loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ref int loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public JILInterpreter(string[] strings, IJModule[] modules, IJType[] types) : base(strings, modules, types) {}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(string[] strings, IJModule[] modules, IJType[] types)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string[] strings		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
IJModule[] modules		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJModule[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
IJType[] types		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
: base(strings, modules, types)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(strings, modules, types)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
strings		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
modules		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public IJExpr GetExpr(int i) => _expressionStack[i];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _expressionStack[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_expressionStack[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_expressionStack		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJModule GetModule(int i) => _moduleStack[i];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _moduleStack[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_moduleStack[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_moduleStack		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJField GetNameField(IJExpr e, JNameRef nameRef) => _expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(IJExpr e, JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJExpr e		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl(nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta].GetNameFieldImpl		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_expressionStack[_exprStackEnd - nameRef.CompileTimeExprStackDelta]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_expressionStack		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[_exprStackEnd - nameRef.CompileTimeExprStackDelta]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
_exprStackEnd - nameRef.CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_exprStackEnd - nameRef.CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_exprStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
nameRef.CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNameFieldImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
        nameRef = default;
        return false;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJExpr e, string name, out JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJExpr e		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;
        nameRef = default;
        return false;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
for(int i = _exprStackEnd; i >= 0; i --)
            if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = _exprStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = _exprStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= _exprStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
_exprStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i >= 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i --		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (_expressionStack[i].GetNameRefImpl(name, out nameRef))
                return true;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_expressionStack[i].GetNameRefImpl(name, out nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_expressionStack[i].GetNameRefImpl		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_expressionStack[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_expressionStack		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNameRefImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, out nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
nameRef = default;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
nameRef = default		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
default		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
IJModule IJCodeExecutionContext.CurrentModule => _moduleStack.First();		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJCodeExecutionContext.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJCodeExecutionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _moduleStack.First()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_moduleStack.First()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_moduleStack.First		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_moduleStack		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
First		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
IJExpr IJCodeExecutionContext.CurrentExpr => _expressionStack.First();		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJCodeExecutionContext.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJCodeExecutionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _expressionStack.First()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_expressionStack.First()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_expressionStack.First		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_expressionStack		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
First		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
void IJCodeExecutionContext.EnterModule(IJModule m) {
        _moduleStack.Add(m);
        _moduleStackEnd++;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJCodeExecutionContext.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJCodeExecutionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(IJModule m)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJModule m		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        _moduleStack.Add(m);
        _moduleStackEnd++;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_moduleStack.Add(m);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_moduleStack.Add(m)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_moduleStack.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_moduleStack		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(m)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_moduleStackEnd++;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_moduleStackEnd++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
_moduleStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void IJCodeExecutionContext.ExitModule() => _moduleStack.RemoveAt(_moduleStackEnd--);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJCodeExecutionContext.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJCodeExecutionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _moduleStack.RemoveAt(_moduleStackEnd--)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_moduleStack.RemoveAt(_moduleStackEnd--)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_moduleStack.RemoveAt		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_moduleStack		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RemoveAt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_moduleStackEnd--)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_moduleStackEnd--		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_moduleStackEnd--		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
_moduleStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void IJCodeExecutionContext.EnterExpr(IJExpr e) {
        _expressionStack.Add(e);
        _exprStackEnd++;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJCodeExecutionContext.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJCodeExecutionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(IJExpr e)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJExpr e		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        _expressionStack.Add(e);
        _exprStackEnd++;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_expressionStack.Add(e);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_expressionStack.Add(e)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_expressionStack.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_expressionStack		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(e)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_exprStackEnd++;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_exprStackEnd++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
_exprStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void IJCodeExecutionContext.ExitExpr() => _expressionStack.RemoveAt(_exprStackEnd--);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJCodeExecutionContext.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJCodeExecutionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _expressionStack.RemoveAt(_exprStackEnd--)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_expressionStack.RemoveAt(_exprStackEnd--)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_expressionStack.RemoveAt		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_expressionStack		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RemoveAt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_exprStackEnd--)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_exprStackEnd--		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_exprStackEnd--		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
_exprStackEnd		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using System.Text;
using runtime.core.Runtime;
using runtime.Utils;

namespace runtime.core.JIL;

public class JILPrinter : Reader.IJILBaseVisitor {
    private int _indent = 0;
    private bool _hasIdented = true;
    private bool _dump;
    private readonly StringBuilder _sb = new();

    public JILPrinter(bool dump = true) => _dump = dump;

    public void IncIndent() => _indent++;
    public void DecIndent() => _indent--;

    public JILPrinter Print(string s)
    {
        if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }

        _sb.Append(s);
        return this;
    }

    public JILPrinter Println(string s = "")
    {
        Print(s);
        Print("\n");
        _hasIdented = false;
        return this;
    }

    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        if (_dump)
            Println("#=Instantiate Type=#");
                
        PrintType(loadedType);
    }

    public static unsafe void PrintBytes(byte* bytes, int length)
    {
        for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");
        Console.WriteLine();
    }

    private static unsafe string GetFieldTypeName(IJField f) {
        if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
        return f.Type.Name;
    }
    
    public void PrintType(IJType t) {
        if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
        
        Println(t.Name).IncIndent();

        t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });
        
        t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });

        DecIndent();
        Println().Println("end");
    }

    public void PrintMethod(string name, IJMethod m) {
        
    }

    public override string ToString() => _sb.ToString();
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Text;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Text		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Text		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.Runtime;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.Utils;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.Utils		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Utils		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core.JIL;

public class JILPrinter : Reader.IJILBaseVisitor {
    private int _indent = 0;
    private bool _hasIdented = true;
    private bool _dump;
    private readonly StringBuilder _sb = new();

    public JILPrinter(bool dump = true) => _dump = dump;

    public void IncIndent() => _indent++;
    public void DecIndent() => _indent--;

    public JILPrinter Print(string s)
    {
        if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }

        _sb.Append(s);
        return this;
    }

    public JILPrinter Println(string s = "")
    {
        Print(s);
        Print("\n");
        _hasIdented = false;
        return this;
    }

    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        if (_dump)
            Println("#=Instantiate Type=#");
                
        PrintType(loadedType);
    }

    public static unsafe void PrintBytes(byte* bytes, int length)
    {
        for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");
        Console.WriteLine();
    }

    private static unsafe string GetFieldTypeName(IJField f) {
        if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
        return f.Type.Name;
    }
    
    public void PrintType(IJType t) {
        if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
        
        Println(t.Name).IncIndent();

        t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });
        
        t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });

        DecIndent();
        Println().Println("end");
    }

    public void PrintMethod(string name, IJMethod m) {
        
    }

    public override string ToString() => _sb.ToString();
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JILPrinter : Reader.IJILBaseVisitor {
    private int _indent = 0;
    private bool _hasIdented = true;
    private bool _dump;
    private readonly StringBuilder _sb = new();

    public JILPrinter(bool dump = true) => _dump = dump;

    public void IncIndent() => _indent++;
    public void DecIndent() => _indent--;

    public JILPrinter Print(string s)
    {
        if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }

        _sb.Append(s);
        return this;
    }

    public JILPrinter Println(string s = "")
    {
        Print(s);
        Print("\n");
        _hasIdented = false;
        return this;
    }

    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        if (_dump)
            Println("#=Instantiate Type=#");
                
        PrintType(loadedType);
    }

    public static unsafe void PrintBytes(byte* bytes, int length)
    {
        for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");
        Console.WriteLine();
    }

    private static unsafe string GetFieldTypeName(IJField f) {
        if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
        return f.Type.Name;
    }
    
    public void PrintType(IJType t) {
        if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
        
        Println(t.Name).IncIndent();

        t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });
        
        t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });

        DecIndent();
        Println().Println("end");
    }

    public void PrintMethod(string name, IJMethod m) {
        
    }

    public override string ToString() => _sb.ToString();
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: Reader.IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
Reader.IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
Reader.IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Reader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private int _indent = 0;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int _indent = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_indent = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
private bool _hasIdented = true;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
bool _hasIdented = true		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_hasIdented = true		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= true		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
private bool _dump;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
bool _dump		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_dump		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private readonly StringBuilder _sb = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
StringBuilder _sb = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
StringBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_sb = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public JILPrinter(bool dump = true) => _dump = dump;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(bool dump = true)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
bool dump = true		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= true		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
=> _dump = dump		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_dump = dump		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_dump		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
dump		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void IncIndent() => _indent++;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _indent++		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_indent++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
_indent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void DecIndent() => _indent--;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _indent--		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_indent--		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
_indent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JILPrinter Print(string s)
    {
        if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }

        _sb.Append(s);
        return this;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JILPrinter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string s)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string s		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }

        _sb.Append(s);
        return this;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (!_hasIdented)
        {
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!_hasIdented		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
_hasIdented		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            _sb.Capacity += _indent;
            for (int i = 0; i < _indent; i++)
                _sb.Append("\t");
            _hasIdented = true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_sb.Capacity += _indent;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_sb.Capacity += _indent		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_sb.Capacity		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_sb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Capacity		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_indent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
for (int i = 0; i < _indent; i++)
                _sb.Append("\t");		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < _indent		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_indent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_sb.Append("\t");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_sb.Append("\t")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_sb.Append		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_sb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Append		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("\t")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"\t"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"\t"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_hasIdented = true;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_hasIdented = true		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_hasIdented		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_sb.Append(s);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_sb.Append(s)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_sb.Append		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_sb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Append		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return this;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public JILPrinter Println(string s = "")
    {
        Print(s);
        Print("\n");
        _hasIdented = false;
        return this;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JILPrinter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string s = "")		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string s = ""		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= ""		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
""		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
        Print(s);
        Print("\n");
        _hasIdented = false;
        return this;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Print(s);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Print(s)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Print("\n");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Print("\n")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("\n")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"\n"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"\n"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_hasIdented = false;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_hasIdented = false		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_hasIdented		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return this;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) {
        if (_dump)
            Println("#=Instantiate Type=#");
                
        PrintType(loadedType);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJType loadedType, ref int loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJType loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ref int loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        if (_dump)
            Println("#=Instantiate Type=#");
                
        PrintType(loadedType);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (_dump)
            Println("#=Instantiate Type=#");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_dump		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Println("#=Instantiate Type=#");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Println("#=Instantiate Type=#")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Println		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("#=Instantiate Type=#")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"#=Instantiate Type=#"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"#=Instantiate Type=#"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
PrintType(loadedType);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
PrintType(loadedType)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
PrintType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(loadedType)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static unsafe void PrintBytes(byte* bytes, int length)
    {
        for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");
        Console.WriteLine();
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(byte* bytes, int length)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
byte* bytes		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
int length		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");
        Console.WriteLine();
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
for (int i = 0; i < length; i++)
            Console.Write(bytes[i] + " ");		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.Write(bytes[i] + " ");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Console.Write(bytes[i] + " ")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Console.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(bytes[i] + " ")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
bytes[i] + " "		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
bytes[i] + " "		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
bytes[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
bytes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
" "		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Console.WriteLine();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Console.WriteLine()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Console.WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
private static unsafe string GetFieldTypeName(IJField f) {
        if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
        return f.Type.Name;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJField f)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJField f		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }
        return f.Type.Name;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (f is JILField jf) {
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
f is JILField jf		Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILField jf		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jf		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
{
            return f.Parent.GetNameField(jf.TypeRef).Name;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return f.Parent.GetNameField(jf.TypeRef).Name;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
f.Parent.GetNameField(jf.TypeRef).Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f.Parent.GetNameField(jf.TypeRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
f.Parent.GetNameField		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNameField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(jf.TypeRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
jf.TypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
jf.TypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
jf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return f.Type.Name;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
f.Type.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f.Type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void PrintType(IJType t) {
        if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
        
        Println(t.Name).IncIndent();

        t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });
        
        t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });

        DecIndent();
        Println().Println("end");
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJType t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJType t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");
        
        Println(t.Name).IncIndent();

        t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });
        
        t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });

        DecIndent();
        Println().Println("end");
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (t.Type == JTypeType.Struct)
            Print("struct ");
        else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t.Type == JTypeType.Struct		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t.Type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JTypeType.Struct		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Struct		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Print("struct ");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Print("struct ")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("struct ")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"struct "		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"struct "		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
else if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t.Type == JTypeType.Mutable)
            Print("mutable struct ");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t.Type == JTypeType.Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t.Type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JTypeType.Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Print("mutable struct ");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Print("mutable struct ")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("mutable struct ")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"mutable struct "		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"mutable struct "		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Println(t.Name).IncIndent();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Println(t.Name).IncIndent()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Println(t.Name).IncIndent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Println(t.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Println		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IncIndent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        });		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
t.VisitFields(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        })		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
t.VisitFields		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitFields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        })		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => {
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
{
            if (x.IsConst)
                Print("const ");
                
            Println(x.Name);
            var tyName = GetFieldTypeName(x);
            
            if (tyName != "Any") {
                Print("::").Println(tyName);
            }

            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (x.IsConst)
                Print("const ");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
x.IsConst		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsConst		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Print("const ");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Print("const ")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("const ")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"const "		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"const "		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Println(x.Name);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Println(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Println		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var tyName = GetFieldTypeName(x);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var tyName = GetFieldTypeName(x)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tyName = GetFieldTypeName(x)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= GetFieldTypeName(x)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
GetFieldTypeName(x)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetFieldTypeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (tyName != "Any") {
                Print("::").Println(tyName);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
tyName != "Any"		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
tyName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
"Any"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
                Print("::").Println(tyName);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Print("::").Println(tyName);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Print("::").Println(tyName)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print("::").Println		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Print("::")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("::")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"::"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"::"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Println		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(tyName)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
tyName		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tyName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        });		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
t.VisitConstructors(x => {
            PrintMethod(t.Name, x);
            return true;
        })		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
t.VisitConstructors		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitConstructors		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => {
            PrintMethod(t.Name, x);
            return true;
        })		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => {
            PrintMethod(t.Name, x);
            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => {
            PrintMethod(t.Name, x);
            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
{
            PrintMethod(t.Name, x);
            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
PrintMethod(t.Name, x);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
PrintMethod(t.Name, x)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
PrintMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t.Name, x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
DecIndent();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
DecIndent()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
DecIndent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Println().Println("end");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Println().Println("end")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Println().Println		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Println()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Println		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Println		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("end")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"end"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"end"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public void PrintMethod(string name, IJMethod m) {
        
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(string name, IJMethod m)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJMethod m		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override string ToString() => _sb.ToString();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _sb.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_sb.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_sb.ToString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_sb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
namespace runtime.core.JIL;

public class Reader
{
    private static unsafe byte* ReadD(ref byte* p)
    {
        var b = p + 1;
        p += JOp.OpCodeTable[*p].OperandsSize;
        return b;
    }

    private static unsafe T ReadData<T>(ref byte* ptr) where T : unmanaged
    {
        var t = (T*) ptr;
        var v = *t++;
        ptr = (byte*) t;
        return v;
    }

    private static unsafe ref T ReadData<T>(byte* ptr) where T : unmanaged => ref *(T*)ptr;

    public interface IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex);

        unsafe void Visit(IJCodeContext ctx, byte[] code) {
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }
        
        unsafe void Visit(ref byte* p, IJCodeContext ctx) {
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }
    }

    public interface IJILVisitor : IJILBaseVisitor{
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex){}
        
    }
    
    public interface IJILBaseTopVisitor : IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => VisitLoadType(loadedType);
        void VisitLoadType(IJType loadedType);
    }
    
    public interface IJILTopVisitor : IJILBaseTopVisitor {
        void VisitLoadType(IJType loadedType){}
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
namespace runtime.core.JIL;

public class Reader
{
    private static unsafe byte* ReadD(ref byte* p)
    {
        var b = p + 1;
        p += JOp.OpCodeTable[*p].OperandsSize;
        return b;
    }

    private static unsafe T ReadData<T>(ref byte* ptr) where T : unmanaged
    {
        var t = (T*) ptr;
        var v = *t++;
        ptr = (byte*) t;
        return v;
    }

    private static unsafe ref T ReadData<T>(byte* ptr) where T : unmanaged => ref *(T*)ptr;

    public interface IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex);

        unsafe void Visit(IJCodeContext ctx, byte[] code) {
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }
        
        unsafe void Visit(ref byte* p, IJCodeContext ctx) {
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }
    }

    public interface IJILVisitor : IJILBaseVisitor{
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex){}
        
    }
    
    public interface IJILBaseTopVisitor : IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => VisitLoadType(loadedType);
        void VisitLoadType(IJType loadedType);
    }
    
    public interface IJILTopVisitor : IJILBaseTopVisitor {
        void VisitLoadType(IJType loadedType){}
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class Reader
{
    private static unsafe byte* ReadD(ref byte* p)
    {
        var b = p + 1;
        p += JOp.OpCodeTable[*p].OperandsSize;
        return b;
    }

    private static unsafe T ReadData<T>(ref byte* ptr) where T : unmanaged
    {
        var t = (T*) ptr;
        var v = *t++;
        ptr = (byte*) t;
        return v;
    }

    private static unsafe ref T ReadData<T>(byte* ptr) where T : unmanaged => ref *(T*)ptr;

    public interface IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex);

        unsafe void Visit(IJCodeContext ctx, byte[] code) {
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }
        
        unsafe void Visit(ref byte* p, IJCodeContext ctx) {
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }
    }

    public interface IJILVisitor : IJILBaseVisitor{
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex){}
        
    }
    
    public interface IJILBaseTopVisitor : IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => VisitLoadType(loadedType);
        void VisitLoadType(IJType loadedType);
    }
    
    public interface IJILTopVisitor : IJILBaseTopVisitor {
        void VisitLoadType(IJType loadedType){}
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
private static unsafe byte* ReadD(ref byte* p)
    {
        var b = p + 1;
        p += JOp.OpCodeTable[*p].OperandsSize;
        return b;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(ref byte* p)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ref byte* p		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        var b = p + 1;
        p += JOp.OpCodeTable[*p].OperandsSize;
        return b;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var b = p + 1;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var b = p + 1		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
b = p + 1		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= p + 1		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
p + 1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
p += JOp.OpCodeTable[*p].OperandsSize;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
p += JOp.OpCodeTable[*p].OperandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JOp.OpCodeTable[*p].OperandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JOp.OpCodeTable[*p]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
JOp.OpCodeTable		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodeTable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[*p]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
*p		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
*p		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OperandsSize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return b;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
b		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private static unsafe T ReadData<T>(ref byte* ptr) where T : unmanaged
    {
        var t = (T*) ptr;
        var v = *t++;
        ptr = (byte*) t;
        return v;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(ref byte* ptr)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ref byte* ptr		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        var t = (T*) ptr;
        var v = *t++;
        ptr = (byte*) t;
        return v;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var t = (T*) ptr;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var t = (T*) ptr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t = (T*) ptr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= (T*) ptr		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
(T*) ptr		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
T*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var v = *t++;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var v = *t++		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v = *t++		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= *t++		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
*t++		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
t++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ptr = (byte*) t;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ptr = (byte*) t		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(byte*) t		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return v;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private static unsafe ref T ReadData<T>(byte* ptr) where T : unmanaged => ref *(T*)ptr;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ref T		Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(byte* ptr)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
byte* ptr		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> ref *(T*)ptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ref *(T*)ptr		Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax
*(T*)ptr		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
(T*)ptr		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
T*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public interface IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex);

        unsafe void Visit(IJCodeContext ctx, byte[] code) {
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }
        
        unsafe void Visit(ref byte* p, IJCodeContext ctx) {
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }
    }		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJType loadedType, ref int loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJType loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ref int loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
unsafe void Visit(IJCodeContext ctx, byte[] code) {
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJCodeContext ctx, byte[] code)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJCodeContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
byte[] code		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{
            fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
fixed (byte* ptr = code) {
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax
byte* ptr = code		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
ptr = code		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= code		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                byte* mptr = ptr;
                var eptr = ptr + code.Length;
                while (mptr < eptr)
                    Visit(ref mptr, ctx);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
byte* mptr = ptr;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
byte* mptr = ptr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
mptr = ptr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= ptr		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var eptr = ptr + code.Length;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var eptr = ptr + code.Length		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
eptr = ptr + code.Length		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= ptr + code.Length		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
ptr + code.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
code.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
while (mptr < eptr)
                    Visit(ref mptr, ctx);		Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax
mptr < eptr		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
mptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
eptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Visit(ref mptr, ctx);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Visit(ref mptr, ctx)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Visit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ref mptr, ctx)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ref mptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unsafe void Visit(ref byte* p, IJCodeContext ctx) {
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(ref byte* p, IJCodeContext ctx)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ref byte* p		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJCodeContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
switch (*p) {
                case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
*p		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case JOp.LoadTypeOp:
                    ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));
                    var loadedType = ctx.GetCtxType(loadedTypeIndex);
                    if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");
                    VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);
                    return;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case JOp.LoadTypeOp:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
JOp.LoadTypeOp		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LoadTypeOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p));		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ref var loadedTypeIndex = ref ReadData<int>(ReadD(ref p))		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ref var		Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
loadedTypeIndex = ref ReadData<int>(ReadD(ref p))		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= ref ReadData<int>(ReadD(ref p))		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
ref ReadData<int>(ReadD(ref p))		Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax
ReadData<int>(ReadD(ref p))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ReadData<int>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<int>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(ReadD(ref p))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ReadD(ref p)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ReadD(ref p)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ReadD		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ref p)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ref p		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var loadedType = ctx.GetCtxType(loadedTypeIndex);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var loadedType = ctx.GetCtxType(loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
loadedType = ctx.GetCtxType(loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= ctx.GetCtxType(loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
ctx.GetCtxType(loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.GetCtxType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetCtxType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (loadedType == null)
                        throw new InternalJuliaException("Type Not Loaded!");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
loadedType == null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
throw new InternalJuliaException("Type Not Loaded!");		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new InternalJuliaException("Type Not Loaded!")		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
InternalJuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Type Not Loaded!")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Type Not Loaded!"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Type Not Loaded!"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
VisitLoadTypeImpl(loadedType, ref loadedTypeIndex);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
VisitLoadTypeImpl(loadedType, ref loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitLoadTypeImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(loadedType, ref loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ref loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
public interface IJILVisitor : IJILBaseVisitor{
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex){}
        
    }		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
: IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex){}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJType loadedType, ref int loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJType loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ref int loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public interface IJILBaseTopVisitor : IJILBaseVisitor {
        void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => VisitLoadType(loadedType);
        void VisitLoadType(IJType loadedType);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
: IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => VisitLoadType(loadedType);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJType loadedType, ref int loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJType loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ref int loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> VisitLoadType(loadedType)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
VisitLoadType(loadedType)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitLoadType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(loadedType)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void VisitLoadType(IJType loadedType);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJType loadedType)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJType loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public interface IJILTopVisitor : IJILBaseTopVisitor {
        void VisitLoadType(IJType loadedType){}
    }		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
: IJILBaseTopVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJILBaseTopVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJILBaseTopVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void VisitLoadType(IJType loadedType){}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJType loadedType)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJType loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
namespace runtime.core.JIL;

public class Serialization
{
    
    
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
namespace runtime.core.JIL;

public class Serialization
{
    
    
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class Serialization
{
    
    
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
using System;using System.Collections.Generic;using System.Reflection.Emit;using runtime.core.JIL;namespace runtime.core.Runtime;public sealed class JRootModule : JRuntimeModule{    private static readonly Dictionary<string, JRootModule> RootModules = new();    private readonly ModuleBuilder _m;    internal JRootModule(ModuleBuilder m, JILModule jm, JRuntimeContext ctx) : base(jm, ctx, null) {        _m = m;        Parent = this;        RootModules.Add(jm.Name, this);    }    public static JRootModule GetRootModule(string name) {        if (RootModules.TryGetValue(name, out JRootModule m))            return m;        return null;    }    internal static JRootModule CreateRootModule(string name) {        // var asm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(name + "Asm"), AssemblyBuilderAccess.Run);        //asm.DefineDynamicModule(name)        var mods = new IJModule[1];        var tys = Array.Empty<IJType>();        var jrc = new JRuntimeContext(new[] { name }, mods, tys);        var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);        jm.Ctx = jrc;                JRootModule em = new(null, jm, jrc);        mods[0] = em;        jm.Parent = em;        return em;    }}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Collections.Generic;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Collections.Generic		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Collections		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Collections		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Generic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Reflection.Emit;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Reflection.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.JIL;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core.Runtime;public sealed class JRootModule : JRuntimeModule{    private static readonly Dictionary<string, JRootModule> RootModules = new();    private readonly ModuleBuilder _m;    internal JRootModule(ModuleBuilder m, JILModule jm, JRuntimeContext ctx) : base(jm, ctx, null) {        _m = m;        Parent = this;        RootModules.Add(jm.Name, this);    }    public static JRootModule GetRootModule(string name) {        if (RootModules.TryGetValue(name, out JRootModule m))            return m;        return null;    }    internal static JRootModule CreateRootModule(string name) {        // var asm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(name + "Asm"), AssemblyBuilderAccess.Run);        //asm.DefineDynamicModule(name)        var mods = new IJModule[1];        var tys = Array.Empty<IJType>();        var jrc = new JRuntimeContext(new[] { name }, mods, tys);        var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);        jm.Ctx = jrc;                JRootModule em = new(null, jm, jrc);        mods[0] = em;        jm.Parent = em;        return em;    }}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public sealed class JRootModule : JRuntimeModule{    private static readonly Dictionary<string, JRootModule> RootModules = new();    private readonly ModuleBuilder _m;    internal JRootModule(ModuleBuilder m, JILModule jm, JRuntimeContext ctx) : base(jm, ctx, null) {        _m = m;        Parent = this;        RootModules.Add(jm.Name, this);    }    public static JRootModule GetRootModule(string name) {        if (RootModules.TryGetValue(name, out JRootModule m))            return m;        return null;    }    internal static JRootModule CreateRootModule(string name) {        // var asm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(name + "Asm"), AssemblyBuilderAccess.Run);        //asm.DefineDynamicModule(name)        var mods = new IJModule[1];        var tys = Array.Empty<IJType>();        var jrc = new JRuntimeContext(new[] { name }, mods, tys);        var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);        jm.Ctx = jrc;                JRootModule em = new(null, jm, jrc);        mods[0] = em;        jm.Parent = em;        return em;    }}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JRuntimeModule		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JRuntimeModule		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JRuntimeModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private static readonly Dictionary<string, JRootModule> RootModules = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
Dictionary<string, JRootModule> RootModules = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
Dictionary<string, JRootModule>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<string, JRootModule>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
JRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RootModules = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
private readonly ModuleBuilder _m;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
ModuleBuilder _m		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_m		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal JRootModule(ModuleBuilder m, JILModule jm, JRuntimeContext ctx) : base(jm, ctx, null) {        _m = m;        Parent = this;        RootModules.Add(jm.Name, this);    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ModuleBuilder m, JILModule jm, JRuntimeContext ctx)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ModuleBuilder m		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILModule jm		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JRuntimeContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JRuntimeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: base(jm, ctx, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(jm, ctx, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
jm		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
jm		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{        _m = m;        Parent = this;        RootModules.Add(jm.Name, this);    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_m = m;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_m = m		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent = this;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Parent = this		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
RootModules.Add(jm.Name, this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
RootModules.Add(jm.Name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
RootModules.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
RootModules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(jm.Name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
jm.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
jm.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
jm		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public static JRootModule GetRootModule(string name) {        if (RootModules.TryGetValue(name, out JRootModule m))            return m;        return null;    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{        if (RootModules.TryGetValue(name, out JRootModule m))            return m;        return null;    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (RootModules.TryGetValue(name, out JRootModule m))            return m;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
RootModules.TryGetValue(name, out JRootModule m)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
RootModules.TryGetValue		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
RootModules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TryGetValue		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, out JRootModule m)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out JRootModule m		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JRootModule m		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax
JRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
return m;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return null;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
internal static JRootModule CreateRootModule(string name) {        // var asm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(name + "Asm"), AssemblyBuilderAccess.Run);        //asm.DefineDynamicModule(name)        var mods = new IJModule[1];        var tys = Array.Empty<IJType>();        var jrc = new JRuntimeContext(new[] { name }, mods, tys);        var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);        jm.Ctx = jrc;                JRootModule em = new(null, jm, jrc);        mods[0] = em;        jm.Parent = em;        return em;    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{        // var asm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(name + "Asm"), AssemblyBuilderAccess.Run);        //asm.DefineDynamicModule(name)        var mods = new IJModule[1];        var tys = Array.Empty<IJType>();        var jrc = new JRuntimeContext(new[] { name }, mods, tys);        var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);        jm.Ctx = jrc;                JRootModule em = new(null, jm, jrc);        mods[0] = em;        jm.Parent = em;        return em;    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var mods = new IJModule[1];		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var mods = new IJModule[1]		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mods = new IJModule[1]		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new IJModule[1]		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new IJModule[1]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax
IJModule[1]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[1]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
var tys = Array.Empty<IJType>();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var tys = Array.Empty<IJType>()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tys = Array.Empty<IJType>()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Array.Empty<IJType>()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Array.Empty<IJType>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Array.Empty<IJType>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Empty<IJType>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJType>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
var jrc = new JRuntimeContext(new[] { name }, mods, tys);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var jrc = new JRuntimeContext(new[] { name }, mods, tys)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jrc = new JRuntimeContext(new[] { name }, mods, tys)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new JRuntimeContext(new[] { name }, mods, tys)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new JRuntimeContext(new[] { name }, mods, tys)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JRuntimeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(new[] { name }, mods, tys)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
new[] { name }		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
new[] { name }		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax
{ name }		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mods		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mods		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tys		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tys		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jm = new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new JILModule(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JILModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0, JModuleFlags.Bare, JExprFlags.None, Array.Empty<byte>(),             Array.Empty<JNameRef>(), Array.Empty<JILField>(), null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
JModuleFlags.Bare		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JModuleFlags.Bare		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JModuleFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Bare		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JExprFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JExprFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Array.Empty<byte>()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Array.Empty<byte>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Array.Empty<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Empty<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Array.Empty<JNameRef>()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Array.Empty<JNameRef>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Array.Empty<JNameRef>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Empty<JNameRef>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<JNameRef>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Array.Empty<JILField>()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Array.Empty<JILField>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Array.Empty<JILField>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Empty<JILField>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<JILField>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
jm.Ctx = jrc;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
jm.Ctx = jrc		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
jm.Ctx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
jm		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jrc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JRootModule em = new(null, jm, jrc);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
JRootModule em = new(null, jm, jrc)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
em = new(null, jm, jrc)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(null, jm, jrc)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(null, jm, jrc)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(null, jm, jrc)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
jm		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
jm		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jrc		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
jrc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mods[0] = em;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
mods[0] = em		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
mods[0]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
mods		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[0]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
em		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jm.Parent = em;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
jm.Parent = em		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
jm.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
jm		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
em		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return em;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
em		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using runtime.core.JIL;

namespace runtime.core.Runtime;

public class JRuntimeExpr : IJExpr
{
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }
    
    internal JRuntimeExpr(JILExpr e, IJExpr parent) {
        Code = e.Code;
        VarTable = e.VarTable;
        Names = e.Names;
        Parent = parent;
        Modifiers = e.Modifiers;
    }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return false;
    }
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    
    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    public override string ToString() {
        JILPrinter p = new();
        ((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);
        return p.ToString();
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.JIL;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core.Runtime;

public class JRuntimeExpr : IJExpr
{
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }
    
    internal JRuntimeExpr(JILExpr e, IJExpr parent) {
        Code = e.Code;
        VarTable = e.VarTable;
        Names = e.Names;
        Parent = parent;
        Modifiers = e.Modifiers;
    }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return false;
    }
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    
    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    public override string ToString() {
        JILPrinter p = new();
        ((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);
        return p.ToString();
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JRuntimeExpr : IJExpr
{
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }
    
    internal JRuntimeExpr(JILExpr e, IJExpr parent) {
        Code = e.Code;
        VarTable = e.VarTable;
        Names = e.Names;
        Parent = parent;
        Modifiers = e.Modifiers;
    }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return false;
    }
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    
    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    public override string ToString() {
        JILPrinter p = new();
        ((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);
        return p.ToString();
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public readonly byte[] Code;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte[] Code		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly JNameRef[] VarTable;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JNameRef[] VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JNameRef[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly JILField[] Names;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JILField[] Names		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILField[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public JExprFlags Modifiers { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJExpr Parent { get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal JRuntimeExpr(JILExpr e, IJExpr parent) {
        Code = e.Code;
        VarTable = e.VarTable;
        Names = e.Names;
        Parent = parent;
        Modifiers = e.Modifiers;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JILExpr e, IJExpr parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILExpr e		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJExpr parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        Code = e.Code;
        VarTable = e.VarTable;
        Names = e.Names;
        Parent = parent;
        Modifiers = e.Modifiers;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Code = e.Code;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Code = e.Code		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e.Code		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VarTable = e.VarTable;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
VarTable = e.VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e.VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Names = e.Names;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Names = e.Names		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e.Names		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent = parent;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Parent = parent		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modifiers = e.Modifiers;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Modifiers = e.Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e.Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return false;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return false;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!v(Names[va.CompileTimeNameRefIndex])		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
v(Names[va.CompileTimeNameRefIndex])		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Names[va.CompileTimeNameRefIndex])		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Names[va.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Names[va.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[va.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
va.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
va.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
va		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, object, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, object, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < Names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (!v(Names[i], null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!v(Names[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
v(Names[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Names[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Names[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Names[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Names[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Names[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name, out JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public override string ToString() {
        JILPrinter p = new();
        ((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);
        return p.ToString();
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
        JILPrinter p = new();
        ((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);
        return p.ToString();
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
JILPrinter p = new();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
JILPrinter p = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILPrinter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
p = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
((Reader.IJILBaseVisitor) p).Visit(Parent.Context, Code)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
((Reader.IJILBaseVisitor) p).Visit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
((Reader.IJILBaseVisitor) p)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(Reader.IJILBaseVisitor) p		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
Reader.IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Reader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJILBaseVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Visit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Parent.Context, Code)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Parent.Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Parent.Context		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return p.ToString();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
p.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
p.ToString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
using System;
using System.Collections.Generic;
using runtime.core.JIL;
using runtime.Utils;

namespace runtime.core.Runtime;

public sealed class JRuntimeJILMethod : JILMethod{
    internal JRuntimeJILMethod(JILMethod j, JRuntimeModule parent) : 
        base(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent) {}
}

public sealed class JRuntimeFunction : IJFunction
{
    private readonly List<IJMethod> _methods;
    public string Name { get; }
    
    internal JRuntimeFunction(string name, IJMethod[] mts) {
        Name = name;
        _methods = new(mts);
    }

    public bool VisitMethods(Func<IJMethod, bool> v) => _methods.Visit(v);

    public object Invoke(object[] parameters)
    {
        return null;
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Collections.Generic;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Collections.Generic		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Collections		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Collections		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Generic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.JIL;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.Utils;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.Utils		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Utils		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core.Runtime;

public sealed class JRuntimeJILMethod : JILMethod{
    internal JRuntimeJILMethod(JILMethod j, JRuntimeModule parent) : 
        base(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent) {}
}

public sealed class JRuntimeFunction : IJFunction
{
    private readonly List<IJMethod> _methods;
    public string Name { get; }
    
    internal JRuntimeFunction(string name, IJMethod[] mts) {
        Name = name;
        _methods = new(mts);
    }

    public bool VisitMethods(Func<IJMethod, bool> v) => _methods.Visit(v);

    public object Invoke(object[] parameters)
    {
        return null;
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public sealed class JRuntimeJILMethod : JILMethod{
    internal JRuntimeJILMethod(JILMethod j, JRuntimeModule parent) : 
        base(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent) {}
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JILMethod		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JILMethod		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JILMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal JRuntimeJILMethod(JILMethod j, JRuntimeModule parent) : 
        base(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent) {}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JILMethod j, JRuntimeModule parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILMethod j		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JRuntimeModule parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JRuntimeModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: 
        base(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(j.MethodModifiers, j.Parameters, j.Modifiers, j.Code, j.VarTable, j.Names, parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
j.MethodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
j.MethodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
j		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MethodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
j.Parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
j.Parameters		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
j		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
j.Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
j.Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
j		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
j.Code		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
j.Code		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
j		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
j.VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
j.VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
j		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
j.Names		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
j.Names		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
j		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public sealed class JRuntimeFunction : IJFunction
{
    private readonly List<IJMethod> _methods;
    public string Name { get; }
    
    internal JRuntimeFunction(string name, IJMethod[] mts) {
        Name = name;
        _methods = new(mts);
    }

    public bool VisitMethods(Func<IJMethod, bool> v) => _methods.Visit(v);

    public object Invoke(object[] parameters)
    {
        return null;
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: IJFunction		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJFunction		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private readonly List<IJMethod> _methods;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<IJMethod> _methods		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<IJMethod>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJMethod>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_methods		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public string Name { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal JRuntimeFunction(string name, IJMethod[] mts) {
        Name = name;
        _methods = new(mts);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(string name, IJMethod[] mts)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJMethod[] mts		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJMethod[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{
        Name = name;
        _methods = new(mts);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Name = name;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Name = name		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_methods = new(mts);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_methods = new(mts)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_methods		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new(mts)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(mts)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
mts		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mts		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitMethods(Func<IJMethod, bool> v) => _methods.Visit(v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJMethod, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJMethod, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _methods.Visit(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_methods.Visit(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_methods.Visit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_methods		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Visit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public object Invoke(object[] parameters)
    {
        return null;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(object[] parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
object[] parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
object[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{
        return null;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return null;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
using System;
using System.Collections.Generic;
using runtime.core.JIL;
using runtime.parse;
using runtime.Utils;

namespace runtime.core.Runtime;

//High Read/Write Speed for Globals
//High Read for Names
//Slow Write for Names
//Low Memory for Names & Globals
public class JRuntimeModule : JRuntimeExpr, IJModule {
    private readonly MInternContainer<string> _names;
    private readonly List<IJName> names;
    
    public string Name { get; }
    public JModuleFlags ModuleModifiers { get; }
    public IJCodeContext Context { get; }

    internal JRuntimeModule(JILModule m, JRuntimeContext ctx, JRuntimeModule parent) : base(m, parent){
        Context = ctx;
        Name = m.Name;
        ModuleModifiers = m.ModuleModifiers;
        names = new(m.Names.Length);
        for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));
    }
    
    public bool GetNameV<T>(JNameRef r, out T t) { throw new NotImplementedException(); }
    public JRuntimeExpr EvalToExpression(string s) => new JuliaStaticCompiler().Compile(new JuliappParser(s), this);
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Collections.Generic;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Collections.Generic		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Collections		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Collections		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Generic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.JIL;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.parse;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.parse		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parse		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.Utils;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.Utils		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Utils		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core.Runtime;

//High Read/Write Speed for Globals
//High Read for Names
//Slow Write for Names
//Low Memory for Names & Globals
public class JRuntimeModule : JRuntimeExpr, IJModule {
    private readonly MInternContainer<string> _names;
    private readonly List<IJName> names;
    
    public string Name { get; }
    public JModuleFlags ModuleModifiers { get; }
    public IJCodeContext Context { get; }

    internal JRuntimeModule(JILModule m, JRuntimeContext ctx, JRuntimeModule parent) : base(m, parent){
        Context = ctx;
        Name = m.Name;
        ModuleModifiers = m.ModuleModifiers;
        names = new(m.Names.Length);
        for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));
    }
    
    public bool GetNameV<T>(JNameRef r, out T t) { throw new NotImplementedException(); }
    public JRuntimeExpr EvalToExpression(string s) => new JuliaStaticCompiler().Compile(new JuliappParser(s), this);
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JRuntimeModule : JRuntimeExpr, IJModule {
    private readonly MInternContainer<string> _names;
    private readonly List<IJName> names;
    
    public string Name { get; }
    public JModuleFlags ModuleModifiers { get; }
    public IJCodeContext Context { get; }

    internal JRuntimeModule(JILModule m, JRuntimeContext ctx, JRuntimeModule parent) : base(m, parent){
        Context = ctx;
        Name = m.Name;
        ModuleModifiers = m.ModuleModifiers;
        names = new(m.Names.Length);
        for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));
    }
    
    public bool GetNameV<T>(JNameRef r, out T t) { throw new NotImplementedException(); }
    public JRuntimeExpr EvalToExpression(string s) => new JuliaStaticCompiler().Compile(new JuliappParser(s), this);
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JRuntimeExpr, IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JRuntimeExpr		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JRuntimeExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private readonly MInternContainer<string> _names;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
MInternContainer<string> _names		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
MInternContainer<string>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<string>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_names		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private readonly List<IJName> names;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<IJName> names		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<IJName>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJName>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public string Name { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JModuleFlags ModuleModifiers { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JModuleFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJCodeContext Context { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal JRuntimeModule(JILModule m, JRuntimeContext ctx, JRuntimeModule parent) : base(m, parent){
        Context = ctx;
        Name = m.Name;
        ModuleModifiers = m.ModuleModifiers;
        names = new(m.Names.Length);
        for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JILModule m, JRuntimeContext ctx, JRuntimeModule parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILModule m		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JRuntimeContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JRuntimeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JRuntimeModule parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JRuntimeModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: base(m, parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(m, parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        Context = ctx;
        Name = m.Name;
        ModuleModifiers = m.ModuleModifiers;
        names = new(m.Names.Length);
        for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Context = ctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Context = ctx		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name = m.Name;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Name = m.Name		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
m.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleModifiers = m.ModuleModifiers;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ModuleModifiers = m.ModuleModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
ModuleModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
m.ModuleModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names = new(m.Names.Length);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
names = new(m.Names.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new(m.Names.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(m.Names.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
m.Names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
m.Names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
m.Names		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
for (int i = 0; i < names.Count; i++)
            names[i] = new JRuntimeName(m.Names[i], new(i, 0));		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < names.Count		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names[i] = new JRuntimeName(m.Names[i], new(i, 0));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
names[i] = new JRuntimeName(m.Names[i], new(i, 0))		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
names[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new JRuntimeName(m.Names[i], new(i, 0))		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JRuntimeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(m.Names[i], new(i, 0))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
m.Names[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
m.Names[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
m.Names		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new(i, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
new(i, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(i, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public bool GetNameV<T>(JNameRef r, out T t) { throw new NotImplementedException(); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(JNameRef r, out T t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef r		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out T t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ throw new NotImplementedException(); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public JRuntimeExpr EvalToExpression(string s) => new JuliaStaticCompiler().Compile(new JuliappParser(s), this);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JRuntimeExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string s)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string s		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> new JuliaStaticCompiler().Compile(new JuliappParser(s), this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
new JuliaStaticCompiler().Compile(new JuliappParser(s), this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
new JuliaStaticCompiler().Compile		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
new JuliaStaticCompiler()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaStaticCompiler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(new JuliappParser(s), this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
new JuliappParser(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
new JuliappParser(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliappParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
using System;
using System.Linq;
using runtime.core.JIL;
using runtime.Utils;

namespace runtime.core.Runtime;

public class JRuntimeName : IJName {
    private readonly IJField _field;

    public object Value { get; set; }
    public object ObjectValue { get => Value; set => Value = value; }
    public string Name => _field.Name;
    public IJType Type => _field.Type;
    public JFieldFlags Modifiers => _field.Modifiers;
    public JNameRef NameRef { get; }
    
    public JRuntimeName(IJField field, JNameRef nameRef, object v = null) {
        _field = field;
        Value = v;
        NameRef = nameRef;
    }
}
    
public class JRuntimeType : IJType {
    public readonly JILField[] Fields;
    private readonly JRuntimeFunction _constructors;

    public string Name { get; }
    public JTypeType Type { get; }
    public JExprFlags Modifiers => JExprFlags.None;
    public IJExpr Parent { get; internal set; }
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.VisitMethods(v);

    internal JRuntimeType(JILType type) {
        Type = type.Type;
        Name = type.Name;
        Fields = type.Fields;
        _constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());
    }

    public bool VisitVariables(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Linq;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Linq		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Linq		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.JIL;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.Utils;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.Utils		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Utils		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core.Runtime;

public class JRuntimeName : IJName {
    private readonly IJField _field;

    public object Value { get; set; }
    public object ObjectValue { get => Value; set => Value = value; }
    public string Name => _field.Name;
    public IJType Type => _field.Type;
    public JFieldFlags Modifiers => _field.Modifiers;
    public JNameRef NameRef { get; }
    
    public JRuntimeName(IJField field, JNameRef nameRef, object v = null) {
        _field = field;
        Value = v;
        NameRef = nameRef;
    }
}
    
public class JRuntimeType : IJType {
    public readonly JILField[] Fields;
    private readonly JRuntimeFunction _constructors;

    public string Name { get; }
    public JTypeType Type { get; }
    public JExprFlags Modifiers => JExprFlags.None;
    public IJExpr Parent { get; internal set; }
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.VisitMethods(v);

    internal JRuntimeType(JILType type) {
        Type = type.Type;
        Name = type.Name;
        Fields = type.Fields;
        _constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());
    }

    public bool VisitVariables(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JRuntimeName : IJName {
    private readonly IJField _field;

    public object Value { get; set; }
    public object ObjectValue { get => Value; set => Value = value; }
    public string Name => _field.Name;
    public IJType Type => _field.Type;
    public JFieldFlags Modifiers => _field.Modifiers;
    public JNameRef NameRef { get; }
    
    public JRuntimeName(IJField field, JNameRef nameRef, object v = null) {
        _field = field;
        Value = v;
        NameRef = nameRef;
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: IJName		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJName		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private readonly IJField _field;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IJField _field		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_field		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public object Value { get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public object ObjectValue { get => Value; set => Value = value; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get => Value; set => Value = value; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get => Value;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
=> Value		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
set => Value = value;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
=> Value = value		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Value = value		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public string Name => _field.Name;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _field.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_field.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_field		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJType Type => _field.Type;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _field.Type		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_field.Type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_field		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JFieldFlags Modifiers => _field.Modifiers;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JFieldFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _field.Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_field.Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_field		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JNameRef NameRef { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JRuntimeName(IJField field, JNameRef nameRef, object v = null) {
        _field = field;
        Value = v;
        NameRef = nameRef;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(IJField field, JNameRef nameRef, object v = null)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJField field		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
object v = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
        _field = field;
        Value = v;
        NameRef = nameRef;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_field = field;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_field = field		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_field		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
field		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Value = v;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Value = v		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NameRef = nameRef;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
NameRef = nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JRuntimeType : IJType {
    public readonly JILField[] Fields;
    private readonly JRuntimeFunction _constructors;

    public string Name { get; }
    public JTypeType Type { get; }
    public JExprFlags Modifiers => JExprFlags.None;
    public IJExpr Parent { get; internal set; }
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.VisitMethods(v);

    internal JRuntimeType(JILType type) {
        Type = type.Type;
        Name = type.Name;
        Fields = type.Fields;
        _constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());
    }

    public bool VisitVariables(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: IJType		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public readonly JILField[] Fields;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JILField[] Fields		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILField[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private readonly JRuntimeFunction _constructors;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JRuntimeFunction _constructors		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JRuntimeFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_constructors		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public string Name { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JTypeType Type { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JExprFlags Modifiers => JExprFlags.None;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> JExprFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
JExprFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJExpr Parent { get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Fields.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Fields.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Fields.Visit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Visit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.VisitMethods(v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJMethod, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJMethod, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _constructors.VisitMethods(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_constructors.VisitMethods(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_constructors.VisitMethods		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_constructors		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitMethods		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal JRuntimeType(JILType type) {
        Type = type.Type;
        Name = type.Name;
        Fields = type.Fields;
        _constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JILType type)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILType type		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        Type = type.Type;
        Name = type.Name;
        Fields = type.Fields;
        _constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Type = type.Type;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Type = type.Type		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
type.Type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name = type.Name;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Name = type.Name		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
type.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Fields = type.Fields;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Fields = type.Fields		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
type.Fields		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray());		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_constructors = new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray())		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_constructors		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray())		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(type.Name, type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
type.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
type.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null)).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
type.Constructors.Select(x => (IJMethod) new JRuntimeJILMethod(x, null))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
type.Constructors.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
type.Constructors		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Constructors		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => (IJMethod) new JRuntimeJILMethod(x, null))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => (IJMethod) new JRuntimeJILMethod(x, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => (IJMethod) new JRuntimeJILMethod(x, null)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
(IJMethod) new JRuntimeJILMethod(x, null)		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new JRuntimeJILMethod(x, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JRuntimeJILMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public bool VisitVariables(Func<IJField, bool> v) => Fields.Visit(x => v(x));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Fields.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Fields.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Fields.Visit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Visit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, object, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, object, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < Fields.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Fields.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (!v(Fields[i], null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!v(Fields[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
v(Fields[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Fields[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Fields[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Fields[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Fields[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Fields[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name, out JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
using System;
using System.Text;

namespace runtime.core
{
    public class JuliaException : Exception
    {
        protected readonly string _message;
        public JuliaException(string message) => _message = message;
        public JuliaException() => _message = "";
        
        public JuliaException(params object[] messages) {
            StringBuilder sb = new StringBuilder();
            foreach(var v in messages)
                sb.Append(v);
            _message = sb.ToString();
        }

        public override string Message => _message;
    }

    public class InternalJuliaException : JuliaException
    {
        public InternalJuliaException(string message) : base(message){}
        public InternalJuliaException() : base(){}
        
        public InternalJuliaException(params object[] messages) : base(messages){}
        
        public override string Message => "Internal Julia Exception. Please report this exception!\n" + _message;
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Text;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Text		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Text		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core
{
    public class JuliaException : Exception
    {
        protected readonly string _message;
        public JuliaException(string message) => _message = message;
        public JuliaException() => _message = "";
        
        public JuliaException(params object[] messages) {
            StringBuilder sb = new StringBuilder();
            foreach(var v in messages)
                sb.Append(v);
            _message = sb.ToString();
        }

        public override string Message => _message;
    }

    public class InternalJuliaException : JuliaException
    {
        public InternalJuliaException(string message) : base(message){}
        public InternalJuliaException() : base(){}
        
        public InternalJuliaException(params object[] messages) : base(messages){}
        
        public override string Message => "Internal Julia Exception. Please report this exception!\n" + _message;
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JuliaException : Exception
    {
        protected readonly string _message;
        public JuliaException(string message) => _message = message;
        public JuliaException() => _message = "";
        
        public JuliaException(params object[] messages) {
            StringBuilder sb = new StringBuilder();
            foreach(var v in messages)
                sb.Append(v);
            _message = sb.ToString();
        }

        public override string Message => _message;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: Exception		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
Exception		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
Exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
protected readonly string _message;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
string _message		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_message		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public JuliaException(string message) => _message = message;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(string message)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string message		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _message = message		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_message = message		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_message		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
message		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JuliaException() => _message = "";		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _message = ""		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_message = ""		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_message		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
""		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public JuliaException(params object[] messages) {
            StringBuilder sb = new StringBuilder();
            foreach(var v in messages)
                sb.Append(v);
            _message = sb.ToString();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(params object[] messages)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
params object[] messages		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
object[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{
            StringBuilder sb = new StringBuilder();
            foreach(var v in messages)
                sb.Append(v);
            _message = sb.ToString();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
StringBuilder sb = new StringBuilder();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
StringBuilder sb = new StringBuilder()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
StringBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sb = new StringBuilder()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new StringBuilder()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new StringBuilder()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
StringBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
foreach(var v in messages)
                sb.Append(v);		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
messages		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sb.Append(v);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
sb.Append(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
sb.Append		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
sb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Append		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_message = sb.ToString();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_message = sb.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_message		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sb.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
sb.ToString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
sb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public override string Message => _message;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _message		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_message		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class InternalJuliaException : JuliaException
    {
        public InternalJuliaException(string message) : base(message){}
        public InternalJuliaException() : base(){}
        
        public InternalJuliaException(params object[] messages) : base(messages){}
        
        public override string Message => "Internal Julia Exception. Please report this exception!\n" + _message;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public InternalJuliaException(string message) : base(message){}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(string message)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string message		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(message)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(message)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
message		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
message		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public InternalJuliaException() : base(){}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
: base()		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public InternalJuliaException(params object[] messages) : base(messages){}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(params object[] messages)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
params object[] messages		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
object[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
: base(messages)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(messages)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
messages		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
messages		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override string Message => "Internal Julia Exception. Please report this exception!\n" + _message;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> "Internal Julia Exception. Please report this exception!\n" + _message		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
"Internal Julia Exception. Please report this exception!\n" + _message		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Internal Julia Exception. Please report this exception!\n"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_message		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using System.Linq.Expressions;
using System.Reflection;

namespace runtime.core
{
    public class EmptyClass{private EmptyClass(){}}
    
    public class SharpReflect
    {
        public readonly static BindingFlags FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic;
        
        public static MethodInfo GetMethod<T>(string methodName, params Type[] types) => typeof(T).GetMethod(methodName, FLAGS, null, types, null);
        public static MethodInfo GetMethod<T, T1>(string methodName) => GetMethod<T>(methodName, typeof(T1));
        public static MethodInfo GetMethod<T, T1, T2>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2));
        public static MethodInfo GetMethod<T, T1, T2, T3>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4, T5>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        public static MethodInfo GetMethod(Type t, string methodName, params Type[] types) => t.GetMethod(methodName, FLAGS, null, types, null);
         
        
        public static ConstructorInfo GetConstructor<T>(params Type[] types) => typeof(T).GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor(Type t, params Type[] types) => t.GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor<T, T1>() => GetConstructor<T>(typeof(T1));
        public static ConstructorInfo GetConstructor<T, T1, T2>() => GetConstructor<T>( typeof(T1), typeof(T2));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4, T5>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));


        public static FieldInfo GetField<T>(string name) => typeof(T).GetField(name, FLAGS);
        public static FieldInfo GetField(Type t, string name) => t.GetField(name, FLAGS);

    }

}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Linq.Expressions;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Linq.Expressions		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Linq		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Linq		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Expressions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Reflection;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core
{
    public class EmptyClass{private EmptyClass(){}}
    
    public class SharpReflect
    {
        public readonly static BindingFlags FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic;
        
        public static MethodInfo GetMethod<T>(string methodName, params Type[] types) => typeof(T).GetMethod(methodName, FLAGS, null, types, null);
        public static MethodInfo GetMethod<T, T1>(string methodName) => GetMethod<T>(methodName, typeof(T1));
        public static MethodInfo GetMethod<T, T1, T2>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2));
        public static MethodInfo GetMethod<T, T1, T2, T3>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4, T5>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        public static MethodInfo GetMethod(Type t, string methodName, params Type[] types) => t.GetMethod(methodName, FLAGS, null, types, null);
         
        
        public static ConstructorInfo GetConstructor<T>(params Type[] types) => typeof(T).GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor(Type t, params Type[] types) => t.GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor<T, T1>() => GetConstructor<T>(typeof(T1));
        public static ConstructorInfo GetConstructor<T, T1, T2>() => GetConstructor<T>( typeof(T1), typeof(T2));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4, T5>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));


        public static FieldInfo GetField<T>(string name) => typeof(T).GetField(name, FLAGS);
        public static FieldInfo GetField(Type t, string name) => t.GetField(name, FLAGS);

    }

}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class EmptyClass{private EmptyClass(){}}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
private EmptyClass(){}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public class SharpReflect
    {
        public readonly static BindingFlags FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic;
        
        public static MethodInfo GetMethod<T>(string methodName, params Type[] types) => typeof(T).GetMethod(methodName, FLAGS, null, types, null);
        public static MethodInfo GetMethod<T, T1>(string methodName) => GetMethod<T>(methodName, typeof(T1));
        public static MethodInfo GetMethod<T, T1, T2>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2));
        public static MethodInfo GetMethod<T, T1, T2, T3>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static MethodInfo GetMethod<T, T1, T2, T3, T4, T5>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        public static MethodInfo GetMethod(Type t, string methodName, params Type[] types) => t.GetMethod(methodName, FLAGS, null, types, null);
         
        
        public static ConstructorInfo GetConstructor<T>(params Type[] types) => typeof(T).GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor(Type t, params Type[] types) => t.GetConstructor(FLAGS, null, types, null);
        public static ConstructorInfo GetConstructor<T, T1>() => GetConstructor<T>(typeof(T1));
        public static ConstructorInfo GetConstructor<T, T1, T2>() => GetConstructor<T>( typeof(T1), typeof(T2));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4, T5>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));


        public static FieldInfo GetField<T>(string name) => typeof(T).GetField(name, FLAGS);
        public static FieldInfo GetField(Type t, string name) => t.GetField(name, FLAGS);

    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
public readonly static BindingFlags FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
BindingFlags FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
BindingFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FLAGS = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                                             BindingFlags.NonPublic		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
BindingFlags.Instance | BindingFlags.Static		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
BindingFlags.Instance		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
BindingFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Instance		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BindingFlags.Static		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
BindingFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Static		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BindingFlags.Public		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
BindingFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Public		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BindingFlags.NonPublic		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
BindingFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NonPublic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static MethodInfo GetMethod<T>(string methodName, params Type[] types) => typeof(T).GetMethod(methodName, FLAGS, null, types, null);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
MethodInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string methodName, params Type[] types)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
params Type[] types		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=> typeof(T).GetMethod(methodName, FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
typeof(T).GetMethod(methodName, FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typeof(T).GetMethod		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(methodName, FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static MethodInfo GetMethod<T, T1>(string methodName) => GetMethod<T>(methodName, typeof(T1));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
MethodInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T, T1>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string methodName)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> GetMethod<T>(methodName, typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
GetMethod<T>(methodName, typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetMethod<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(methodName, typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static MethodInfo GetMethod<T, T1, T2>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
MethodInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T, T1, T2>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string methodName)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> GetMethod<T>(methodName, typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
GetMethod<T>(methodName, typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetMethod<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(methodName, typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static MethodInfo GetMethod<T, T1, T2, T3>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
MethodInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T, T1, T2, T3>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string methodName)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetMethod<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(methodName, typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static MethodInfo GetMethod<T, T1, T2, T3, T4>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
MethodInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T, T1, T2, T3, T4>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string methodName)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetMethod<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static MethodInfo GetMethod<T, T1, T2, T3, T4, T5>(string methodName) => GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
MethodInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T, T1, T2, T3, T4, T5>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T5		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string methodName)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
GetMethod<T>(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetMethod<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(methodName, typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T5)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T5)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T5		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static MethodInfo GetMethod(Type t, string methodName, params Type[] types) => t.GetMethod(methodName, FLAGS, null, types, null);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
MethodInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Type t, string methodName, params Type[] types)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
params Type[] types		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=> t.GetMethod(methodName, FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
t.GetMethod(methodName, FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
t.GetMethod		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(methodName, FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
methodName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static ConstructorInfo GetConstructor<T>(params Type[] types) => typeof(T).GetConstructor(FLAGS, null, types, null);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ConstructorInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(params Type[] types)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
params Type[] types		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=> typeof(T).GetConstructor(FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
typeof(T).GetConstructor(FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typeof(T).GetConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static ConstructorInfo GetConstructor(Type t, params Type[] types) => t.GetConstructor(FLAGS, null, types, null);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ConstructorInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Type t, params Type[] types)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
params Type[] types		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=> t.GetConstructor(FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
t.GetConstructor(FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
t.GetConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(FLAGS, null, types, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static ConstructorInfo GetConstructor<T, T1>() => GetConstructor<T>(typeof(T1));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ConstructorInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T, T1>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> GetConstructor<T>(typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
GetConstructor<T>(typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetConstructor<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static ConstructorInfo GetConstructor<T, T1, T2>() => GetConstructor<T>( typeof(T1), typeof(T2));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ConstructorInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T, T1, T2>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> GetConstructor<T>( typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
GetConstructor<T>( typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetConstructor<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
( typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static ConstructorInfo GetConstructor<T, T1, T2, T3>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ConstructorInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T, T1, T2, T3>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetConstructor<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
( typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ConstructorInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T, T1, T2, T3, T4>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetConstructor<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
( typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static ConstructorInfo GetConstructor<T, T1, T2, T3, T4, T5>() => GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ConstructorInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T, T1, T2, T3, T4, T5>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T5		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
GetConstructor<T>( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetConstructor<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
( typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T5)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T5)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T5		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static FieldInfo GetField<T>(string name) => typeof(T).GetField(name, FLAGS);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
FieldInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> typeof(T).GetField(name, FLAGS)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
typeof(T).GetField(name, FLAGS)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typeof(T).GetField		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, FLAGS)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static FieldInfo GetField(Type t, string name) => t.GetField(name, FLAGS);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
FieldInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Type t, string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> t.GetField(name, FLAGS)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
t.GetField(name, FLAGS)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
t.GetField		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, FLAGS)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
FLAGS		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using System.Reflection;
using System.Reflection.Emit;

namespace runtime.ILCompiler
{
    public struct ILTypeBuilder
    {
        public readonly TypeBuilder InternalBuilder;
        public readonly IlExprBuilder TypeInitializer;

        internal ILTypeBuilder(TypeBuilder t) {
            TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());
            InternalBuilder = t;
        }

        internal FieldBuilder CreateFieldImpl(string name, Type type, FieldAttributes extra = 0) => InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra);

        public FieldBuilder CreateField(string name, Type type, bool isConst) => CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0);
        public IlExprBuilder CreateMethod(string name, Type returnType, params Type[] parameters) =>
            new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters));

        public IlExprBuilder CreateMethod(string name) => CreateMethod(name, typeof(void));
        public IlExprBuilder CreateMethod<TOut>(string name) => CreateMethod(name, typeof(TOut));
        public IlExprBuilder CreateMethod<TOut, T1>(string name) => CreateMethod(name, typeof(TOut), typeof(T1));
        public IlExprBuilder CreateMethod<TOut, T1, T2>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4, T5>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));

        public IlExprBuilder CreateConstructor(params Type[] parameters) =>
            new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters));

        public IlExprBuilder CreateConstructor<T1>() => CreateConstructor(typeof(T1));
        public IlExprBuilder CreateConstructor<T1, T2>() => CreateConstructor(typeof(T1), typeof(T2));
        public IlExprBuilder CreateConstructor<T1, T2, T3>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4, T5>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        
        public Type Create() {
            var ti = TypeInitializer;
            ti.ReturnVoid();
            return InternalBuilder.CreateType();
        }
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Reflection;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Reflection.Emit;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Reflection.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.ILCompiler
{
    public struct ILTypeBuilder
    {
        public readonly TypeBuilder InternalBuilder;
        public readonly IlExprBuilder TypeInitializer;

        internal ILTypeBuilder(TypeBuilder t) {
            TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());
            InternalBuilder = t;
        }

        internal FieldBuilder CreateFieldImpl(string name, Type type, FieldAttributes extra = 0) => InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra);

        public FieldBuilder CreateField(string name, Type type, bool isConst) => CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0);
        public IlExprBuilder CreateMethod(string name, Type returnType, params Type[] parameters) =>
            new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters));

        public IlExprBuilder CreateMethod(string name) => CreateMethod(name, typeof(void));
        public IlExprBuilder CreateMethod<TOut>(string name) => CreateMethod(name, typeof(TOut));
        public IlExprBuilder CreateMethod<TOut, T1>(string name) => CreateMethod(name, typeof(TOut), typeof(T1));
        public IlExprBuilder CreateMethod<TOut, T1, T2>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4, T5>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));

        public IlExprBuilder CreateConstructor(params Type[] parameters) =>
            new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters));

        public IlExprBuilder CreateConstructor<T1>() => CreateConstructor(typeof(T1));
        public IlExprBuilder CreateConstructor<T1, T2>() => CreateConstructor(typeof(T1), typeof(T2));
        public IlExprBuilder CreateConstructor<T1, T2, T3>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4, T5>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        
        public Type Create() {
            var ti = TypeInitializer;
            ti.ReturnVoid();
            return InternalBuilder.CreateType();
        }
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.ILCompiler		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ILCompiler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public struct ILTypeBuilder
    {
        public readonly TypeBuilder InternalBuilder;
        public readonly IlExprBuilder TypeInitializer;

        internal ILTypeBuilder(TypeBuilder t) {
            TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());
            InternalBuilder = t;
        }

        internal FieldBuilder CreateFieldImpl(string name, Type type, FieldAttributes extra = 0) => InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra);

        public FieldBuilder CreateField(string name, Type type, bool isConst) => CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0);
        public IlExprBuilder CreateMethod(string name, Type returnType, params Type[] parameters) =>
            new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters));

        public IlExprBuilder CreateMethod(string name) => CreateMethod(name, typeof(void));
        public IlExprBuilder CreateMethod<TOut>(string name) => CreateMethod(name, typeof(TOut));
        public IlExprBuilder CreateMethod<TOut, T1>(string name) => CreateMethod(name, typeof(TOut), typeof(T1));
        public IlExprBuilder CreateMethod<TOut, T1, T2>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4, T5>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));

        public IlExprBuilder CreateConstructor(params Type[] parameters) =>
            new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters));

        public IlExprBuilder CreateConstructor<T1>() => CreateConstructor(typeof(T1));
        public IlExprBuilder CreateConstructor<T1, T2>() => CreateConstructor(typeof(T1), typeof(T2));
        public IlExprBuilder CreateConstructor<T1, T2, T3>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4));
        public IlExprBuilder CreateConstructor<T1, T2, T3, T4, T5>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));
        
        public Type Create() {
            var ti = TypeInitializer;
            ti.ReturnVoid();
            return InternalBuilder.CreateType();
        }
    }		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
public readonly TypeBuilder InternalBuilder;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
TypeBuilder InternalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
TypeBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
InternalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly IlExprBuilder TypeInitializer;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IlExprBuilder TypeInitializer		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeInitializer		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal ILTypeBuilder(TypeBuilder t) {
            TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());
            InternalBuilder = t;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(TypeBuilder t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
TypeBuilder t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TypeBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());
            InternalBuilder = t;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer());		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
TypeInitializer = new IlExprBuilder(t.DefineTypeInitializer())		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
TypeInitializer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new IlExprBuilder(t.DefineTypeInitializer())		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t.DefineTypeInitializer())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t.DefineTypeInitializer()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t.DefineTypeInitializer()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
t.DefineTypeInitializer		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DefineTypeInitializer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
InternalBuilder = t;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
InternalBuilder = t		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
InternalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal FieldBuilder CreateFieldImpl(string name, Type type, FieldAttributes extra = 0) => InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
FieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name, Type type, FieldAttributes extra = 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Type type		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FieldAttributes extra = 0		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
FieldAttributes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
=> InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
InternalBuilder.DefineField(name, type, FieldAttributes.Public | extra)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
InternalBuilder.DefineField		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
InternalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DefineField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, type, FieldAttributes.Public | extra)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FieldAttributes.Public | extra		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
FieldAttributes.Public | extra		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
FieldAttributes.Public		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
FieldAttributes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Public		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
extra		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public FieldBuilder CreateField(string name, Type type, bool isConst) => CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
FieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name, Type type, bool isConst)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Type type		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool isConst		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateFieldImpl(name, type, isConst ? FieldAttributes.InitOnly : 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateFieldImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, type, isConst ? FieldAttributes.InitOnly : 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
isConst ? FieldAttributes.InitOnly : 0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
isConst ? FieldAttributes.InitOnly : 0		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
isConst		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FieldAttributes.InitOnly		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
FieldAttributes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
InitOnly		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public IlExprBuilder CreateMethod(string name, Type returnType, params Type[] parameters) =>
            new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name, Type returnType, params Type[] parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Type returnType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
params Type[] parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=>
            new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
new(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
InternalBuilder.DefineMethod(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
InternalBuilder.DefineMethod		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
InternalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DefineMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, MethodAttributes.Static | MethodAttributes.Public, 
                returnType, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MethodAttributes.Static | MethodAttributes.Public		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MethodAttributes.Static | MethodAttributes.Public		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
MethodAttributes.Static		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodAttributes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Static		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MethodAttributes.Public		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodAttributes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Public		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
returnType		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
returnType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateMethod(string name) => CreateMethod(name, typeof(void));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> CreateMethod(name, typeof(void))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateMethod(name, typeof(void))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, typeof(void))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(void)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(void)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public IlExprBuilder CreateMethod<TOut>(string name) => CreateMethod(name, typeof(TOut));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TOut>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> CreateMethod(name, typeof(TOut))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateMethod(name, typeof(TOut))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, typeof(TOut))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateMethod<TOut, T1>(string name) => CreateMethod(name, typeof(TOut), typeof(T1));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TOut, T1>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> CreateMethod(name, typeof(TOut), typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateMethod(name, typeof(TOut), typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, typeof(TOut), typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateMethod<TOut, T1, T2>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TOut, T1, T2>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, typeof(TOut), typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateMethod<TOut, T1, T2, T3>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TOut, T1, T2, T3>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TOut, T1, T2, T3, T4>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateMethod<TOut, T1, T2, T3, T4, T5>(string name) => CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TOut, T1, T2, T3, T4, T5>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T5		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateMethod(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, typeof(TOut), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(TOut)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
TOut		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T5)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T5)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T5		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateConstructor(params Type[] parameters) =>
            new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(params Type[] parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
params Type[] parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=>
            new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
new(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
InternalBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
InternalBuilder.DefineConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
InternalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DefineConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(MethodAttributes.Static | MethodAttributes.Public, 
                CallingConventions.Any, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
MethodAttributes.Static | MethodAttributes.Public		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MethodAttributes.Static | MethodAttributes.Public		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
MethodAttributes.Static		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodAttributes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Static		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MethodAttributes.Public		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodAttributes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Public		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CallingConventions.Any		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
CallingConventions.Any		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
CallingConventions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Any		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateConstructor<T1>() => CreateConstructor(typeof(T1));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T1>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> CreateConstructor(typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateConstructor(typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateConstructor<T1, T2>() => CreateConstructor(typeof(T1), typeof(T2));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T1, T2>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> CreateConstructor(typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateConstructor(typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T1), typeof(T2))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateConstructor<T1, T2, T3>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T1, T2, T3>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> CreateConstructor(typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateConstructor(typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T1), typeof(T2), typeof(T3))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateConstructor<T1, T2, T3, T4>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T1, T2, T3, T4>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T1), typeof(T2), typeof(T3), typeof(T4))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder CreateConstructor<T1, T2, T3, T4, T5>() => CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T1, T2, T3, T4, T5>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
T5		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
CreateConstructor(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CreateConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T1)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T2)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T3)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T4)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(T5)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T5)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T5		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public Type Create() {
            var ti = TypeInitializer;
            ti.ReturnVoid();
            return InternalBuilder.CreateType();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
            var ti = TypeInitializer;
            ti.ReturnVoid();
            return InternalBuilder.CreateType();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var ti = TypeInitializer;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var ti = TypeInitializer		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ti = TypeInitializer		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= TypeInitializer		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
TypeInitializer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ti.ReturnVoid();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ti.ReturnVoid()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ti.ReturnVoid		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ti		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReturnVoid		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return InternalBuilder.CreateType();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
InternalBuilder.CreateType()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
InternalBuilder.CreateType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
InternalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CreateType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
namespace runtime.ILCompiler
{
    public class ILUtils
    {
        
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
namespace runtime.ILCompiler
{
    public class ILUtils
    {
        
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.ILCompiler		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ILCompiler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class ILUtils
    {
        
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
namespace HyperSphere {

using Antlr4.Runtime.Misc;
using IErrorNode = Antlr4.Runtime.Tree.IErrorNode;
using ITerminalNode = Antlr4.Runtime.Tree.ITerminalNode;
using IToken = Antlr4.Runtime.IToken;
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;

/// <summary>
/// This class provides an empty implementation of <see cref="IJuliaListener"/>,
/// which can be extended to create a listener which only needs to handle a subset
/// of the available methods.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseListener : IJuliaListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterEndExpr([NotNull] JuliaParser.EndExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitEndExpr([NotNull] JuliaParser.EndExprContext context) { }

	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void EnterEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void ExitEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitTerminal([NotNull] ITerminalNode node) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitErrorNode([NotNull] IErrorNode node) { }
}
} // namespace HyperSphere
		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
namespace HyperSphere {

using Antlr4.Runtime.Misc;
using IErrorNode = Antlr4.Runtime.Tree.IErrorNode;
using ITerminalNode = Antlr4.Runtime.Tree.ITerminalNode;
using IToken = Antlr4.Runtime.IToken;
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;

/// <summary>
/// This class provides an empty implementation of <see cref="IJuliaListener"/>,
/// which can be extended to create a listener which only needs to handle a subset
/// of the available methods.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseListener : IJuliaListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterEndExpr([NotNull] JuliaParser.EndExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitEndExpr([NotNull] JuliaParser.EndExprContext context) { }

	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void EnterEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void ExitEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitTerminal([NotNull] ITerminalNode node) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitErrorNode([NotNull] IErrorNode node) { }
}
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
HyperSphere		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Misc;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Misc		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Misc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using IErrorNode = Antlr4.Runtime.Tree.IErrorNode;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
IErrorNode =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
IErrorNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4.Runtime.Tree.IErrorNode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime.Tree		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Tree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IErrorNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using ITerminalNode = Antlr4.Runtime.Tree.ITerminalNode;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
ITerminalNode =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4.Runtime.Tree.ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime.Tree		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Tree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using IToken = Antlr4.Runtime.IToken;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
IToken =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
IToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4.Runtime.IToken		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
ParserRuleContext =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4.Runtime.ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseListener : IJuliaListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitScript([NotNull] JuliaParser.ScriptContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModule([NotNull] JuliaParser.ModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructure([NotNull] JuliaParser.StructureContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructField([NotNull] JuliaParser.StructFieldContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitStructItem([NotNull] JuliaParser.StructItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunction([NotNull] JuliaParser.FunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTuple([NotNull] JuliaParser.TupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTupleList([NotNull] JuliaParser.TupleListContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitTypeName([NotNull] JuliaParser.TypeNameContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitType([NotNull] JuliaParser.TypeContext context) { }
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void EnterEndExpr([NotNull] JuliaParser.EndExprContext context) { }
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>The default implementation does nothing.</para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	public virtual void ExitEndExpr([NotNull] JuliaParser.EndExprContext context) { }

	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void EnterEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void ExitEveryRule([NotNull] ParserRuleContext context) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitTerminal([NotNull] ITerminalNode node) { }
	/// <inheritdoc/>
	/// <remarks>The default implementation does nothing.</remarks>
	public virtual void VisitErrorNode([NotNull] IErrorNode node) { }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CodeDom.Compiler.GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom.Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.CLSCompliant(false)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CLSCompliant(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
: IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual void EnterScript([NotNull] JuliaParser.ScriptContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ScriptContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ScriptContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitScript([NotNull] JuliaParser.ScriptContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ScriptContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ScriptContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterModule([NotNull] JuliaParser.ModuleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitModule([NotNull] JuliaParser.ModuleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.UsingModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.UsingModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.UsingModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.UsingModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleRefContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleRefContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleRefContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleRefContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.SymbolIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.SymbolIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.SymbolIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.SymbolIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.AbstractStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.AbstractStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.AbstractStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.AbstractStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.CompositeStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.CompositeStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.CompositeStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.CompositeStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterStructure([NotNull] JuliaParser.StructureContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitStructure([NotNull] JuliaParser.StructureContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterStructField([NotNull] JuliaParser.StructFieldContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructFieldContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructFieldContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitStructField([NotNull] JuliaParser.StructFieldContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructFieldContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructFieldContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterStructItem([NotNull] JuliaParser.StructItemContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitStructItem([NotNull] JuliaParser.StructItemContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockVariableInstatiationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableInstatiationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockVariableInstatiationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableInstatiationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockArgContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockArgContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockArgContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockArgContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterFunction([NotNull] JuliaParser.FunctionContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitFunction([NotNull] JuliaParser.FunctionContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionHeaderContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionHeaderContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionHeaderContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionHeaderContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionCallContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionCallContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionCallContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionCallContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ShortFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ShortFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ShortFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ShortFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.LongFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.LongFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.LongFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.LongFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterTuple([NotNull] JuliaParser.TupleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitTuple([NotNull] JuliaParser.TupleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.NamedTupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.NamedTupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.NamedTupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.NamedTupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypetupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypetupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypetupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypetupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterTupleList([NotNull] JuliaParser.TupleListContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TupleListContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleListContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitTupleList([NotNull] JuliaParser.TupleListContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TupleListContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleListContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterTypeName([NotNull] JuliaParser.TypeNameContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypeNameContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeNameContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitTypeName([NotNull] JuliaParser.TypeNameContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypeNameContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeNameContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ParameterizedTypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ParameterizedTypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ParameterizedTypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ParameterizedTypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterType([NotNull] JuliaParser.TypeContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitType([NotNull] JuliaParser.TypeContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterEndExpr([NotNull] JuliaParser.EndExprContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.EndExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.EndExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitEndExpr([NotNull] JuliaParser.EndExprContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.EndExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.EndExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void EnterEveryRule([NotNull] ParserRuleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] ParserRuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] ParserRuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void ExitEveryRule([NotNull] ParserRuleContext context) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] ParserRuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] ParserRuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void VisitTerminal([NotNull] ITerminalNode node) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] ITerminalNode node)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] ITerminalNode node		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public virtual void VisitErrorNode([NotNull] IErrorNode node) { }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] IErrorNode node)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] IErrorNode node		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IErrorNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
namespace HyperSphere {
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using IToken = Antlr4.Runtime.IToken;
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;

/// <summary>
/// This class provides an empty implementation of <see cref="IJuliaVisitor{Result}"/>,
/// which can be extended to create a visitor which only needs to handle a subset
/// of the available methods.
/// </summary>
/// <typeparam name="Result">The return type of the visit operation.</typeparam>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseVisitor<Result> : AbstractParseTreeVisitor<Result>, IJuliaVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitScript([NotNull] JuliaParser.ScriptContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModule([NotNull] JuliaParser.ModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructure([NotNull] JuliaParser.StructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructField([NotNull] JuliaParser.StructFieldContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructItem([NotNull] JuliaParser.StructItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunction([NotNull] JuliaParser.FunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTuple([NotNull] JuliaParser.TupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTupleList([NotNull] JuliaParser.TupleListContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitType([NotNull] JuliaParser.TypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context) { return VisitChildren(context); }
}
} // namespace HyperSphere
		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
namespace HyperSphere {
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using IToken = Antlr4.Runtime.IToken;
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;

/// <summary>
/// This class provides an empty implementation of <see cref="IJuliaVisitor{Result}"/>,
/// which can be extended to create a visitor which only needs to handle a subset
/// of the available methods.
/// </summary>
/// <typeparam name="Result">The return type of the visit operation.</typeparam>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseVisitor<Result> : AbstractParseTreeVisitor<Result>, IJuliaVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitScript([NotNull] JuliaParser.ScriptContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModule([NotNull] JuliaParser.ModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructure([NotNull] JuliaParser.StructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructField([NotNull] JuliaParser.StructFieldContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructItem([NotNull] JuliaParser.StructItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunction([NotNull] JuliaParser.FunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTuple([NotNull] JuliaParser.TupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTupleList([NotNull] JuliaParser.TupleListContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitType([NotNull] JuliaParser.TypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context) { return VisitChildren(context); }
}
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
HyperSphere		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Misc;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Misc		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Misc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Tree;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Tree		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Tree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using IToken = Antlr4.Runtime.IToken;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
IToken =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
IToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4.Runtime.IToken		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using ParserRuleContext = Antlr4.Runtime.ParserRuleContext;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
ParserRuleContext =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4.Runtime.ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.Diagnostics.DebuggerNonUserCode]
[System.CLSCompliant(false)]
public partial class JuliaBaseVisitor<Result> : AbstractParseTreeVisitor<Result>, IJuliaVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitScript([NotNull] JuliaParser.ScriptContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModule([NotNull] JuliaParser.ModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructure([NotNull] JuliaParser.StructureContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructField([NotNull] JuliaParser.StructFieldContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitStructItem([NotNull] JuliaParser.StructItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunction([NotNull] JuliaParser.FunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTuple([NotNull] JuliaParser.TupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTupleList([NotNull] JuliaParser.TupleListContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitType([NotNull] JuliaParser.TypeContext context) { return VisitChildren(context); }
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// <para>
	/// The default implementation returns the result of calling <see cref="AbstractParseTreeVisitor{Result}.VisitChildren(IRuleNode)"/>
	/// on <paramref name="context"/>.
	/// </para>
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	public virtual Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context) { return VisitChildren(context); }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CodeDom.Compiler.GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom.Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.CLSCompliant(false)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CLSCompliant(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
: AbstractParseTreeVisitor<Result>, IJuliaVisitor<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
AbstractParseTreeVisitor<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
AbstractParseTreeVisitor<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJuliaVisitor<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitScript([NotNull] JuliaParser.ScriptContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ScriptContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ScriptContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitModule([NotNull] JuliaParser.ModuleContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.UsingModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.UsingModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleRefContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleRefContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.SymbolIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.SymbolIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.AbstractStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.AbstractStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.CompositeStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.CompositeStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitStructure([NotNull] JuliaParser.StructureContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.StructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitStructField([NotNull] JuliaParser.StructFieldContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.StructFieldContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructFieldContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitStructItem([NotNull] JuliaParser.StructItemContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.StructItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.BlockExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.BlockExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.BlockVariableInstatiationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableInstatiationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.BlockArgContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockArgContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.BlockVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitFunction([NotNull] JuliaParser.FunctionContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.FunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.FunctionHeaderContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionHeaderContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.FunctionItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.FunctionCallContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionCallContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ShortFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ShortFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.LongFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.LongFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitTuple([NotNull] JuliaParser.TupleContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.TupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.NamedTupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.NamedTupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.TypetupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypetupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitTupleList([NotNull] JuliaParser.TupleListContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.TupleListContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleListContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.TypeNameContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeNameContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ParameterizedTypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ParameterizedTypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitType([NotNull] JuliaParser.TypeContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.TypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public virtual Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context) { return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.EndExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.EndExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ return VisitChildren(context); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return VisitChildren(context);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
VisitChildren(context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace HyperSphere {
using System;
using System.IO;
using System.Text;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaLexer : Lexer {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public static string[] channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	};

	public static string[] modeNames = {
		"DEFAULT_MODE"
	};

	public static readonly string[] ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};


	public JuliaLexer(ICharStream input)
	: this(input, Console.Out, Console.Error) { }

	public JuliaLexer(ICharStream input, TextWriter output, TextWriter errorOutput)
	: base(input, output, errorOutput)
	{
		Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string[] ChannelNames { get { return channelNames; } }

	public override string[] ModeNames { get { return modeNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaLexer() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}
	private static int[] _serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace HyperSphere
		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
namespace HyperSphere {
using System;
using System.IO;
using System.Text;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaLexer : Lexer {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public static string[] channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	};

	public static string[] modeNames = {
		"DEFAULT_MODE"
	};

	public static readonly string[] ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};


	public JuliaLexer(ICharStream input)
	: this(input, Console.Out, Console.Error) { }

	public JuliaLexer(ICharStream input, TextWriter output, TextWriter errorOutput)
	: base(input, output, errorOutput)
	{
		Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string[] ChannelNames { get { return channelNames; } }

	public override string[] ModeNames { get { return modeNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaLexer() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}
	private static int[] _serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
HyperSphere		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.IO;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.IO		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IO		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Text;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Text		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Text		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Atn;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Atn		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Atn		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Misc;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Misc		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Misc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using DFA = Antlr4.Runtime.Dfa.DFA;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
DFA =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
DFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4.Runtime.Dfa.DFA		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime.Dfa		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Dfa		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaLexer : Lexer {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public static string[] channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	};

	public static string[] modeNames = {
		"DEFAULT_MODE"
	};

	public static readonly string[] ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};


	public JuliaLexer(ICharStream input)
	: this(input, Console.Out, Console.Error) { }

	public JuliaLexer(ICharStream input, TextWriter output, TextWriter errorOutput)
	: base(input, output, errorOutput)
	{
		Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string[] ChannelNames { get { return channelNames; } }

	public override string[] ModeNames { get { return modeNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaLexer() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}
	private static int[] _serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CodeDom.Compiler.GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom.Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.CLSCompliant(false)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CLSCompliant(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
: Lexer		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
Lexer		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
Lexer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
protected static DFA[] decisionToDFA;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
DFA[] decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
DFA[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
DFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
protected static PredictionContextCache sharedContextCache = new PredictionContextCache();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
PredictionContextCache sharedContextCache = new PredictionContextCache()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
PredictionContextCache		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sharedContextCache = new PredictionContextCache()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new PredictionContextCache()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new PredictionContextCache()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
PredictionContextCache		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Symbol=1		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=1		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
AbstractType=2		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=2		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Using=3		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=3		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Extend=4		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=4		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Global=5		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=5		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Const=6		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=6		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Local=7		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=7		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Mutable=8		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=8		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Function=9		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=9		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Module=10		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=10		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Struct=11		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=11		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
For=12		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=12		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Goto=13		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=13		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
If=14		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=14		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Else=15		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=15		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ElseIf=16		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=16		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Return=17		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=17		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Continue=18		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=18		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Do=19		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=19		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
End=20		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=20		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LeftParen=21		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=21		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RightParen=22		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=22		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LeftBracket=23		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=23		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RightBracket=24		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=24		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LeftBrace=25		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=25		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RightBrace=26		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=26		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
And=27		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=27		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Or=28		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=28		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Caret=29		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=29		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Not=30		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=30		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Tilde=31		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=31		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Plus=32		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=32		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Minus=33		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=33		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Star=34		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=34		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Div=35		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=35		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Mod=36		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=36		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LeftShift=37		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=37		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RightShift=38		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=38		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Operator=39		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=39		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Less=40		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=40		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LessEqual=41		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=41		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Greater=42		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=42		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
GreaterEqual=43		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=43		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ComparisonOperator=44		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=44		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ShortAnd=45		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=45		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ShortOr=46		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=46		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ShortcutOperator=47		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=47		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Question=48		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=48		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Colon=49		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=49		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ValueType=50		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=50		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Semi=51		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=51		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
51		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Comma=52		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=52		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Assign=53		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=53		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Arrow=54		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=54		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Dot=55		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=55		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Splat=56		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=56		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Termination=57		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=57		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
AugmentedAssignment=58		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=58		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Assignment=59		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=59		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Constant=60		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=60		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Identifier=61		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=61		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
IntegerConstant=62		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=62		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
DecimalConstant=63		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=63		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
NewLine=64		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=64		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Whitespace=65		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=65		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
BlockComment=66		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=66		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LineComment=67		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=67		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static string[] channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	};		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
string[] channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
{
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
"DEFAULT_TOKEN_CHANNEL"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"HIDDEN"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static string[] modeNames = {
		"DEFAULT_MODE"
	};		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
string[] modeNames = {
		"DEFAULT_MODE"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
modeNames = {
		"DEFAULT_MODE"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= {
		"DEFAULT_MODE"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
{
		"DEFAULT_MODE"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
"DEFAULT_MODE"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static readonly string[] ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
string[] ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
ruleNames = {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= {
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
{
		"Symbol", "AbstractType", "Using", "Extend", "Global", "Const", "Local", 
		"Mutable", "Function", "Module", "Struct", "For", "Goto", "If", "Else", 
		"ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "Digit", "IdentifierPrefixCharacter", 
		"IdentifierSuffixCharacter", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
"Symbol"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"AbstractType"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Using"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Extend"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Global"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Const"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Local"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Mutable"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Function"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Module"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Struct"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"For"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Goto"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"If"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Else"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ElseIf"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Return"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Continue"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Do"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"End"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftParen"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightParen"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftBracket"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightBracket"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftBrace"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightBrace"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"And"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Or"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Caret"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Not"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Tilde"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Plus"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Minus"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Star"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Div"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Mod"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftShift"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightShift"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Operator"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Less"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LessEqual"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Greater"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"GreaterEqual"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ComparisonOperator"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ShortAnd"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ShortOr"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ShortcutOperator"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Question"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Colon"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ValueType"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Semi"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Comma"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Assign"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Arrow"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Dot"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Splat"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Termination"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"AugmentedAssignment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Assignment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Constant"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Identifier"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"IntegerConstant"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"DecimalConstant"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Digit"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"IdentifierPrefixCharacter"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"IdentifierSuffixCharacter"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"NewLine"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Whitespace"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"BlockComment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LineComment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public JuliaLexer(ICharStream input)
	: this(input, Console.Out, Console.Error) { }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ICharStream input)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ICharStream input		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ICharStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: this(input, Console.Out, Console.Error)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(input, Console.Out, Console.Error)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
input		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
input		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.Out		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Console.Out		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Out		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.Error		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Console.Error		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Error		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public JuliaLexer(ICharStream input, TextWriter output, TextWriter errorOutput)
	: base(input, output, errorOutput)
	{
		Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ICharStream input, TextWriter output, TextWriter errorOutput)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ICharStream input		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ICharStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TextWriter output		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TextWriter errorOutput		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: base(input, output, errorOutput)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(input, output, errorOutput)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
input		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
input		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
output		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
output		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
errorOutput		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
errorOutput		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Interpreter = new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new LexerATNSimulator(this, _ATN, decisionToDFA, sharedContextCache)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
LexerATNSimulator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, _ATN, decisionToDFA, sharedContextCache)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_ATN		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sharedContextCache		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
sharedContextCache		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
_LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
{
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'using'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'<:'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'global'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'const'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'local'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'mutable'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'function'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'module'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'struct'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'for'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'goto'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'if'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'else'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'elseif'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'return'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'continue'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'do'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'end'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'('"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"')'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'['"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"']'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'{'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'}'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'&'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'|'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'^'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'!'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'~'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'+'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'-'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'*'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'/'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'%'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'<<'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'>>'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'<'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'<='"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'>'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'>='"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'&&'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'||'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'?'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"':'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'::'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"';'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"','"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'='"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'->'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'.'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'...'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
_SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
{
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Symbol"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"AbstractType"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Using"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Extend"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Global"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Const"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Local"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Mutable"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Function"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Module"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Struct"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"For"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Goto"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"If"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Else"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ElseIf"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Return"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Continue"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Do"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"End"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftParen"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightParen"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftBracket"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightBracket"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftBrace"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightBrace"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"And"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Or"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Caret"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Not"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Tilde"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Plus"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Minus"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Star"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Div"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Mod"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftShift"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightShift"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Operator"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Less"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LessEqual"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Greater"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"GreaterEqual"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ComparisonOperator"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ShortAnd"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ShortOr"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ShortcutOperator"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Question"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Colon"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ValueType"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Semi"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Comma"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Assign"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Arrow"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Dot"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Splat"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Termination"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"AugmentedAssignment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Assignment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Constant"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Identifier"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"IntegerConstant"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"DecimalConstant"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"NewLine"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Whitespace"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"BlockComment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LineComment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IVocabulary		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new Vocabulary(_LiteralNames, _SymbolicNames)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new Vocabulary(_LiteralNames, _SymbolicNames)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
Vocabulary		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_LiteralNames, _SymbolicNames)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_LiteralNames		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_LiteralNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_SymbolicNames		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_SymbolicNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IVocabulary		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		get
		{
			return DefaultVocabulary;
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get
		{
			return DefaultVocabulary;
		}		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{
			return DefaultVocabulary;
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return DefaultVocabulary;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
DefaultVocabulary		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public override string GrammarFileName { get { return "Julia.g4"; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return "Julia.g4"; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return "Julia.g4"; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return "Julia.g4"; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return "Julia.g4";		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
"Julia.g4"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public override string[] RuleNames { get { return ruleNames; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{ get { return ruleNames; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return ruleNames; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return ruleNames; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return ruleNames;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
ruleNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public override string[] ChannelNames { get { return channelNames; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{ get { return channelNames; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return channelNames; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return channelNames; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return channelNames;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
channelNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public override string[] ModeNames { get { return modeNames; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{ get { return modeNames; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return modeNames; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return modeNames; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return modeNames;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
modeNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public override int[] SerializedAtn { get { return _serializedATN; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{ get { return _serializedATN; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return _serializedATN; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return _serializedATN; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return _serializedATN;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_serializedATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
static JuliaLexer() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
decisionToDFA = new DFA[_ATN.NumberOfDecisions];		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
decisionToDFA = new DFA[_ATN.NumberOfDecisions]		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new DFA[_ATN.NumberOfDecisions]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax
DFA[_ATN.NumberOfDecisions]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
DFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[_ATN.NumberOfDecisions]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
_ATN.NumberOfDecisions		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NumberOfDecisions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < _ATN.NumberOfDecisions		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_ATN.NumberOfDecisions		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NumberOfDecisions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
decisionToDFA[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new DFA(_ATN.GetDecisionState(i), i)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
DFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_ATN.GetDecisionState(i), i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_ATN.GetDecisionState(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_ATN.GetDecisionState(i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_ATN.GetDecisionState		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetDecisionState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private static int[] _serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	};		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int[] _serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
_serializedATN = {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= {
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	}		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
{
		4,0,67,450,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
		6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
		7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
		7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
		7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
		7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
		7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
		7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
		7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
		7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,1,
		0,5,0,144,8,0,10,0,12,0,147,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,
		1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
		1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,1,26,
		1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,
		1,33,1,34,1,34,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,318,8,38,1,39,1,39,1,40,1,
		40,1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,3,43,334,8,43,1,44,
		1,44,1,44,1,45,1,45,1,45,1,46,1,46,3,46,344,8,46,1,47,1,47,1,48,1,48,1,
		49,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,54,1,54,1,
		55,1,55,1,55,1,55,1,56,1,56,4,56,370,8,56,11,56,12,56,371,1,57,1,57,1,
		57,1,58,1,58,3,58,379,8,58,1,59,1,59,3,59,383,8,59,1,60,1,60,5,60,387,
		8,60,10,60,12,60,390,9,60,1,61,4,61,393,8,61,11,61,12,61,394,1,62,4,62,
		398,8,62,11,62,12,62,399,1,62,1,62,4,62,404,8,62,11,62,12,62,405,1,63,
		1,63,1,64,1,64,1,65,1,65,1,66,1,66,3,66,416,8,66,1,66,3,66,419,8,66,1,
		67,4,67,422,8,67,11,67,12,67,423,1,67,1,67,1,68,1,68,1,68,1,68,5,68,432,
		8,68,10,68,12,68,435,9,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,5,69,444,
		8,69,10,69,12,69,447,9,69,1,69,1,69,1,433,0,70,1,1,3,2,5,3,7,4,9,5,11,
		6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,14,29,15,31,16,33,17,35,18,
		37,19,39,20,41,21,43,22,45,23,47,24,49,25,51,26,53,27,55,28,57,29,59,30,
		61,31,63,32,65,33,67,34,69,35,71,36,73,37,75,38,77,39,79,40,81,41,83,42,
		85,43,87,44,89,45,91,46,93,47,95,48,97,49,99,50,101,51,103,52,105,53,107,
		54,109,55,111,56,113,57,115,58,117,59,119,60,121,61,123,62,125,63,127,
		0,129,0,131,0,133,64,135,65,137,66,139,67,1,0,5,1,0,48,57,4,0,33,33,65,
		90,95,95,97,122,5,0,33,33,48,57,65,90,95,95,97,122,2,0,9,9,32,32,2,0,10,
		10,13,13,474,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,
		0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,
		1,0,0,0,0,23,1,0,0,0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,
		0,0,33,1,0,0,0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,
		1,0,0,0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,0,51,1,0,0,0,0,53,1,0,0,
		0,0,55,1,0,0,0,0,57,1,0,0,0,0,59,1,0,0,0,0,61,1,0,0,0,0,63,1,0,0,0,0,65,
		1,0,0,0,0,67,1,0,0,0,0,69,1,0,0,0,0,71,1,0,0,0,0,73,1,0,0,0,0,75,1,0,0,
		0,0,77,1,0,0,0,0,79,1,0,0,0,0,81,1,0,0,0,0,83,1,0,0,0,0,85,1,0,0,0,0,87,
		1,0,0,0,0,89,1,0,0,0,0,91,1,0,0,0,0,93,1,0,0,0,0,95,1,0,0,0,0,97,1,0,0,
		0,0,99,1,0,0,0,0,101,1,0,0,0,0,103,1,0,0,0,0,105,1,0,0,0,0,107,1,0,0,0,
		0,109,1,0,0,0,0,111,1,0,0,0,0,113,1,0,0,0,0,115,1,0,0,0,0,117,1,0,0,0,
		0,119,1,0,0,0,0,121,1,0,0,0,0,123,1,0,0,0,0,125,1,0,0,0,0,133,1,0,0,0,
		0,135,1,0,0,0,0,137,1,0,0,0,0,139,1,0,0,0,1,141,1,0,0,0,3,148,1,0,0,0,
		5,162,1,0,0,0,7,168,1,0,0,0,9,171,1,0,0,0,11,178,1,0,0,0,13,184,1,0,0,
		0,15,190,1,0,0,0,17,198,1,0,0,0,19,207,1,0,0,0,21,214,1,0,0,0,23,221,1,
		0,0,0,25,225,1,0,0,0,27,230,1,0,0,0,29,233,1,0,0,0,31,238,1,0,0,0,33,245,
		1,0,0,0,35,252,1,0,0,0,37,261,1,0,0,0,39,264,1,0,0,0,41,268,1,0,0,0,43,
		270,1,0,0,0,45,272,1,0,0,0,47,274,1,0,0,0,49,276,1,0,0,0,51,278,1,0,0,
		0,53,280,1,0,0,0,55,282,1,0,0,0,57,284,1,0,0,0,59,286,1,0,0,0,61,288,1,
		0,0,0,63,290,1,0,0,0,65,292,1,0,0,0,67,294,1,0,0,0,69,296,1,0,0,0,71,298,
		1,0,0,0,73,300,1,0,0,0,75,303,1,0,0,0,77,317,1,0,0,0,79,319,1,0,0,0,81,
		321,1,0,0,0,83,324,1,0,0,0,85,326,1,0,0,0,87,333,1,0,0,0,89,335,1,0,0,
		0,91,338,1,0,0,0,93,343,1,0,0,0,95,345,1,0,0,0,97,347,1,0,0,0,99,349,1,
		0,0,0,101,352,1,0,0,0,103,354,1,0,0,0,105,356,1,0,0,0,107,358,1,0,0,0,
		109,361,1,0,0,0,111,363,1,0,0,0,113,369,1,0,0,0,115,373,1,0,0,0,117,378,
		1,0,0,0,119,382,1,0,0,0,121,384,1,0,0,0,123,392,1,0,0,0,125,397,1,0,0,
		0,127,407,1,0,0,0,129,409,1,0,0,0,131,411,1,0,0,0,133,418,1,0,0,0,135,
		421,1,0,0,0,137,427,1,0,0,0,139,441,1,0,0,0,141,145,3,97,48,0,142,144,
		3,131,65,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,
		0,0,146,2,1,0,0,0,147,145,1,0,0,0,148,149,5,97,0,0,149,150,5,98,0,0,150,
		151,5,115,0,0,151,152,5,116,0,0,152,153,5,114,0,0,153,154,5,97,0,0,154,
		155,5,99,0,0,155,156,5,116,0,0,156,157,1,0,0,0,157,158,5,116,0,0,158,159,
		5,121,0,0,159,160,5,112,0,0,160,161,5,101,0,0,161,4,1,0,0,0,162,163,5,
		117,0,0,163,164,5,115,0,0,164,165,5,105,0,0,165,166,5,110,0,0,166,167,
		5,103,0,0,167,6,1,0,0,0,168,169,5,60,0,0,169,170,5,58,0,0,170,8,1,0,0,
		0,171,172,5,103,0,0,172,173,5,108,0,0,173,174,5,111,0,0,174,175,5,98,0,
		0,175,176,5,97,0,0,176,177,5,108,0,0,177,10,1,0,0,0,178,179,5,99,0,0,179,
		180,5,111,0,0,180,181,5,110,0,0,181,182,5,115,0,0,182,183,5,116,0,0,183,
		12,1,0,0,0,184,185,5,108,0,0,185,186,5,111,0,0,186,187,5,99,0,0,187,188,
		5,97,0,0,188,189,5,108,0,0,189,14,1,0,0,0,190,191,5,109,0,0,191,192,5,
		117,0,0,192,193,5,116,0,0,193,194,5,97,0,0,194,195,5,98,0,0,195,196,5,
		108,0,0,196,197,5,101,0,0,197,16,1,0,0,0,198,199,5,102,0,0,199,200,5,117,
		0,0,200,201,5,110,0,0,201,202,5,99,0,0,202,203,5,116,0,0,203,204,5,105,
		0,0,204,205,5,111,0,0,205,206,5,110,0,0,206,18,1,0,0,0,207,208,5,109,0,
		0,208,209,5,111,0,0,209,210,5,100,0,0,210,211,5,117,0,0,211,212,5,108,
		0,0,212,213,5,101,0,0,213,20,1,0,0,0,214,215,5,115,0,0,215,216,5,116,0,
		0,216,217,5,114,0,0,217,218,5,117,0,0,218,219,5,99,0,0,219,220,5,116,0,
		0,220,22,1,0,0,0,221,222,5,102,0,0,222,223,5,111,0,0,223,224,5,114,0,0,
		224,24,1,0,0,0,225,226,5,103,0,0,226,227,5,111,0,0,227,228,5,116,0,0,228,
		229,5,111,0,0,229,26,1,0,0,0,230,231,5,105,0,0,231,232,5,102,0,0,232,28,
		1,0,0,0,233,234,5,101,0,0,234,235,5,108,0,0,235,236,5,115,0,0,236,237,
		5,101,0,0,237,30,1,0,0,0,238,239,5,101,0,0,239,240,5,108,0,0,240,241,5,
		115,0,0,241,242,5,101,0,0,242,243,5,105,0,0,243,244,5,102,0,0,244,32,1,
		0,0,0,245,246,5,114,0,0,246,247,5,101,0,0,247,248,5,116,0,0,248,249,5,
		117,0,0,249,250,5,114,0,0,250,251,5,110,0,0,251,34,1,0,0,0,252,253,5,99,
		0,0,253,254,5,111,0,0,254,255,5,110,0,0,255,256,5,116,0,0,256,257,5,105,
		0,0,257,258,5,110,0,0,258,259,5,117,0,0,259,260,5,101,0,0,260,36,1,0,0,
		0,261,262,5,100,0,0,262,263,5,111,0,0,263,38,1,0,0,0,264,265,5,101,0,0,
		265,266,5,110,0,0,266,267,5,100,0,0,267,40,1,0,0,0,268,269,5,40,0,0,269,
		42,1,0,0,0,270,271,5,41,0,0,271,44,1,0,0,0,272,273,5,91,0,0,273,46,1,0,
		0,0,274,275,5,93,0,0,275,48,1,0,0,0,276,277,5,123,0,0,277,50,1,0,0,0,278,
		279,5,125,0,0,279,52,1,0,0,0,280,281,5,38,0,0,281,54,1,0,0,0,282,283,5,
		124,0,0,283,56,1,0,0,0,284,285,5,94,0,0,285,58,1,0,0,0,286,287,5,33,0,
		0,287,60,1,0,0,0,288,289,5,126,0,0,289,62,1,0,0,0,290,291,5,43,0,0,291,
		64,1,0,0,0,292,293,5,45,0,0,293,66,1,0,0,0,294,295,5,42,0,0,295,68,1,0,
		0,0,296,297,5,47,0,0,297,70,1,0,0,0,298,299,5,37,0,0,299,72,1,0,0,0,300,
		301,5,60,0,0,301,302,5,60,0,0,302,74,1,0,0,0,303,304,5,62,0,0,304,305,
		5,62,0,0,305,76,1,0,0,0,306,318,3,53,26,0,307,318,3,55,27,0,308,318,3,
		57,28,0,309,318,3,59,29,0,310,318,3,61,30,0,311,318,3,63,31,0,312,318,
		3,65,32,0,313,318,3,69,34,0,314,318,3,71,35,0,315,318,3,73,36,0,316,318,
		3,75,37,0,317,306,1,0,0,0,317,307,1,0,0,0,317,308,1,0,0,0,317,309,1,0,
		0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,312,1,0,0,0,317,313,1,0,0,0,317,
		314,1,0,0,0,317,315,1,0,0,0,317,316,1,0,0,0,318,78,1,0,0,0,319,320,5,60,
		0,0,320,80,1,0,0,0,321,322,5,60,0,0,322,323,5,61,0,0,323,82,1,0,0,0,324,
		325,5,62,0,0,325,84,1,0,0,0,326,327,5,62,0,0,327,328,5,61,0,0,328,86,1,
		0,0,0,329,334,3,79,39,0,330,334,3,81,40,0,331,334,3,83,41,0,332,334,3,
		85,42,0,333,329,1,0,0,0,333,330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,
		0,334,88,1,0,0,0,335,336,5,38,0,0,336,337,5,38,0,0,337,90,1,0,0,0,338,
		339,5,124,0,0,339,340,5,124,0,0,340,92,1,0,0,0,341,344,3,89,44,0,342,344,
		3,91,45,0,343,341,1,0,0,0,343,342,1,0,0,0,344,94,1,0,0,0,345,346,5,63,
		0,0,346,96,1,0,0,0,347,348,5,58,0,0,348,98,1,0,0,0,349,350,5,58,0,0,350,
		351,5,58,0,0,351,100,1,0,0,0,352,353,5,59,0,0,353,102,1,0,0,0,354,355,
		5,44,0,0,355,104,1,0,0,0,356,357,5,61,0,0,357,106,1,0,0,0,358,359,5,45,
		0,0,359,360,5,62,0,0,360,108,1,0,0,0,361,362,5,46,0,0,362,110,1,0,0,0,
		363,364,5,46,0,0,364,365,5,46,0,0,365,366,5,46,0,0,366,112,1,0,0,0,367,
		370,3,133,66,0,368,370,3,101,50,0,369,367,1,0,0,0,369,368,1,0,0,0,370,
		371,1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,114,1,0,0,0,373,374,3,
		77,38,0,374,375,3,117,58,0,375,116,1,0,0,0,376,379,3,105,52,0,377,379,
		3,115,57,0,378,376,1,0,0,0,378,377,1,0,0,0,379,118,1,0,0,0,380,383,3,123,
		61,0,381,383,3,125,62,0,382,380,1,0,0,0,382,381,1,0,0,0,383,120,1,0,0,
		0,384,388,3,129,64,0,385,387,3,131,65,0,386,385,1,0,0,0,387,390,1,0,0,
		0,388,386,1,0,0,0,388,389,1,0,0,0,389,122,1,0,0,0,390,388,1,0,0,0,391,
		393,3,127,63,0,392,391,1,0,0,0,393,394,1,0,0,0,394,392,1,0,0,0,394,395,
		1,0,0,0,395,124,1,0,0,0,396,398,3,127,63,0,397,396,1,0,0,0,398,399,1,0,
		0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,403,3,109,54,0,
		402,404,3,127,63,0,403,402,1,0,0,0,404,405,1,0,0,0,405,403,1,0,0,0,405,
		406,1,0,0,0,406,126,1,0,0,0,407,408,7,0,0,0,408,128,1,0,0,0,409,410,7,
		1,0,0,410,130,1,0,0,0,411,412,7,2,0,0,412,132,1,0,0,0,413,415,5,13,0,0,
		414,416,5,10,0,0,415,414,1,0,0,0,415,416,1,0,0,0,416,419,1,0,0,0,417,419,
		5,10,0,0,418,413,1,0,0,0,418,417,1,0,0,0,419,134,1,0,0,0,420,422,7,3,0,
		0,421,420,1,0,0,0,422,423,1,0,0,0,423,421,1,0,0,0,423,424,1,0,0,0,424,
		425,1,0,0,0,425,426,6,67,0,0,426,136,1,0,0,0,427,428,5,35,0,0,428,429,
		5,61,0,0,429,433,1,0,0,0,430,432,9,0,0,0,431,430,1,0,0,0,432,435,1,0,0,
		0,433,434,1,0,0,0,433,431,1,0,0,0,434,436,1,0,0,0,435,433,1,0,0,0,436,
		437,5,61,0,0,437,438,5,35,0,0,438,439,1,0,0,0,439,440,6,68,0,0,440,138,
		1,0,0,0,441,445,5,35,0,0,442,444,8,4,0,0,443,442,1,0,0,0,444,447,1,0,0,
		0,445,443,1,0,0,0,445,446,1,0,0,0,446,448,1,0,0,0,447,445,1,0,0,0,448,
		449,6,69,0,0,449,140,1,0,0,0,18,0,145,317,333,343,369,371,378,382,388,
		394,399,405,415,418,423,433,445,1,6,0,0
	}		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
450		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
51		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
51		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
144		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
147		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
334		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
344		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
51		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
51		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
370		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
371		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
379		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
383		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
387		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
390		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
393		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
394		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
398		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
399		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
404		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
405		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
416		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
419		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
422		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
423		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
432		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
435		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
444		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
447		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
433		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
70		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
51		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
71		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
73		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
75		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
77		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
79		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
81		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
83		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
85		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
87		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
89		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
91		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
93		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
95		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
51		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
103		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
105		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
107		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
109		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
113		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
119		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
121		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
123		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
125		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
127		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
129		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
131		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
133		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
135		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
137		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
139		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
90		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
95		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
95		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
122		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
90		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
95		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
95		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
122		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
474		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
51		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
71		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
73		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
75		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
77		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
79		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
81		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
83		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
85		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
87		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
89		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
91		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
93		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
95		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
103		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
105		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
107		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
109		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
113		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
119		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
121		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
123		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
125		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
133		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
135		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
137		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
139		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
141		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
148		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
162		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
168		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
171		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
178		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
184		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
190		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
198		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
207		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
214		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
221		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
225		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
230		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
233		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
238		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
245		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
252		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
261		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
264		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
268		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
270		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
272		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
274		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
276		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
51		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
278		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
280		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
282		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
284		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
286		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
288		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
290		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
292		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
294		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
296		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
71		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
298		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
73		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
300		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
75		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
303		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
77		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
79		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
319		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
81		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
321		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
83		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
324		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
85		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
326		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
87		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
333		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
89		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
335		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
91		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
338		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
93		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
343		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
95		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
345		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
347		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
349		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
352		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
103		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
354		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
105		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
356		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
107		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
358		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
109		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
361		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
363		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
113		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
369		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
373		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
378		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
119		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
382		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
121		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
384		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
123		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
392		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
125		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
397		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
127		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
407		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
129		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
409		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
131		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
411		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
133		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
418		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
135		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
421		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
137		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
427		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
139		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
441		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
141		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
145		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
142		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
144		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
131		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
143		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
142		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
144		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
147		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
145		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
143		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
145		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
146		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
146		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
147		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
145		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
148		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
149		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
149		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
150		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
98		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
150		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
151		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
151		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
152		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
152		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
153		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
114		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
153		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
154		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
154		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
155		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
155		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
156		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
156		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
157		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
157		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
158		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
158		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
159		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
121		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
159		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
160		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
112		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
160		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
161		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
161		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
162		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
163		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
163		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
164		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
164		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
165		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
105		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
165		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
166		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
166		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
167		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
103		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
167		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
168		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
169		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
169		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
170		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
170		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
171		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
172		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
103		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
172		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
173		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
108		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
173		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
174		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
174		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
175		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
98		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
175		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
176		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
176		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
177		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
108		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
177		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
178		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
179		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
179		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
180		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
180		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
181		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
181		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
182		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
182		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
183		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
183		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
184		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
185		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
108		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
185		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
186		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
186		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
187		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
187		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
188		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
188		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
189		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
108		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
189		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
190		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
191		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
109		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
191		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
192		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
192		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
193		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
193		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
194		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
194		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
195		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
98		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
195		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
196		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
108		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
196		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
197		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
197		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
198		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
199		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
102		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
199		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
200		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
200		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
201		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
201		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
202		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
202		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
203		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
203		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
204		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
105		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
204		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
205		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
205		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
206		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
206		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
207		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
208		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
109		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
208		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
209		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
209		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
210		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
100		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
210		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
211		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
211		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
212		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
108		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
212		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
213		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
213		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
214		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
215		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
215		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
216		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
216		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
217		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
114		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
217		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
218		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
218		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
219		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
219		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
220		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
220		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
221		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
222		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
102		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
222		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
223		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
223		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
224		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
114		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
224		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
225		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
226		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
103		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
226		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
227		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
227		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
228		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
228		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
229		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
229		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
230		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
231		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
105		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
231		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
232		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
102		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
232		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
233		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
234		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
234		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
235		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
108		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
235		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
236		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
236		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
237		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
237		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
238		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
239		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
239		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
240		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
108		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
240		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
241		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
241		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
242		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
242		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
243		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
105		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
243		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
244		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
102		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
244		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
245		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
246		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
114		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
246		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
247		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
247		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
248		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
248		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
249		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
249		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
250		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
114		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
250		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
251		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
251		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
252		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
253		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
253		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
254		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
254		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
255		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
255		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
256		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
256		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
257		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
105		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
257		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
258		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
258		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
259		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
259		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
260		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
260		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
261		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
262		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
100		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
262		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
263		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
263		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
264		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
265		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
265		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
266		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
266		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
267		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
100		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
267		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
268		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
269		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
269		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
270		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
271		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
271		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
272		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
273		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
91		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
273		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
274		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
275		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
93		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
275		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
276		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
277		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
123		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
277		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
278		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
279		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
125		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
279		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
280		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
281		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
281		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
282		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
283		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
124		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
283		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
284		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
285		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
94		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
285		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
286		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
287		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
287		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
288		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
289		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
126		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
289		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
290		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
291		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
291		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
292		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
293		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
293		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
294		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
295		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
295		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
296		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
297		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
297		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
70		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
298		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
299		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
299		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
72		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
300		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
301		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
301		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
302		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
302		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
74		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
303		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
304		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
304		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
305		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
305		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
76		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
306		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
307		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
308		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
309		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
310		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
311		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
312		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
313		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
314		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
71		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
315		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
73		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
316		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
75		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
306		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
307		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
308		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
309		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
310		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
311		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
312		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
313		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
314		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
315		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
316		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
318		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
78		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
319		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
320		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
320		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
80		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
321		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
322		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
322		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
323		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
323		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
82		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
324		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
325		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
325		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
84		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
326		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
327		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
327		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
328		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
328		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
86		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
329		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
334		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
79		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
330		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
334		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
81		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
331		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
334		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
83		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
332		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
334		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
85		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
333		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
329		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
333		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
330		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
333		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
331		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
333		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
332		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
334		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
88		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
335		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
336		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
336		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
337		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
337		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
90		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
338		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
339		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
124		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
339		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
340		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
124		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
340		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
92		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
341		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
344		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
89		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
342		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
344		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
91		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
343		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
341		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
343		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
342		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
344		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
94		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
345		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
346		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
346		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
96		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
347		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
348		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
348		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
98		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
349		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
350		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
350		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
351		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
351		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
100		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
352		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
353		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
353		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
102		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
354		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
355		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
355		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
104		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
356		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
357		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
357		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
106		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
358		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
359		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
359		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
360		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
360		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
108		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
361		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
362		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
362		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
363		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
364		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
364		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
365		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
365		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
366		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
366		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
112		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
367		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
370		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
133		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
368		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
370		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
369		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
367		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
369		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
368		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
370		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
371		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
371		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
369		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
371		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
372		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
372		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
114		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
373		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
374		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
77		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
374		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
375		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
375		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
376		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
379		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
105		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
377		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
379		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
378		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
376		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
378		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
377		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
379		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
118		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
380		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
383		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
123		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
381		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
383		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
125		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
382		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
380		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
382		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
381		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
383		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
120		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
384		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
388		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
129		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
385		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
387		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
131		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
386		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
385		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
387		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
390		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
388		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
386		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
388		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
389		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
389		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
122		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
390		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
388		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
391		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
393		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
127		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
392		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
391		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
393		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
394		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
394		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
392		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
394		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
395		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
395		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
124		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
396		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
398		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
127		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
397		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
396		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
398		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
399		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
399		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
397		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
399		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
400		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
400		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
401		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
401		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
403		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
109		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
402		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
404		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
127		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
403		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
402		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
404		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
405		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
405		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
403		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
405		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
406		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
406		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
126		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
407		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
408		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
408		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
128		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
409		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
410		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
410		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
130		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
411		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
412		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
412		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
132		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
413		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
415		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
414		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
416		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
415		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
414		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
415		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
416		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
416		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
419		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
417		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
419		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
418		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
413		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
418		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
417		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
419		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
134		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
420		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
422		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
421		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
420		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
422		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
423		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
423		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
421		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
423		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
424		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
424		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
425		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
425		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
426		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
426		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
136		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
427		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
428		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
428		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
429		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
429		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
433		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
430		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
432		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
431		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
430		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
432		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
435		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
433		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
434		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
433		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
431		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
434		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
436		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
435		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
433		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
436		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
437		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
437		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
438		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
438		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
439		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
439		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
440		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
440		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
138		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
441		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
445		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
442		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
444		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
443		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
442		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
444		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
447		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
445		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
443		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
445		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
446		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
446		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
448		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
447		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
445		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
448		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
449		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
449		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
140		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
145		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
317		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
333		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
343		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
369		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
371		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
378		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
382		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
388		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
394		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
399		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
405		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
415		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
418		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
423		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
433		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
445		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_ATN =
		new ATNDeserializer().Deserialize(_serializedATN)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=
		new ATNDeserializer().Deserialize(_serializedATN)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new ATNDeserializer().Deserialize(_serializedATN)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
new ATNDeserializer().Deserialize		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
new ATNDeserializer()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ATNDeserializer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Deserialize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_serializedATN)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_serializedATN		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_serializedATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace HyperSphere {
using Antlr4.Runtime.Misc;
using IParseTreeListener = Antlr4.Runtime.Tree.IParseTreeListener;
using IToken = Antlr4.Runtime.IToken;

/// <summary>
/// This interface defines a complete listener for a parse tree produced by
/// <see cref="JuliaParser"/>.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaListener : IParseTreeListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterEndExpr([NotNull] JuliaParser.EndExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitEndExpr([NotNull] JuliaParser.EndExprContext context);
}
} // namespace HyperSphere
		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
namespace HyperSphere {
using Antlr4.Runtime.Misc;
using IParseTreeListener = Antlr4.Runtime.Tree.IParseTreeListener;
using IToken = Antlr4.Runtime.IToken;

/// <summary>
/// This interface defines a complete listener for a parse tree produced by
/// <see cref="JuliaParser"/>.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaListener : IParseTreeListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterEndExpr([NotNull] JuliaParser.EndExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitEndExpr([NotNull] JuliaParser.EndExprContext context);
}
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
HyperSphere		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Misc;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Misc		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Misc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using IParseTreeListener = Antlr4.Runtime.Tree.IParseTreeListener;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
IParseTreeListener =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4.Runtime.Tree.IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime.Tree		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Tree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using IToken = Antlr4.Runtime.IToken;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
IToken =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
IToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4.Runtime.IToken		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaListener : IParseTreeListener {
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Enter a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void EnterEndExpr([NotNull] JuliaParser.EndExprContext context);
	/// <summary>
	/// Exit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	void ExitEndExpr([NotNull] JuliaParser.EndExprContext context);
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CodeDom.Compiler.GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom.Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.CLSCompliant(false)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CLSCompliant(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
: IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterScript([NotNull] JuliaParser.ScriptContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ScriptContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ScriptContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitScript([NotNull] JuliaParser.ScriptContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ScriptContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ScriptContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterModuleExpr([NotNull] JuliaParser.ModuleExprContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterModule([NotNull] JuliaParser.ModuleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitModule([NotNull] JuliaParser.ModuleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterUsingModule([NotNull] JuliaParser.UsingModuleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.UsingModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.UsingModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitUsingModule([NotNull] JuliaParser.UsingModuleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.UsingModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.UsingModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterModuleRef([NotNull] JuliaParser.ModuleRefContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleRefContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleRefContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitModuleRef([NotNull] JuliaParser.ModuleRefContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleRefContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleRefContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ModuleIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.SymbolIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.SymbolIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.SymbolIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.SymbolIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.AbstractStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.AbstractStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.AbstractStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.AbstractStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.CompositeStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.CompositeStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.CompositeStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.CompositeStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterStructure([NotNull] JuliaParser.StructureContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitStructure([NotNull] JuliaParser.StructureContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterStructField([NotNull] JuliaParser.StructFieldContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructFieldContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructFieldContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitStructField([NotNull] JuliaParser.StructFieldContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructFieldContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructFieldContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterStructItem([NotNull] JuliaParser.StructItemContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitStructItem([NotNull] JuliaParser.StructItemContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.StructItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterBlockExpr([NotNull] JuliaParser.BlockExprContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitBlockExpr([NotNull] JuliaParser.BlockExprContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockVariableInstatiationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableInstatiationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockVariableInstatiationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableInstatiationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterBlockArg([NotNull] JuliaParser.BlockArgContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockArgContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockArgContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitBlockArg([NotNull] JuliaParser.BlockArgContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockArgContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockArgContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.BlockVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterFunction([NotNull] JuliaParser.FunctionContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitFunction([NotNull] JuliaParser.FunctionContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionHeaderContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionHeaderContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionHeaderContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionHeaderContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterFunctionItem([NotNull] JuliaParser.FunctionItemContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterFunctionCall([NotNull] JuliaParser.FunctionCallContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionCallContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionCallContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.FunctionCallContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionCallContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterShortFunction([NotNull] JuliaParser.ShortFunctionContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ShortFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ShortFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ShortFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ShortFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterLongFunction([NotNull] JuliaParser.LongFunctionContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.LongFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.LongFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitLongFunction([NotNull] JuliaParser.LongFunctionContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.LongFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.LongFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterTuple([NotNull] JuliaParser.TupleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitTuple([NotNull] JuliaParser.TupleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterNamedTuple([NotNull] JuliaParser.NamedTupleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.NamedTupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.NamedTupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.NamedTupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.NamedTupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterTypetuple([NotNull] JuliaParser.TypetupleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypetupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypetupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitTypetuple([NotNull] JuliaParser.TypetupleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypetupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypetupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterTupleList([NotNull] JuliaParser.TupleListContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TupleListContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleListContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitTupleList([NotNull] JuliaParser.TupleListContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TupleListContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleListContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterTypeName([NotNull] JuliaParser.TypeNameContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypeNameContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeNameContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitTypeName([NotNull] JuliaParser.TypeNameContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypeNameContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeNameContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ParameterizedTypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ParameterizedTypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.ParameterizedTypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ParameterizedTypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterType([NotNull] JuliaParser.TypeContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitType([NotNull] JuliaParser.TypeContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.TypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void EnterEndExpr([NotNull] JuliaParser.EndExprContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.EndExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.EndExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void ExitEndExpr([NotNull] JuliaParser.EndExprContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
([NotNull] JuliaParser.EndExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.EndExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace HyperSphere {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public const int
		RULE_script = 0, RULE_moduleExpr = 1, RULE_moduleVariableDeclaration = 2, 
		RULE_module = 3, RULE_moduleExprStatement = 4, RULE_usingModule = 5, RULE_moduleRef = 6, 
		RULE_moduleIdentifier = 7, RULE_symbolIdentifier = 8, RULE_abstractStructure = 9, 
		RULE_compositeStructure = 10, RULE_structure = 11, RULE_structField = 12, 
		RULE_structItem = 13, RULE_blockExpr = 14, RULE_blockExprStatement = 15, 
		RULE_blockVariableInstatiation = 16, RULE_blockArg = 17, RULE_blockVariableDeclaration = 18, 
		RULE_function = 19, RULE_functionHeader = 20, RULE_functionItem = 21, 
		RULE_functionCall = 22, RULE_shortFunction = 23, RULE_longFunction = 24, 
		RULE_tuple = 25, RULE_namedTuple = 26, RULE_typetuple = 27, RULE_tupleList = 28, 
		RULE_typeName = 29, RULE_parameterizedType = 30, RULE_type = 31, RULE_endExpr = 32;
	public static readonly string[] ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public JuliaParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public JuliaParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ScriptContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(JuliaParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext[] moduleExprStatement() {
			return GetRuleContexts<ModuleExprStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext moduleExprStatement(int i) {
			return GetRuleContext<ModuleExprStatementContext>(i);
		}
		public ScriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_script; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptContext script() {
		ScriptContext _localctx = new ScriptContext(Context, State);
		EnterRule(_localctx, 0, RULE_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructureContext structure() {
			return GetRuleContext<StructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleVariableDeclarationContext moduleVariableDeclaration() {
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleContext module() {
			return GetRuleContext<ModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingModuleContext usingModule() {
			return GetRuleContext<UsingModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprContext moduleExpr() {
		ModuleExprContext _localctx = new ModuleExprContext(Context, State);
		EnterRule(_localctx, 2, RULE_moduleExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		public ModuleVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleVariableDeclarationContext moduleVariableDeclaration() {
		ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Module() { return GetToken(JuliaParser.Module, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext[] moduleExpr() {
			return GetRuleContexts<ModuleExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr(int i) {
			return GetRuleContext<ModuleExprContext>(i);
		}
		public ModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_module; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleContext module() {
		ModuleContext _localctx = new ModuleContext(Context, State);
		EnterRule(_localctx, 6, RULE_module);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprStatementContext moduleExprStatement() {
		ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_moduleExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Using() { return GetToken(JuliaParser.Using, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		public UsingModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingModule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UsingModuleContext usingModule() {
		UsingModuleContext _localctx = new UsingModuleContext(Context, State);
		EnterRule(_localctx, 10, RULE_usingModule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleRefContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(JuliaParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(JuliaParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(JuliaParser.Dot); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(JuliaParser.Dot, i);
		}
		public ModuleRefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleRef; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleRefContext moduleRef() {
		ModuleRefContext _localctx = new ModuleRefContext(Context, State);
		EnterRule(_localctx, 12, RULE_moduleRef);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(JuliaParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public ModuleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleIdentifierContext moduleIdentifier() {
		ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);
		EnterRule(_localctx, 14, RULE_moduleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleIdentifierContext moduleIdentifier() {
			return GetRuleContext<ModuleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public SymbolIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolIdentifierContext symbolIdentifier() {
		SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);
		EnterRule(_localctx, 16, RULE_symbolIdentifier);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AbstractStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AbstractType() { return GetToken(JuliaParser.AbstractType, 0); }
		public AbstractStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abstractStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AbstractStructureContext abstractStructure() {
		AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);
		EnterRule(_localctx, 18, RULE_abstractStructure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompositeStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(JuliaParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mutable() { return GetToken(JuliaParser.Mutable, 0); }
		public CompositeStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compositeStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompositeStructureContext compositeStructure() {
		CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);
		EnterRule(_localctx, 20, RULE_compositeStructure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractStructureContext abstractStructure() {
			return GetRuleContext<AbstractStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompositeStructureContext compositeStructure() {
			return GetRuleContext<CompositeStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext[] structItem() {
			return GetRuleContexts<StructItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext structItem(int i) {
			return GetRuleContext<StructItemContext>(i);
		}
		public StructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructureContext structure() {
		StructureContext _localctx = new StructureContext(Context, State);
		EnterRule(_localctx, 22, RULE_structure);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructFieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structField; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructFieldContext structField() {
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 24, RULE_structField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Termination() { return GetTokens(JuliaParser.Termination); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination(int i) {
			return GetToken(JuliaParser.Termination, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext structField() {
			return GetRuleContext<StructFieldContext>(0);
		}
		public StructItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructItemContext structItem() {
		StructItemContext _localctx = new StructItemContext(Context, State);
		EnterRule(_localctx, 26, RULE_structItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableDeclarationContext blockVariableDeclaration() {
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}
		public BlockExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprContext blockExpr() {
		BlockExprContext _localctx = new BlockExprContext(Context, State);
		EnterRule(_localctx, 28, RULE_blockExpr);
		try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public BlockExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprStatementContext blockExprStatement() {
		BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_blockExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableInstatiationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assignment() { return GetToken(JuliaParser.Assignment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		public BlockVariableInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableInstatiation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableInstatiationContext blockVariableInstatiation() {
		BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);
		EnterRule(_localctx, 32, RULE_blockVariableInstatiation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ValueType() { return GetToken(JuliaParser.ValueType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public BlockArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockArgContext blockArg() {
		BlockArgContext _localctx = new BlockArgContext(Context, State);
		EnterRule(_localctx, 34, RULE_blockArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Global() { return GetToken(JuliaParser.Global, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		public BlockVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableDeclarationContext blockVariableDeclaration() {
		BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 36, RULE_blockVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShortFunctionContext shortFunction() {
			return GetRuleContext<ShortFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LongFunctionContext longFunction() {
			return GetRuleContext<LongFunctionContext>(0);
		}
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 38, RULE_function);
		try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NamedTupleContext namedTuple() {
			return GetRuleContext<NamedTupleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionHeaderContext functionHeader() {
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 40, RULE_functionHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprStatementContext blockExprStatement() {
			return GetRuleContext<BlockExprStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public FunctionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionItemContext functionItem() {
		FunctionItemContext _localctx = new FunctionItemContext(Context, State);
		EnterRule(_localctx, 42, RULE_functionItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolIdentifierContext symbolIdentifier() {
			return GetRuleContext<SymbolIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TupleContext tuple() {
			return GetRuleContext<TupleContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 44, RULE_functionCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShortFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(JuliaParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem() {
			return GetRuleContext<FunctionItemContext>(0);
		}
		public ShortFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shortFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShortFunctionContext shortFunction() {
		ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);
		EnterRule(_localctx, 46, RULE_shortFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LongFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(JuliaParser.Function, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext[] functionItem() {
			return GetRuleContexts<FunctionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem(int i) {
			return GetRuleContext<FunctionItemContext>(i);
		}
		public LongFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_longFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LongFunctionContext longFunction() {
		LongFunctionContext _localctx = new LongFunctionContext(Context, State);
		EnterRule(_localctx, 48, RULE_longFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleContext tuple() {
		TupleContext _localctx = new TupleContext(Context, State);
		EnterRule(_localctx, 50, RULE_tuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedTupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext[] blockArg() {
			return GetRuleContexts<BlockArgContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg(int i) {
			return GetRuleContext<BlockArgContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		public NamedTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedTuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedTupleContext namedTuple() {
		NamedTupleContext _localctx = new NamedTupleContext(Context, State);
		EnterRule(_localctx, 52, RULE_namedTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypetupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(JuliaParser.Comma, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TypetupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typetuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypetupleContext typetuple() {
		TypetupleContext _localctx = new TypetupleContext(Context, State);
		EnterRule(_localctx, 54, RULE_typetuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext[] blockExpr() {
			return GetRuleContexts<BlockExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr(int i) {
			return GetRuleContext<BlockExprContext>(i);
		}
		public TupleListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleListContext tupleList() {
		TupleListContext _localctx = new TupleListContext(Context, State);
		EnterRule(_localctx, 56, RULE_tupleList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extend() { return GetToken(JuliaParser.Extend, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 58, RULE_typeName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterizedTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RightBrace() { return GetTokens(JuliaParser.RightBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace(int i) {
			return GetToken(JuliaParser.RightBrace, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LeftBrace() { return GetTokens(JuliaParser.LeftBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace(int i) {
			return GetToken(JuliaParser.LeftBrace, i);
		}
		public ParameterizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterizedType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterizedTypeContext parameterizedType() {
		ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_parameterizedType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterizedTypeContext parameterizedType() {
			return GetRuleContext<ParameterizedTypeContext>(0);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_type);
		try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(JuliaParser.End, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public EndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EndExprContext endExpr() {
		EndExprContext _localctx = new EndExprContext(Context, State);
		EnterRule(_localctx, 64, RULE_endExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace HyperSphere
		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
namespace HyperSphere {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public const int
		RULE_script = 0, RULE_moduleExpr = 1, RULE_moduleVariableDeclaration = 2, 
		RULE_module = 3, RULE_moduleExprStatement = 4, RULE_usingModule = 5, RULE_moduleRef = 6, 
		RULE_moduleIdentifier = 7, RULE_symbolIdentifier = 8, RULE_abstractStructure = 9, 
		RULE_compositeStructure = 10, RULE_structure = 11, RULE_structField = 12, 
		RULE_structItem = 13, RULE_blockExpr = 14, RULE_blockExprStatement = 15, 
		RULE_blockVariableInstatiation = 16, RULE_blockArg = 17, RULE_blockVariableDeclaration = 18, 
		RULE_function = 19, RULE_functionHeader = 20, RULE_functionItem = 21, 
		RULE_functionCall = 22, RULE_shortFunction = 23, RULE_longFunction = 24, 
		RULE_tuple = 25, RULE_namedTuple = 26, RULE_typetuple = 27, RULE_tupleList = 28, 
		RULE_typeName = 29, RULE_parameterizedType = 30, RULE_type = 31, RULE_endExpr = 32;
	public static readonly string[] ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public JuliaParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public JuliaParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ScriptContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(JuliaParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext[] moduleExprStatement() {
			return GetRuleContexts<ModuleExprStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext moduleExprStatement(int i) {
			return GetRuleContext<ModuleExprStatementContext>(i);
		}
		public ScriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_script; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptContext script() {
		ScriptContext _localctx = new ScriptContext(Context, State);
		EnterRule(_localctx, 0, RULE_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructureContext structure() {
			return GetRuleContext<StructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleVariableDeclarationContext moduleVariableDeclaration() {
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleContext module() {
			return GetRuleContext<ModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingModuleContext usingModule() {
			return GetRuleContext<UsingModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprContext moduleExpr() {
		ModuleExprContext _localctx = new ModuleExprContext(Context, State);
		EnterRule(_localctx, 2, RULE_moduleExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		public ModuleVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleVariableDeclarationContext moduleVariableDeclaration() {
		ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Module() { return GetToken(JuliaParser.Module, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext[] moduleExpr() {
			return GetRuleContexts<ModuleExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr(int i) {
			return GetRuleContext<ModuleExprContext>(i);
		}
		public ModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_module; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleContext module() {
		ModuleContext _localctx = new ModuleContext(Context, State);
		EnterRule(_localctx, 6, RULE_module);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprStatementContext moduleExprStatement() {
		ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_moduleExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Using() { return GetToken(JuliaParser.Using, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		public UsingModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingModule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UsingModuleContext usingModule() {
		UsingModuleContext _localctx = new UsingModuleContext(Context, State);
		EnterRule(_localctx, 10, RULE_usingModule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleRefContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(JuliaParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(JuliaParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(JuliaParser.Dot); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(JuliaParser.Dot, i);
		}
		public ModuleRefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleRef; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleRefContext moduleRef() {
		ModuleRefContext _localctx = new ModuleRefContext(Context, State);
		EnterRule(_localctx, 12, RULE_moduleRef);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(JuliaParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public ModuleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleIdentifierContext moduleIdentifier() {
		ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);
		EnterRule(_localctx, 14, RULE_moduleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleIdentifierContext moduleIdentifier() {
			return GetRuleContext<ModuleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public SymbolIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolIdentifierContext symbolIdentifier() {
		SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);
		EnterRule(_localctx, 16, RULE_symbolIdentifier);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AbstractStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AbstractType() { return GetToken(JuliaParser.AbstractType, 0); }
		public AbstractStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abstractStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AbstractStructureContext abstractStructure() {
		AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);
		EnterRule(_localctx, 18, RULE_abstractStructure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompositeStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(JuliaParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mutable() { return GetToken(JuliaParser.Mutable, 0); }
		public CompositeStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compositeStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompositeStructureContext compositeStructure() {
		CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);
		EnterRule(_localctx, 20, RULE_compositeStructure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractStructureContext abstractStructure() {
			return GetRuleContext<AbstractStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompositeStructureContext compositeStructure() {
			return GetRuleContext<CompositeStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext[] structItem() {
			return GetRuleContexts<StructItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext structItem(int i) {
			return GetRuleContext<StructItemContext>(i);
		}
		public StructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructureContext structure() {
		StructureContext _localctx = new StructureContext(Context, State);
		EnterRule(_localctx, 22, RULE_structure);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructFieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structField; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructFieldContext structField() {
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 24, RULE_structField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Termination() { return GetTokens(JuliaParser.Termination); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination(int i) {
			return GetToken(JuliaParser.Termination, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext structField() {
			return GetRuleContext<StructFieldContext>(0);
		}
		public StructItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructItemContext structItem() {
		StructItemContext _localctx = new StructItemContext(Context, State);
		EnterRule(_localctx, 26, RULE_structItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableDeclarationContext blockVariableDeclaration() {
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}
		public BlockExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprContext blockExpr() {
		BlockExprContext _localctx = new BlockExprContext(Context, State);
		EnterRule(_localctx, 28, RULE_blockExpr);
		try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public BlockExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprStatementContext blockExprStatement() {
		BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_blockExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableInstatiationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assignment() { return GetToken(JuliaParser.Assignment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		public BlockVariableInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableInstatiation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableInstatiationContext blockVariableInstatiation() {
		BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);
		EnterRule(_localctx, 32, RULE_blockVariableInstatiation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ValueType() { return GetToken(JuliaParser.ValueType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public BlockArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockArgContext blockArg() {
		BlockArgContext _localctx = new BlockArgContext(Context, State);
		EnterRule(_localctx, 34, RULE_blockArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Global() { return GetToken(JuliaParser.Global, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		public BlockVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableDeclarationContext blockVariableDeclaration() {
		BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 36, RULE_blockVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShortFunctionContext shortFunction() {
			return GetRuleContext<ShortFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LongFunctionContext longFunction() {
			return GetRuleContext<LongFunctionContext>(0);
		}
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 38, RULE_function);
		try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NamedTupleContext namedTuple() {
			return GetRuleContext<NamedTupleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionHeaderContext functionHeader() {
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 40, RULE_functionHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprStatementContext blockExprStatement() {
			return GetRuleContext<BlockExprStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public FunctionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionItemContext functionItem() {
		FunctionItemContext _localctx = new FunctionItemContext(Context, State);
		EnterRule(_localctx, 42, RULE_functionItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolIdentifierContext symbolIdentifier() {
			return GetRuleContext<SymbolIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TupleContext tuple() {
			return GetRuleContext<TupleContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 44, RULE_functionCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShortFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(JuliaParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem() {
			return GetRuleContext<FunctionItemContext>(0);
		}
		public ShortFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shortFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShortFunctionContext shortFunction() {
		ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);
		EnterRule(_localctx, 46, RULE_shortFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LongFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(JuliaParser.Function, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext[] functionItem() {
			return GetRuleContexts<FunctionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem(int i) {
			return GetRuleContext<FunctionItemContext>(i);
		}
		public LongFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_longFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LongFunctionContext longFunction() {
		LongFunctionContext _localctx = new LongFunctionContext(Context, State);
		EnterRule(_localctx, 48, RULE_longFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleContext tuple() {
		TupleContext _localctx = new TupleContext(Context, State);
		EnterRule(_localctx, 50, RULE_tuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedTupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext[] blockArg() {
			return GetRuleContexts<BlockArgContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg(int i) {
			return GetRuleContext<BlockArgContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		public NamedTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedTuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedTupleContext namedTuple() {
		NamedTupleContext _localctx = new NamedTupleContext(Context, State);
		EnterRule(_localctx, 52, RULE_namedTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypetupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(JuliaParser.Comma, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TypetupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typetuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypetupleContext typetuple() {
		TypetupleContext _localctx = new TypetupleContext(Context, State);
		EnterRule(_localctx, 54, RULE_typetuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext[] blockExpr() {
			return GetRuleContexts<BlockExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr(int i) {
			return GetRuleContext<BlockExprContext>(i);
		}
		public TupleListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleListContext tupleList() {
		TupleListContext _localctx = new TupleListContext(Context, State);
		EnterRule(_localctx, 56, RULE_tupleList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extend() { return GetToken(JuliaParser.Extend, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 58, RULE_typeName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterizedTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RightBrace() { return GetTokens(JuliaParser.RightBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace(int i) {
			return GetToken(JuliaParser.RightBrace, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LeftBrace() { return GetTokens(JuliaParser.LeftBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace(int i) {
			return GetToken(JuliaParser.LeftBrace, i);
		}
		public ParameterizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterizedType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterizedTypeContext parameterizedType() {
		ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_parameterizedType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterizedTypeContext parameterizedType() {
			return GetRuleContext<ParameterizedTypeContext>(0);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_type);
		try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(JuliaParser.End, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public EndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EndExprContext endExpr() {
		EndExprContext _localctx = new EndExprContext(Context, State);
		EnterRule(_localctx, 64, RULE_endExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
HyperSphere		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.IO;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.IO		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IO		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Text;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Text		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Text		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Diagnostics;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Collections.Generic;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Collections.Generic		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Collections		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Collections		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Generic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Atn;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Atn		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Atn		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Misc;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Misc		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Misc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Tree;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Tree		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Tree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using DFA = Antlr4.Runtime.Dfa.DFA;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
DFA =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
DFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4.Runtime.Dfa.DFA		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime.Dfa		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Dfa		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class JuliaParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;
	public const int
		RULE_script = 0, RULE_moduleExpr = 1, RULE_moduleVariableDeclaration = 2, 
		RULE_module = 3, RULE_moduleExprStatement = 4, RULE_usingModule = 5, RULE_moduleRef = 6, 
		RULE_moduleIdentifier = 7, RULE_symbolIdentifier = 8, RULE_abstractStructure = 9, 
		RULE_compositeStructure = 10, RULE_structure = 11, RULE_structField = 12, 
		RULE_structItem = 13, RULE_blockExpr = 14, RULE_blockExprStatement = 15, 
		RULE_blockVariableInstatiation = 16, RULE_blockArg = 17, RULE_blockVariableDeclaration = 18, 
		RULE_function = 19, RULE_functionHeader = 20, RULE_functionItem = 21, 
		RULE_functionCall = 22, RULE_shortFunction = 23, RULE_longFunction = 24, 
		RULE_tuple = 25, RULE_namedTuple = 26, RULE_typetuple = 27, RULE_tupleList = 28, 
		RULE_typeName = 29, RULE_parameterizedType = 30, RULE_type = 31, RULE_endExpr = 32;
	public static readonly string[] ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Julia.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static JuliaParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public JuliaParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public JuliaParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ScriptContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(JuliaParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext[] moduleExprStatement() {
			return GetRuleContexts<ModuleExprStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext moduleExprStatement(int i) {
			return GetRuleContext<ModuleExprStatementContext>(i);
		}
		public ScriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_script; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScriptContext script() {
		ScriptContext _localctx = new ScriptContext(Context, State);
		EnterRule(_localctx, 0, RULE_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructureContext structure() {
			return GetRuleContext<StructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleVariableDeclarationContext moduleVariableDeclaration() {
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleContext module() {
			return GetRuleContext<ModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingModuleContext usingModule() {
			return GetRuleContext<UsingModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprContext moduleExpr() {
		ModuleExprContext _localctx = new ModuleExprContext(Context, State);
		EnterRule(_localctx, 2, RULE_moduleExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		public ModuleVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleVariableDeclarationContext moduleVariableDeclaration() {
		ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Module() { return GetToken(JuliaParser.Module, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext[] moduleExpr() {
			return GetRuleContexts<ModuleExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr(int i) {
			return GetRuleContext<ModuleExprContext>(i);
		}
		public ModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_module; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleContext module() {
		ModuleContext _localctx = new ModuleContext(Context, State);
		EnterRule(_localctx, 6, RULE_module);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleExprStatementContext moduleExprStatement() {
		ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_moduleExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UsingModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Using() { return GetToken(JuliaParser.Using, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		public UsingModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingModule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UsingModuleContext usingModule() {
		UsingModuleContext _localctx = new UsingModuleContext(Context, State);
		EnterRule(_localctx, 10, RULE_usingModule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleRefContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(JuliaParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(JuliaParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(JuliaParser.Dot); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(JuliaParser.Dot, i);
		}
		public ModuleRefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleRef; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleRefContext moduleRef() {
		ModuleRefContext _localctx = new ModuleRefContext(Context, State);
		EnterRule(_localctx, 12, RULE_moduleRef);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModuleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(JuliaParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public ModuleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModuleIdentifierContext moduleIdentifier() {
		ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);
		EnterRule(_localctx, 14, RULE_moduleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleIdentifierContext moduleIdentifier() {
			return GetRuleContext<ModuleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public SymbolIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolIdentifierContext symbolIdentifier() {
		SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);
		EnterRule(_localctx, 16, RULE_symbolIdentifier);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AbstractStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AbstractType() { return GetToken(JuliaParser.AbstractType, 0); }
		public AbstractStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abstractStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AbstractStructureContext abstractStructure() {
		AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);
		EnterRule(_localctx, 18, RULE_abstractStructure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompositeStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(JuliaParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mutable() { return GetToken(JuliaParser.Mutable, 0); }
		public CompositeStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compositeStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompositeStructureContext compositeStructure() {
		CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);
		EnterRule(_localctx, 20, RULE_compositeStructure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractStructureContext abstractStructure() {
			return GetRuleContext<AbstractStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompositeStructureContext compositeStructure() {
			return GetRuleContext<CompositeStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext[] structItem() {
			return GetRuleContexts<StructItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext structItem(int i) {
			return GetRuleContext<StructItemContext>(i);
		}
		public StructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructureContext structure() {
		StructureContext _localctx = new StructureContext(Context, State);
		EnterRule(_localctx, 22, RULE_structure);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructFieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structField; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructFieldContext structField() {
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 24, RULE_structField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Termination() { return GetTokens(JuliaParser.Termination); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination(int i) {
			return GetToken(JuliaParser.Termination, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext structField() {
			return GetRuleContext<StructFieldContext>(0);
		}
		public StructItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructItemContext structItem() {
		StructItemContext _localctx = new StructItemContext(Context, State);
		EnterRule(_localctx, 26, RULE_structItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableDeclarationContext blockVariableDeclaration() {
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}
		public BlockExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprContext blockExpr() {
		BlockExprContext _localctx = new BlockExprContext(Context, State);
		EnterRule(_localctx, 28, RULE_blockExpr);
		try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public BlockExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockExprStatementContext blockExprStatement() {
		BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_blockExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableInstatiationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assignment() { return GetToken(JuliaParser.Assignment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		public BlockVariableInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableInstatiation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableInstatiationContext blockVariableInstatiation() {
		BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);
		EnterRule(_localctx, 32, RULE_blockVariableInstatiation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ValueType() { return GetToken(JuliaParser.ValueType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public BlockArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockArgContext blockArg() {
		BlockArgContext _localctx = new BlockArgContext(Context, State);
		EnterRule(_localctx, 34, RULE_blockArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Global() { return GetToken(JuliaParser.Global, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		public BlockVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockVariableDeclarationContext blockVariableDeclaration() {
		BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 36, RULE_blockVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShortFunctionContext shortFunction() {
			return GetRuleContext<ShortFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LongFunctionContext longFunction() {
			return GetRuleContext<LongFunctionContext>(0);
		}
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 38, RULE_function);
		try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NamedTupleContext namedTuple() {
			return GetRuleContext<NamedTupleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionHeaderContext functionHeader() {
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 40, RULE_functionHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprStatementContext blockExprStatement() {
			return GetRuleContext<BlockExprStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public FunctionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionItemContext functionItem() {
		FunctionItemContext _localctx = new FunctionItemContext(Context, State);
		EnterRule(_localctx, 42, RULE_functionItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolIdentifierContext symbolIdentifier() {
			return GetRuleContext<SymbolIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TupleContext tuple() {
			return GetRuleContext<TupleContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 44, RULE_functionCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShortFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(JuliaParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem() {
			return GetRuleContext<FunctionItemContext>(0);
		}
		public ShortFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shortFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShortFunctionContext shortFunction() {
		ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);
		EnterRule(_localctx, 46, RULE_shortFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LongFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(JuliaParser.Function, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext[] functionItem() {
			return GetRuleContexts<FunctionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem(int i) {
			return GetRuleContext<FunctionItemContext>(i);
		}
		public LongFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_longFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LongFunctionContext longFunction() {
		LongFunctionContext _localctx = new LongFunctionContext(Context, State);
		EnterRule(_localctx, 48, RULE_longFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleContext tuple() {
		TupleContext _localctx = new TupleContext(Context, State);
		EnterRule(_localctx, 50, RULE_tuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedTupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext[] blockArg() {
			return GetRuleContexts<BlockArgContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg(int i) {
			return GetRuleContext<BlockArgContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		public NamedTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedTuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedTupleContext namedTuple() {
		NamedTupleContext _localctx = new NamedTupleContext(Context, State);
		EnterRule(_localctx, 52, RULE_namedTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypetupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(JuliaParser.Comma, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TypetupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typetuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypetupleContext typetuple() {
		TypetupleContext _localctx = new TypetupleContext(Context, State);
		EnterRule(_localctx, 54, RULE_typetuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext[] blockExpr() {
			return GetRuleContexts<BlockExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr(int i) {
			return GetRuleContext<BlockExprContext>(i);
		}
		public TupleListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleListContext tupleList() {
		TupleListContext _localctx = new TupleListContext(Context, State);
		EnterRule(_localctx, 56, RULE_tupleList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extend() { return GetToken(JuliaParser.Extend, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 58, RULE_typeName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterizedTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RightBrace() { return GetTokens(JuliaParser.RightBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace(int i) {
			return GetToken(JuliaParser.RightBrace, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LeftBrace() { return GetTokens(JuliaParser.LeftBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace(int i) {
			return GetToken(JuliaParser.LeftBrace, i);
		}
		public ParameterizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterizedType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterizedTypeContext parameterizedType() {
		ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_parameterizedType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterizedTypeContext parameterizedType() {
			return GetRuleContext<ParameterizedTypeContext>(0);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_type);
		try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(JuliaParser.End, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public EndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EndExprContext endExpr() {
		EndExprContext _localctx = new EndExprContext(Context, State);
		EnterRule(_localctx, 64, RULE_endExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CodeDom.Compiler.GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom.Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.CLSCompliant(false)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CLSCompliant(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
: Parser		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
Parser		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
Parser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
protected static DFA[] decisionToDFA;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
DFA[] decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
DFA[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
DFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
protected static PredictionContextCache sharedContextCache = new PredictionContextCache();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
PredictionContextCache sharedContextCache = new PredictionContextCache()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
PredictionContextCache		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sharedContextCache = new PredictionContextCache()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new PredictionContextCache()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new PredictionContextCache()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
PredictionContextCache		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public const int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int
		Symbol=1, AbstractType=2, Using=3, Extend=4, Global=5, Const=6, Local=7, 
		Mutable=8, Function=9, Module=10, Struct=11, For=12, Goto=13, If=14, Else=15, 
		ElseIf=16, Return=17, Continue=18, Do=19, End=20, LeftParen=21, RightParen=22, 
		LeftBracket=23, RightBracket=24, LeftBrace=25, RightBrace=26, And=27, 
		Or=28, Caret=29, Not=30, Tilde=31, Plus=32, Minus=33, Star=34, Div=35, 
		Mod=36, LeftShift=37, RightShift=38, Operator=39, Less=40, LessEqual=41, 
		Greater=42, GreaterEqual=43, ComparisonOperator=44, ShortAnd=45, ShortOr=46, 
		ShortcutOperator=47, Question=48, Colon=49, ValueType=50, Semi=51, Comma=52, 
		Assign=53, Arrow=54, Dot=55, Splat=56, Termination=57, AugmentedAssignment=58, 
		Assignment=59, Constant=60, Identifier=61, IntegerConstant=62, DecimalConstant=63, 
		NewLine=64, Whitespace=65, BlockComment=66, LineComment=67		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Symbol=1		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=1		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
AbstractType=2		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=2		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Using=3		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=3		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Extend=4		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=4		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Global=5		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=5		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Const=6		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=6		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Local=7		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=7		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Mutable=8		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=8		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Function=9		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=9		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Module=10		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=10		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Struct=11		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=11		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
For=12		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=12		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Goto=13		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=13		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
If=14		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=14		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Else=15		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=15		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ElseIf=16		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=16		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Return=17		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=17		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Continue=18		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=18		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Do=19		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=19		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
End=20		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=20		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LeftParen=21		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=21		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RightParen=22		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=22		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LeftBracket=23		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=23		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RightBracket=24		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=24		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LeftBrace=25		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=25		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RightBrace=26		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=26		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
And=27		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=27		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Or=28		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=28		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Caret=29		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=29		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Not=30		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=30		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Tilde=31		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=31		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Plus=32		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=32		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Minus=33		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=33		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Star=34		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=34		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Div=35		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=35		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Mod=36		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=36		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LeftShift=37		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=37		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RightShift=38		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=38		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Operator=39		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=39		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Less=40		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=40		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LessEqual=41		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=41		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Greater=42		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=42		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
GreaterEqual=43		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=43		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ComparisonOperator=44		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=44		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ShortAnd=45		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=45		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ShortOr=46		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=46		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ShortcutOperator=47		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=47		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Question=48		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=48		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Colon=49		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=49		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ValueType=50		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=50		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Semi=51		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=51		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
51		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Comma=52		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=52		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Assign=53		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=53		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Arrow=54		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=54		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Dot=55		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=55		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Splat=56		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=56		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Termination=57		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=57		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
AugmentedAssignment=58		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=58		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Assignment=59		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=59		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Constant=60		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=60		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Identifier=61		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=61		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
IntegerConstant=62		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=62		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
DecimalConstant=63		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=63		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
NewLine=64		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=64		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Whitespace=65		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=65		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
BlockComment=66		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=66		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LineComment=67		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=67		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public const int
		RULE_script = 0, RULE_moduleExpr = 1, RULE_moduleVariableDeclaration = 2, 
		RULE_module = 3, RULE_moduleExprStatement = 4, RULE_usingModule = 5, RULE_moduleRef = 6, 
		RULE_moduleIdentifier = 7, RULE_symbolIdentifier = 8, RULE_abstractStructure = 9, 
		RULE_compositeStructure = 10, RULE_structure = 11, RULE_structField = 12, 
		RULE_structItem = 13, RULE_blockExpr = 14, RULE_blockExprStatement = 15, 
		RULE_blockVariableInstatiation = 16, RULE_blockArg = 17, RULE_blockVariableDeclaration = 18, 
		RULE_function = 19, RULE_functionHeader = 20, RULE_functionItem = 21, 
		RULE_functionCall = 22, RULE_shortFunction = 23, RULE_longFunction = 24, 
		RULE_tuple = 25, RULE_namedTuple = 26, RULE_typetuple = 27, RULE_tupleList = 28, 
		RULE_typeName = 29, RULE_parameterizedType = 30, RULE_type = 31, RULE_endExpr = 32;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int
		RULE_script = 0, RULE_moduleExpr = 1, RULE_moduleVariableDeclaration = 2, 
		RULE_module = 3, RULE_moduleExprStatement = 4, RULE_usingModule = 5, RULE_moduleRef = 6, 
		RULE_moduleIdentifier = 7, RULE_symbolIdentifier = 8, RULE_abstractStructure = 9, 
		RULE_compositeStructure = 10, RULE_structure = 11, RULE_structField = 12, 
		RULE_structItem = 13, RULE_blockExpr = 14, RULE_blockExprStatement = 15, 
		RULE_blockVariableInstatiation = 16, RULE_blockArg = 17, RULE_blockVariableDeclaration = 18, 
		RULE_function = 19, RULE_functionHeader = 20, RULE_functionItem = 21, 
		RULE_functionCall = 22, RULE_shortFunction = 23, RULE_longFunction = 24, 
		RULE_tuple = 25, RULE_namedTuple = 26, RULE_typetuple = 27, RULE_tupleList = 28, 
		RULE_typeName = 29, RULE_parameterizedType = 30, RULE_type = 31, RULE_endExpr = 32		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
RULE_script = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_moduleExpr = 1		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 1		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_moduleVariableDeclaration = 2		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 2		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_module = 3		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 3		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_moduleExprStatement = 4		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 4		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_usingModule = 5		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 5		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_moduleRef = 6		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 6		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_moduleIdentifier = 7		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 7		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_symbolIdentifier = 8		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 8		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_abstractStructure = 9		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 9		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_compositeStructure = 10		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 10		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_structure = 11		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 11		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_structField = 12		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 12		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_structItem = 13		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 13		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_blockExpr = 14		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 14		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_blockExprStatement = 15		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 15		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_blockVariableInstatiation = 16		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 16		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_blockArg = 17		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 17		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_blockVariableDeclaration = 18		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 18		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_function = 19		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 19		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_functionHeader = 20		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 20		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_functionItem = 21		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 21		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_functionCall = 22		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 22		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_shortFunction = 23		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 23		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_longFunction = 24		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 24		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_tuple = 25		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 25		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_namedTuple = 26		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 26		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_typetuple = 27		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 27		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_tupleList = 28		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 28		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_typeName = 29		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 29		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_parameterizedType = 30		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 30		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_type = 31		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 31		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_endExpr = 32		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 32		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static readonly string[] ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	};		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
string[] ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
ruleNames = {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= {
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
{
		"script", "moduleExpr", "moduleVariableDeclaration", "module", "moduleExprStatement", 
		"usingModule", "moduleRef", "moduleIdentifier", "symbolIdentifier", "abstractStructure", 
		"compositeStructure", "structure", "structField", "structItem", "blockExpr", 
		"blockExprStatement", "blockVariableInstatiation", "blockArg", "blockVariableDeclaration", 
		"function", "functionHeader", "functionItem", "functionCall", "shortFunction", 
		"longFunction", "tuple", "namedTuple", "typetuple", "tupleList", "typeName", 
		"parameterizedType", "type", "endExpr"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
"script"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"moduleExpr"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"moduleVariableDeclaration"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"module"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"moduleExprStatement"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"usingModule"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"moduleRef"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"moduleIdentifier"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"symbolIdentifier"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"abstractStructure"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"compositeStructure"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"structure"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"structField"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"structItem"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"blockExpr"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"blockExprStatement"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"blockVariableInstatiation"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"blockArg"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"blockVariableDeclaration"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"function"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"functionHeader"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"functionItem"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"functionCall"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"shortFunction"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"longFunction"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"tuple"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"namedTuple"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"typetuple"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"tupleList"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"typeName"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"parameterizedType"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"type"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"endExpr"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
private static readonly string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	};		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
string[] _LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
_LiteralNames = {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= {
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
{
		null, null, null, "'using'", "'<:'", "'global'", "'const'", "'local'", 
		"'mutable'", "'function'", "'module'", "'struct'", "'for'", "'goto'", 
		"'if'", "'else'", "'elseif'", "'return'", "'continue'", "'do'", "'end'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'<<'", "'>>'", null, "'<'", 
		"'<='", "'>'", "'>='", null, "'&&'", "'||'", null, "'?'", "':'", "'::'", 
		"';'", "','", "'='", "'->'", "'.'", "'...'"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'using'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'<:'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'global'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'const'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'local'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'mutable'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'function'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'module'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'struct'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'for'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'goto'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'if'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'else'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'elseif'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'return'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'continue'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'do'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'end'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'('"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"')'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'['"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"']'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'{'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'}'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'&'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'|'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'^'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'!'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'~'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'+'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'-'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'*'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'/'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'%'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'<<'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'>>'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'<'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'<='"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'>'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'>='"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'&&'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'||'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'?'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"':'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'::'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"';'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"','"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'='"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'->'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'.'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"'...'"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
private static readonly string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	};		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
string[] _SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
_SymbolicNames = {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= {
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
{
		null, "Symbol", "AbstractType", "Using", "Extend", "Global", "Const", 
		"Local", "Mutable", "Function", "Module", "Struct", "For", "Goto", "If", 
		"Else", "ElseIf", "Return", "Continue", "Do", "End", "LeftParen", "RightParen", 
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "And", "Or", 
		"Caret", "Not", "Tilde", "Plus", "Minus", "Star", "Div", "Mod", "LeftShift", 
		"RightShift", "Operator", "Less", "LessEqual", "Greater", "GreaterEqual", 
		"ComparisonOperator", "ShortAnd", "ShortOr", "ShortcutOperator", "Question", 
		"Colon", "ValueType", "Semi", "Comma", "Assign", "Arrow", "Dot", "Splat", 
		"Termination", "AugmentedAssignment", "Assignment", "Constant", "Identifier", 
		"IntegerConstant", "DecimalConstant", "NewLine", "Whitespace", "BlockComment", 
		"LineComment"
	}		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Symbol"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"AbstractType"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Using"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Extend"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Global"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Const"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Local"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Mutable"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Function"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Module"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Struct"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"For"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Goto"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"If"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Else"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ElseIf"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Return"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Continue"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Do"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"End"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftParen"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightParen"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftBracket"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightBracket"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftBrace"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightBrace"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"And"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Or"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Caret"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Not"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Tilde"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Plus"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Minus"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Star"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Div"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Mod"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LeftShift"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"RightShift"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Operator"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Less"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LessEqual"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Greater"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"GreaterEqual"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ComparisonOperator"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ShortAnd"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ShortOr"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ShortcutOperator"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Question"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Colon"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"ValueType"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Semi"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Comma"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Assign"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Arrow"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Dot"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Splat"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Termination"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"AugmentedAssignment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Assignment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Constant"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Identifier"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"IntegerConstant"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"DecimalConstant"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"NewLine"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"Whitespace"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"BlockComment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"LineComment"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IVocabulary		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new Vocabulary(_LiteralNames, _SymbolicNames)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new Vocabulary(_LiteralNames, _SymbolicNames)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
Vocabulary		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_LiteralNames, _SymbolicNames)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_LiteralNames		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_LiteralNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_SymbolicNames		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_SymbolicNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IVocabulary		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		get
		{
			return DefaultVocabulary;
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get
		{
			return DefaultVocabulary;
		}		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{
			return DefaultVocabulary;
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return DefaultVocabulary;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
DefaultVocabulary		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public override string GrammarFileName { get { return "Julia.g4"; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return "Julia.g4"; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return "Julia.g4"; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return "Julia.g4"; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return "Julia.g4";		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
"Julia.g4"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public override string[] RuleNames { get { return ruleNames; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{ get { return ruleNames; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return ruleNames; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return ruleNames; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return ruleNames;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
ruleNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public override int[] SerializedAtn { get { return _serializedATN; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{ get { return _serializedATN; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return _serializedATN; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return _serializedATN; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return _serializedATN;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_serializedATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
static JuliaParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
decisionToDFA = new DFA[_ATN.NumberOfDecisions];		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
decisionToDFA = new DFA[_ATN.NumberOfDecisions]		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new DFA[_ATN.NumberOfDecisions]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax
DFA[_ATN.NumberOfDecisions]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
DFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[_ATN.NumberOfDecisions]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
_ATN.NumberOfDecisions		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NumberOfDecisions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < _ATN.NumberOfDecisions		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_ATN.NumberOfDecisions		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NumberOfDecisions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
decisionToDFA[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new DFA(_ATN.GetDecisionState(i), i)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
DFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_ATN.GetDecisionState(i), i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_ATN.GetDecisionState(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_ATN.GetDecisionState(i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_ATN.GetDecisionState		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetDecisionState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JuliaParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ITokenStream input)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ITokenStream input		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ITokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: this(input, Console.Out, Console.Error)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(input, Console.Out, Console.Error)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
input		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
input		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.Out		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Console.Out		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Out		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.Error		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Console.Error		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Error		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public JuliaParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ITokenStream input, TextWriter output, TextWriter errorOutput)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ITokenStream input		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ITokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TextWriter output		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TextWriter errorOutput		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: base(input, output, errorOutput)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(input, output, errorOutput)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
input		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
input		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
output		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
output		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
errorOutput		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
errorOutput		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ParserATNSimulator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, _ATN, decisionToDFA, sharedContextCache)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_ATN		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
decisionToDFA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sharedContextCache		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
sharedContextCache		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class ScriptContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(JuliaParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext[] moduleExprStatement() {
			return GetRuleContexts<ModuleExprStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext moduleExprStatement(int i) {
			return GetRuleContext<ModuleExprStatementContext>(i);
		}
		public ScriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_script; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(JuliaParser.Eof, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Eof, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Eof, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Eof, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Eof, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Eof		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Eof		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Eof		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<ModuleExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ModuleExprContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ModuleExprContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ModuleExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext[] moduleExprStatement() {
			return GetRuleContexts<ModuleExprStatementContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprStatementContext[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContexts<ModuleExprStatementContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContexts<ModuleExprStatementContext>();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContexts<ModuleExprStatementContext>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContexts<ModuleExprStatementContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleExprStatementContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprStatementContext moduleExprStatement(int i) {
			return GetRuleContext<ModuleExprStatementContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetRuleContext<ModuleExprStatementContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ModuleExprStatementContext>(i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ModuleExprStatementContext>(i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ModuleExprStatementContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleExprStatementContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public ScriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_script; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_script; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_script; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_script; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_script;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_script		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterScript(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterScript(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterScript(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterScript(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterScript		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterScript		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitScript(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitScript(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitScript(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitScript(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitScript		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitScript		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitScript(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitScript(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitScript(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitScript		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitScript		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public ScriptContext script() {
		ScriptContext _localctx = new ScriptContext(Context, State);
		EnterRule(_localctx, 0, RULE_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		ScriptContext _localctx = new ScriptContext(Context, State);
		EnterRule(_localctx, 0, RULE_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ScriptContext _localctx = new ScriptContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ScriptContext _localctx = new ScriptContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new ScriptContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new ScriptContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new ScriptContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 0, RULE_script);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 0, RULE_script)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 0, RULE_script)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_script		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_script		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 77;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 77;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 77		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
77		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
switch (TokenStream.LA(1)) {
			case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;
			case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
case Eof:
				{
				State = 66;
				Match(Eof);
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case Eof:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Eof		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				State = 66;
				Match(Eof);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 66;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 66		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Eof);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Eof)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Eof)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Eof		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Eof		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case AbstractType:
			case Using:
			case Global:
			case Const:
			case Local:
			case Mutable:
			case Module:
			case Struct:
			case Termination:
			case Identifier:
				{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case AbstractType:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
AbstractType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case Using:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Using		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case Global:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case Const:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case Local:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case Mutable:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case Module:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case Struct:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Struct		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case Termination:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case Identifier:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 73;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}
				State = 75;
				Match(Eof);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 73;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 73		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
73		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;
				case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;
				}		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
Interpreter.AdaptivePredict(TokenStream,1,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,1,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 1:
					{
					State = 67;
					moduleExpr();
					}
					break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 1:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
					State = 67;
					moduleExpr();
					}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 67;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 67		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
moduleExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
moduleExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case 2:
					{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}
					break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 2:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );
					}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 69;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 69		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
do {
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0) );		Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax
{
						{
						{
						State = 68;
						moduleExprStatement();
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
						{
						State = 68;
						moduleExprStatement();
						}
						}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
						State = 68;
						moduleExprStatement();
						}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 68;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 68		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
moduleExprStatement();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
moduleExprStatement()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
moduleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 71;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 71		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
71		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
(((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
((_la) & ~0x3f) == 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
((_la) & ~0x3f)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(_la) & ~0x3f		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(_la)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
~0x3f		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
0x3f		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))) != 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
((1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier)))		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(1L << _la) & ((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << _la)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << _la		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier))		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination) | (1L << Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct) | (1L << Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module) | (1L << Struct)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable) | (1L << Module)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local) | (1L << Mutable)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const) | (1L << Local)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << AbstractType) | (1L << Using) | (1L << Global) | (1L << Const)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << AbstractType) | (1L << Using) | (1L << Global)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << AbstractType) | (1L << Using)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << AbstractType)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << AbstractType		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
AbstractType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Using)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Using		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Using		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Global)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Global		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Const)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Const		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Local)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Local		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Mutable)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Module)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Module		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Struct)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Struct		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Struct		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Termination		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
State = 75;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 75		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
75		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Eof);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Eof)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Eof)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Eof		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Eof		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
default:
				throw new NoViableAltException(this);		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
default:		Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax
throw new NoViableAltException(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new NoViableAltException(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NoViableAltException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class ModuleExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructureContext structure() {
			return GetRuleContext<StructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleVariableDeclarationContext moduleVariableDeclaration() {
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleContext module() {
			return GetRuleContext<ModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UsingModuleContext usingModule() {
			return GetRuleContext<UsingModuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public StructureContext structure() {
			return GetRuleContext<StructureContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<StructureContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<StructureContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<StructureContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<StructureContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<StructureContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleVariableDeclarationContext moduleVariableDeclaration() {
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<ModuleVariableDeclarationContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ModuleVariableDeclarationContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ModuleVariableDeclarationContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ModuleVariableDeclarationContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleVariableDeclarationContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleContext module() {
			return GetRuleContext<ModuleContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<ModuleContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ModuleContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ModuleContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ModuleContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public UsingModuleContext usingModule() {
			return GetRuleContext<UsingModuleContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<UsingModuleContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<UsingModuleContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<UsingModuleContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<UsingModuleContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<UsingModuleContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<BlockExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockExprContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockExprContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Termination, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public ModuleExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_moduleExpr; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_moduleExpr; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_moduleExpr; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_moduleExpr; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_moduleExpr;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterModuleExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterModuleExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterModuleExpr(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterModuleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterModuleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitModuleExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitModuleExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitModuleExpr(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitModuleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitModuleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitModuleExpr(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitModuleExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitModuleExpr(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitModuleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitModuleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public ModuleExprContext moduleExpr() {
		ModuleExprContext _localctx = new ModuleExprContext(Context, State);
		EnterRule(_localctx, 2, RULE_moduleExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		ModuleExprContext _localctx = new ModuleExprContext(Context, State);
		EnterRule(_localctx, 2, RULE_moduleExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ModuleExprContext _localctx = new ModuleExprContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ModuleExprContext _localctx = new ModuleExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new ModuleExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new ModuleExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new ModuleExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 2, RULE_moduleExpr);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 2, RULE_moduleExpr)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 2, RULE_moduleExpr)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 80;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}

			State = 87;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 80;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 80		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
80		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Termination) {
				{
				State = 79;
				Match(Termination);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Termination		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 79;
				Match(Termination);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 79;
				Match(Termination);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 79;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 79		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
79		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Termination);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 87;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 87		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
87		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 82;
				structure();
				}
				break;
			case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;
			case 3:
				{
				State = 84;
				module();
				}
				break;
			case 4:
				{
				State = 85;
				usingModule();
				}
				break;
			case 5:
				{
				State = 86;
				blockExpr();
				}
				break;
			}		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
Interpreter.AdaptivePredict(TokenStream,4,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,4,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 1:
				{
				State = 82;
				structure();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 1:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 82;
				structure();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 82;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 82		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
82		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
structure();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
structure()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
structure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case 2:
				{
				State = 83;
				moduleVariableDeclaration();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 2:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 83;
				moduleVariableDeclaration();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 83;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 83		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
83		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
moduleVariableDeclaration();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
moduleVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
moduleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case 3:
				{
				State = 84;
				module();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 3:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 84;
				module();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 84;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 84		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
84		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
module();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
module()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case 4:
				{
				State = 85;
				usingModule();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 4:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 85;
				usingModule();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 85;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 85		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
85		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
usingModule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
usingModule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
usingModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case 5:
				{
				State = 86;
				blockExpr();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 5:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 86;
				blockExpr();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 86;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 86		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
86		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class ModuleVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		public ModuleVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<BlockArgContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockArgContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockArgContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockArgContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockArgContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Const, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Const, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Const, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Const, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Const		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Const		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Local, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Local, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Local, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Local, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Local		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Local		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockVariableInstatiationContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockVariableInstatiationContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockVariableInstatiationContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockVariableInstatiationContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public ModuleVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_moduleVariableDeclaration; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_moduleVariableDeclaration; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_moduleVariableDeclaration; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_moduleVariableDeclaration; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_moduleVariableDeclaration;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_moduleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterModuleVariableDeclaration(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterModuleVariableDeclaration(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterModuleVariableDeclaration(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterModuleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterModuleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitModuleVariableDeclaration(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitModuleVariableDeclaration(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitModuleVariableDeclaration(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitModuleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitModuleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitModuleVariableDeclaration(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitModuleVariableDeclaration(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitModuleVariableDeclaration(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitModuleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitModuleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public ModuleVariableDeclarationContext moduleVariableDeclaration() {
		ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ModuleVariableDeclarationContext _localctx = new ModuleVariableDeclarationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new ModuleVariableDeclarationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new ModuleVariableDeclarationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new ModuleVariableDeclarationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 4, RULE_moduleVariableDeclaration);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 4, RULE_moduleVariableDeclaration)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 4, RULE_moduleVariableDeclaration)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_moduleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_moduleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}

			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}

			State = 95;
			blockArg();
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}

			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 90;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 90		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
90		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Const) {
				{
				State = 89;
				Match(Const);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Const		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 89;
				Match(Const);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 89;
				Match(Const);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 89;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 89		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
89		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Const);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Const)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Const)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 93;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 93		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
93		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Local) {
				{
				State = 92;
				Match(Local);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Local		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 92;
				Match(Local);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 92;
				Match(Local);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 92;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 92		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
92		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Local);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Local)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Local)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 95;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 95		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
95		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockArg();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockArg()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 97;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 97		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Assignment) {
				{
				State = 96;
				blockVariableInstatiation();
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Assignment		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Assignment		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 96;
				blockVariableInstatiation();
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 96;
				blockVariableInstatiation();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 96;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 96		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
96		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockVariableInstatiation();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockVariableInstatiation()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockVariableInstatiation		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class ModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Module() { return GetToken(JuliaParser.Module, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext[] moduleExpr() {
			return GetRuleContexts<ModuleExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr(int i) {
			return GetRuleContext<ModuleExprContext>(i);
		}
		public ModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_module; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Module() { return GetToken(JuliaParser.Module, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Module, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Module, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Module, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Module, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Module		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Identifier, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<EndExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<EndExprContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<EndExprContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<EndExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<EndExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext[] moduleExpr() {
			return GetRuleContexts<ModuleExprContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprContext[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContexts<ModuleExprContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContexts<ModuleExprContext>();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContexts<ModuleExprContext>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContexts<ModuleExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr(int i) {
			return GetRuleContext<ModuleExprContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetRuleContext<ModuleExprContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ModuleExprContext>(i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ModuleExprContext>(i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ModuleExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public ModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_module; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_module; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_module; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_module; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_module;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModule(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterModule(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterModule(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterModule(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModule(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitModule(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitModule(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitModule(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitModule(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitModule(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitModule(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public ModuleContext module() {
		ModuleContext _localctx = new ModuleContext(Context, State);
		EnterRule(_localctx, 6, RULE_module);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		ModuleContext _localctx = new ModuleContext(Context, State);
		EnterRule(_localctx, 6, RULE_module);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ModuleContext _localctx = new ModuleContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ModuleContext _localctx = new ModuleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new ModuleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new ModuleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new ModuleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 6, RULE_module);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 6, RULE_module)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 6, RULE_module)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_module		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
int _alt;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _alt		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 99;
			Match(Module);
			State = 100;
			Match(Identifier);
			State = 104;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			State = 107;
			endExpr();
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 99;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 99		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Module);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Module)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Module)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 100;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 100		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
100		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Identifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 104;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 104		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
104		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,8,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Interpreter.AdaptivePredict(TokenStream,8,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,8,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax
_alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt!=2		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime.Atn.ATN		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime.Atn		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax
global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Atn		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}
				State = 106;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if ( _alt==1 ) {
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_alt==1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
					{
					{
					State = 101;
					moduleExpr();
					}
					} 
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
					{
					State = 101;
					moduleExpr();
					}
					}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
					State = 101;
					moduleExpr();
					}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 101;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 101		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
moduleExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
moduleExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 106;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 106		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
106		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,8,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Interpreter.AdaptivePredict(TokenStream,8,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,8,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 107;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 107		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
107		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
endExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
endExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
endExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class ModuleExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public ModuleExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleExprContext moduleExpr() {
			return GetRuleContext<ModuleExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<ModuleExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ModuleExprContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ModuleExprContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ModuleExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Termination, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public ModuleExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_moduleExprStatement; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_moduleExprStatement; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_moduleExprStatement; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_moduleExprStatement; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_moduleExprStatement;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_moduleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleExprStatement(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterModuleExprStatement(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterModuleExprStatement(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterModuleExprStatement(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterModuleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterModuleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleExprStatement(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitModuleExprStatement(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitModuleExprStatement(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitModuleExprStatement(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitModuleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitModuleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitModuleExprStatement(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitModuleExprStatement(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitModuleExprStatement(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitModuleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitModuleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public ModuleExprStatementContext moduleExprStatement() {
		ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_moduleExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_moduleExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ModuleExprStatementContext _localctx = new ModuleExprStatementContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new ModuleExprStatementContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new ModuleExprStatementContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new ModuleExprStatementContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 8, RULE_moduleExprStatement);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 8, RULE_moduleExprStatement)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 8, RULE_moduleExprStatement)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_moduleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_moduleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 109;
			moduleExpr();
			State = 110;
			Match(Termination);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 109;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 109		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
109		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
moduleExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
moduleExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 110;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 110		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Termination);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class UsingModuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Using() { return GetToken(JuliaParser.Using, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		public UsingModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_usingModule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Using() { return GetToken(JuliaParser.Using, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Using, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Using, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Using, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Using, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Using		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Using		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Using		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<ModuleRefContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ModuleRefContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ModuleRefContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ModuleRefContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleRefContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public UsingModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_usingModule; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_usingModule; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_usingModule; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_usingModule; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_usingModule;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_usingModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterUsingModule(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterUsingModule(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterUsingModule(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterUsingModule(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterUsingModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterUsingModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitUsingModule(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitUsingModule(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitUsingModule(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitUsingModule(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitUsingModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitUsingModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitUsingModule(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitUsingModule(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitUsingModule(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitUsingModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitUsingModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public UsingModuleContext usingModule() {
		UsingModuleContext _localctx = new UsingModuleContext(Context, State);
		EnterRule(_localctx, 10, RULE_usingModule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		UsingModuleContext _localctx = new UsingModuleContext(Context, State);
		EnterRule(_localctx, 10, RULE_usingModule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
UsingModuleContext _localctx = new UsingModuleContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
UsingModuleContext _localctx = new UsingModuleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new UsingModuleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new UsingModuleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new UsingModuleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 10, RULE_usingModule);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 10, RULE_usingModule)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 10, RULE_usingModule)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_usingModule		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_usingModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 112;
			Match(Using);
			State = 113;
			moduleRef();
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 112;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 112		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
112		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Using);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Using)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Using)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Using		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Using		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 113;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 113		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
113		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
moduleRef();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
moduleRef()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
moduleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class ModuleRefContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(JuliaParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(JuliaParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(JuliaParser.Dot); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(JuliaParser.Dot, i);
		}
		public ModuleRefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleRef; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(JuliaParser.Identifier); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetTokens(JuliaParser.Identifier); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetTokens(JuliaParser.Identifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetTokens(JuliaParser.Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetTokens		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(JuliaParser.Identifier, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetToken(JuliaParser.Identifier, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Identifier, i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Identifier, i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Identifier, i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(JuliaParser.Dot); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetTokens(JuliaParser.Dot); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetTokens(JuliaParser.Dot);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetTokens(JuliaParser.Dot)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetTokens		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Dot)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Dot		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Dot		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Dot		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(JuliaParser.Dot, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetToken(JuliaParser.Dot, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Dot, i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Dot, i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Dot, i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Dot		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Dot		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Dot		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public ModuleRefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_moduleRef; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_moduleRef; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_moduleRef; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_moduleRef; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_moduleRef;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_moduleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleRef(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterModuleRef(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterModuleRef(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterModuleRef(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterModuleRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterModuleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleRef(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitModuleRef(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitModuleRef(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitModuleRef(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitModuleRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitModuleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitModuleRef(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitModuleRef(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitModuleRef(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitModuleRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitModuleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public ModuleRefContext moduleRef() {
		ModuleRefContext _localctx = new ModuleRefContext(Context, State);
		EnterRule(_localctx, 12, RULE_moduleRef);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		ModuleRefContext _localctx = new ModuleRefContext(Context, State);
		EnterRule(_localctx, 12, RULE_moduleRef);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ModuleRefContext _localctx = new ModuleRefContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ModuleRefContext _localctx = new ModuleRefContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new ModuleRefContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new ModuleRefContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new ModuleRefContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 12, RULE_moduleRef);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 12, RULE_moduleRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 12, RULE_moduleRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_moduleRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_moduleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
int _alt;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _alt		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 119;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 122;
			Match(Identifier);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 119;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 119		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
119		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,9,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Interpreter.AdaptivePredict(TokenStream,9,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,9,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax
_alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt!=2		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime.Atn.ATN		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime.Atn		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax
global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Atn		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}
				State = 121;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if ( _alt==1 ) {
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_alt==1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
					{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					} 
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
					{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}
					}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
					State = 115;
					Match(Identifier);
					State = 116;
					Match(Dot);
					}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 115;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 115		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Identifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 116;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 116		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Dot);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Dot)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Dot)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Dot		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Dot		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 121;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 121		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
121		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,9,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Interpreter.AdaptivePredict(TokenStream,9,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,9,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 122;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 122		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
122		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Identifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class ModuleIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(JuliaParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public ModuleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_moduleIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<ModuleRefContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ModuleRefContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ModuleRefContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ModuleRefContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleRefContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(JuliaParser.Dot, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Dot, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Dot, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Dot, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Dot, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Dot		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Dot		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Dot		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Identifier, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public ModuleIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_moduleIdentifier; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_moduleIdentifier; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_moduleIdentifier; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_moduleIdentifier; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_moduleIdentifier;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_moduleIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterModuleIdentifier(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterModuleIdentifier(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterModuleIdentifier(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterModuleIdentifier(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterModuleIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterModuleIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitModuleIdentifier(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitModuleIdentifier(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitModuleIdentifier(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitModuleIdentifier(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitModuleIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitModuleIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitModuleIdentifier(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitModuleIdentifier(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitModuleIdentifier(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitModuleIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitModuleIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public ModuleIdentifierContext moduleIdentifier() {
		ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);
		EnterRule(_localctx, 14, RULE_moduleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);
		EnterRule(_localctx, 14, RULE_moduleIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ModuleIdentifierContext _localctx = new ModuleIdentifierContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new ModuleIdentifierContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new ModuleIdentifierContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new ModuleIdentifierContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 14, RULE_moduleIdentifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 14, RULE_moduleIdentifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 14, RULE_moduleIdentifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_moduleIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_moduleIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 124;
			moduleRef();
			State = 125;
			Match(Dot);
			State = 126;
			Match(Identifier);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 124;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 124		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
124		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
moduleRef();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
moduleRef()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
moduleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 125;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 125		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
125		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Dot);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Dot)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Dot)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Dot		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Dot		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 126;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 126		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
126		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Identifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class SymbolIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModuleIdentifierContext moduleIdentifier() {
			return GetRuleContext<ModuleIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public SymbolIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleIdentifierContext moduleIdentifier() {
			return GetRuleContext<ModuleIdentifierContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<ModuleIdentifierContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ModuleIdentifierContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ModuleIdentifierContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ModuleIdentifierContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleIdentifierContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Identifier, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public SymbolIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_symbolIdentifier; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_symbolIdentifier; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_symbolIdentifier; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_symbolIdentifier; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_symbolIdentifier;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_symbolIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterSymbolIdentifier(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterSymbolIdentifier(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterSymbolIdentifier(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterSymbolIdentifier(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterSymbolIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterSymbolIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitSymbolIdentifier(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitSymbolIdentifier(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitSymbolIdentifier(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitSymbolIdentifier(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitSymbolIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitSymbolIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitSymbolIdentifier(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitSymbolIdentifier(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitSymbolIdentifier(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitSymbolIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitSymbolIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public SymbolIdentifierContext symbolIdentifier() {
		SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);
		EnterRule(_localctx, 16, RULE_symbolIdentifier);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);
		EnterRule(_localctx, 16, RULE_symbolIdentifier);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
SymbolIdentifierContext _localctx = new SymbolIdentifierContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new SymbolIdentifierContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new SymbolIdentifierContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new SymbolIdentifierContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 16, RULE_symbolIdentifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 16, RULE_symbolIdentifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 16, RULE_symbolIdentifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_symbolIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_symbolIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 130;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 130		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
130		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;
			}		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
Interpreter.AdaptivePredict(TokenStream,10,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,10,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128;
				moduleIdentifier();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 1:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 128;
				moduleIdentifier();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 128;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 128		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
128		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
moduleIdentifier();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
moduleIdentifier()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
moduleIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129;
				Match(Identifier);
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 2:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
EnterOuterAlt(_localctx, 2);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 2)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 129;
				Match(Identifier);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 129;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 129		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
129		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Identifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class AbstractStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AbstractType() { return GetToken(JuliaParser.AbstractType, 0); }
		public AbstractStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abstractStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AbstractType() { return GetToken(JuliaParser.AbstractType, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.AbstractType, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.AbstractType, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.AbstractType, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.AbstractType, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.AbstractType		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.AbstractType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AbstractType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public AbstractStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_abstractStructure; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_abstractStructure; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_abstractStructure; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_abstractStructure; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_abstractStructure;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_abstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterAbstractStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterAbstractStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterAbstractStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterAbstractStructure(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterAbstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterAbstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitAbstractStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitAbstractStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitAbstractStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitAbstractStructure(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitAbstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitAbstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitAbstractStructure(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitAbstractStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitAbstractStructure(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitAbstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitAbstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public AbstractStructureContext abstractStructure() {
		AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);
		EnterRule(_localctx, 18, RULE_abstractStructure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);
		EnterRule(_localctx, 18, RULE_abstractStructure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
AbstractStructureContext _localctx = new AbstractStructureContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
AbstractStructureContext _localctx = new AbstractStructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new AbstractStructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new AbstractStructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new AbstractStructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 18, RULE_abstractStructure);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 18, RULE_abstractStructure)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 18, RULE_abstractStructure)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_abstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_abstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(AbstractType);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 132;
			Match(AbstractType);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 132;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 132		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
132		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(AbstractType);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(AbstractType)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(AbstractType)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
AbstractType		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
AbstractType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class CompositeStructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(JuliaParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mutable() { return GetToken(JuliaParser.Mutable, 0); }
		public CompositeStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compositeStructure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(JuliaParser.Struct, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Struct, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Struct, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Struct, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Struct, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Struct		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Struct		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Struct		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mutable() { return GetToken(JuliaParser.Mutable, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Mutable, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Mutable, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Mutable, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Mutable, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public CompositeStructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_compositeStructure; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_compositeStructure; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_compositeStructure; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_compositeStructure; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_compositeStructure;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_compositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterCompositeStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterCompositeStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterCompositeStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterCompositeStructure(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterCompositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterCompositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitCompositeStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitCompositeStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitCompositeStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitCompositeStructure(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitCompositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitCompositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitCompositeStructure(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitCompositeStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitCompositeStructure(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitCompositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitCompositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public CompositeStructureContext compositeStructure() {
		CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);
		EnterRule(_localctx, 20, RULE_compositeStructure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);
		EnterRule(_localctx, 20, RULE_compositeStructure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
CompositeStructureContext _localctx = new CompositeStructureContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
CompositeStructureContext _localctx = new CompositeStructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new CompositeStructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new CompositeStructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new CompositeStructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 20, RULE_compositeStructure);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 20, RULE_compositeStructure)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 20, RULE_compositeStructure)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_compositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_compositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}

			State = 137;
			Match(Struct);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 135;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 135		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
135		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Mutable) {
				{
				State = 134;
				Match(Mutable);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 134;
				Match(Mutable);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 134;
				Match(Mutable);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 134;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 134		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
134		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Mutable);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Mutable)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Mutable)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 137;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 137		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
137		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Struct);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Struct)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Struct)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Struct		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Struct		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class StructureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractStructureContext abstractStructure() {
			return GetRuleContext<AbstractStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompositeStructureContext compositeStructure() {
			return GetRuleContext<CompositeStructureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext[] structItem() {
			return GetRuleContexts<StructItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructItemContext structItem(int i) {
			return GetRuleContext<StructItemContext>(i);
		}
		public StructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<TypeNameContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<TypeNameContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<TypeNameContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<TypeNameContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TypeNameContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<EndExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<EndExprContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<EndExprContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<EndExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<EndExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public AbstractStructureContext abstractStructure() {
			return GetRuleContext<AbstractStructureContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<AbstractStructureContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<AbstractStructureContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<AbstractStructureContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<AbstractStructureContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<AbstractStructureContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public CompositeStructureContext compositeStructure() {
			return GetRuleContext<CompositeStructureContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<CompositeStructureContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<CompositeStructureContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<CompositeStructureContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<CompositeStructureContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<CompositeStructureContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public StructItemContext[] structItem() {
			return GetRuleContexts<StructItemContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructItemContext[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContexts<StructItemContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContexts<StructItemContext>();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContexts<StructItemContext>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContexts<StructItemContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<StructItemContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
[System.Diagnostics.DebuggerNonUserCode] public StructItemContext structItem(int i) {
			return GetRuleContext<StructItemContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetRuleContext<StructItemContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<StructItemContext>(i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<StructItemContext>(i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<StructItemContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<StructItemContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public StructureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_structure; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_structure; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_structure; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_structure; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_structure;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_structure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterStructure(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructure(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitStructure(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitStructure(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitStructure(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitStructure(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public StructureContext structure() {
		StructureContext _localctx = new StructureContext(Context, State);
		EnterRule(_localctx, 22, RULE_structure);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		StructureContext _localctx = new StructureContext(Context, State);
		EnterRule(_localctx, 22, RULE_structure);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
StructureContext _localctx = new StructureContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
StructureContext _localctx = new StructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new StructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new StructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new StructureContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 22, RULE_structure);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 22, RULE_structure)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 22, RULE_structure)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_structure		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_structure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
int _alt;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _alt		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 141;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 143;
			typeName();
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			State = 150;
			endExpr();
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 141;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 141		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
141		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
switch (TokenStream.LA(1)) {
			case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;
			case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
case AbstractType:
				{
				State = 139;
				abstractStructure();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case AbstractType:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
AbstractType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				State = 139;
				abstractStructure();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 139;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 139		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
139		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
abstractStructure();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
abstractStructure()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
abstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case Mutable:
			case Struct:
				{
				State = 140;
				compositeStructure();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case Mutable:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case Struct:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Struct		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				State = 140;
				compositeStructure();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 140;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 140		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
140		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
compositeStructure();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
compositeStructure()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
compositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
default:
				throw new NoViableAltException(this);		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
default:		Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax
throw new NoViableAltException(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new NoViableAltException(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NoViableAltException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
State = 143;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 143		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
143		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typeName();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typeName()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 147;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 147		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
147		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,13,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Interpreter.AdaptivePredict(TokenStream,13,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,13,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax
_alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt!=2		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime.Atn.ATN		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime.Atn		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax
global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Atn		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if ( _alt==1 ) {
					{
					{
					State = 144;
					structItem();
					}
					} 
				}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_alt==1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
					{
					{
					State = 144;
					structItem();
					}
					} 
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
					{
					State = 144;
					structItem();
					}
					}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
					State = 144;
					structItem();
					}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 144;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 144		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
144		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
structItem();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
structItem()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
structItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 149;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 149		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
149		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,13,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Interpreter.AdaptivePredict(TokenStream,13,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,13,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 150;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 150		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
150		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
endExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
endExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
endExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class StructFieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structField; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<BlockArgContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockArgContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockArgContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockArgContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockArgContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Const, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Const, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Const, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Const, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Const		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Const		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_structField; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_structField; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_structField; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_structField; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_structField;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_structField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterStructField(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterStructField(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterStructField(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterStructField		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterStructField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitStructField(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitStructField(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitStructField(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitStructField		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitStructField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitStructField(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitStructField(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitStructField(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitStructField		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitStructField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public StructFieldContext structField() {
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 24, RULE_structField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 24, RULE_structField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
StructFieldContext _localctx = new StructFieldContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
StructFieldContext _localctx = new StructFieldContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new StructFieldContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new StructFieldContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new StructFieldContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 24, RULE_structField);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 24, RULE_structField)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 24, RULE_structField)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_structField		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_structField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}

			State = 155;
			blockArg();
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 153;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 153		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
153		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Const) {
				{
				State = 152;
				Match(Const);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Const		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 152;
				Match(Const);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 152;
				Match(Const);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 152;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 152		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
152		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Const);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Const)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Const)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 155;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 155		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
155		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockArg();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockArg()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class StructItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Termination() { return GetTokens(JuliaParser.Termination); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination(int i) {
			return GetToken(JuliaParser.Termination, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext structField() {
			return GetRuleContext<StructFieldContext>(0);
		}
		public StructItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Termination() { return GetTokens(JuliaParser.Termination); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetTokens(JuliaParser.Termination); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetTokens(JuliaParser.Termination);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetTokens(JuliaParser.Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetTokens		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination(int i) {
			return GetToken(JuliaParser.Termination, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetToken(JuliaParser.Termination, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Termination, i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Termination, i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Termination, i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<FunctionContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<FunctionContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<FunctionContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<FunctionContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<FunctionContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext structField() {
			return GetRuleContext<StructFieldContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<StructFieldContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<StructFieldContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<StructFieldContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<StructFieldContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<StructFieldContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public StructItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_structItem; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_structItem; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_structItem; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_structItem; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_structItem;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_structItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterStructItem(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterStructItem(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterStructItem(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterStructItem(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterStructItem		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterStructItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitStructItem(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitStructItem(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitStructItem(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitStructItem(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitStructItem		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitStructItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitStructItem(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitStructItem(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitStructItem(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitStructItem		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitStructItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public StructItemContext structItem() {
		StructItemContext _localctx = new StructItemContext(Context, State);
		EnterRule(_localctx, 26, RULE_structItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		StructItemContext _localctx = new StructItemContext(Context, State);
		EnterRule(_localctx, 26, RULE_structItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
StructItemContext _localctx = new StructItemContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
StructItemContext _localctx = new StructItemContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new StructItemContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new StructItemContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new StructItemContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 26, RULE_structItem);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 26, RULE_structItem)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 26, RULE_structItem)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_structItem		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_structItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}

			State = 162;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}
			State = 164;
			Match(Termination);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 158;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 158		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
158		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Termination) {
				{
				State = 157;
				Match(Termination);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Termination		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 157;
				Match(Termination);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 157;
				Match(Termination);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 157;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 157		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
157		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Termination);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 162;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 162		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
162		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 160;
				function();
				}
				break;
			case 2:
				{
				State = 161;
				structField();
				}
				break;
			}		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
Interpreter.AdaptivePredict(TokenStream,16,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,16,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 1:
				{
				State = 160;
				function();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 1:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 160;
				function();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 160;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 160		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
160		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
function();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
function()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case 2:
				{
				State = 161;
				structField();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 2:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 161;
				structField();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 161;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 161		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
161		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
structField();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
structField()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
structField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
State = 164;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 164		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
164		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Termination);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class BlockExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableDeclarationContext blockVariableDeclaration() {
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}
		public BlockExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<FunctionCallContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<FunctionCallContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<FunctionCallContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<FunctionCallContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<FunctionCallContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockVariableDeclarationContext blockVariableDeclaration() {
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<BlockVariableDeclarationContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockVariableDeclarationContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockVariableDeclarationContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockVariableDeclarationContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockVariableDeclarationContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public BlockExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_blockExpr; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_blockExpr; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_blockExpr; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_blockExpr; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_blockExpr;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterBlockExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterBlockExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterBlockExpr(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterBlockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterBlockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitBlockExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitBlockExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitBlockExpr(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitBlockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitBlockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitBlockExpr(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitBlockExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitBlockExpr(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitBlockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitBlockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public BlockExprContext blockExpr() {
		BlockExprContext _localctx = new BlockExprContext(Context, State);
		EnterRule(_localctx, 28, RULE_blockExpr);
		try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		BlockExprContext _localctx = new BlockExprContext(Context, State);
		EnterRule(_localctx, 28, RULE_blockExpr);
		try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
BlockExprContext _localctx = new BlockExprContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
BlockExprContext _localctx = new BlockExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new BlockExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new BlockExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new BlockExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 28, RULE_blockExpr);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 28, RULE_blockExpr)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 28, RULE_blockExpr)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			State = 168;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 168;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 168		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
168		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;
			}		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
Interpreter.AdaptivePredict(TokenStream,17,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,17,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 166;
				functionCall();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 1:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 166;
				functionCall();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 166;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 166		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
166		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
functionCall();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
functionCall()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
functionCall		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167;
				blockVariableDeclaration();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 2:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
EnterOuterAlt(_localctx, 2);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 2)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 167;
				blockVariableDeclaration();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 167;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 167		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
167		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockVariableDeclaration();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class BlockExprStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public BlockExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockExprStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<BlockExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockExprContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockExprContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Termination, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public BlockExprStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_blockExprStatement; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_blockExprStatement; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_blockExprStatement; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_blockExprStatement; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_blockExprStatement;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_blockExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockExprStatement(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterBlockExprStatement(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterBlockExprStatement(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterBlockExprStatement(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterBlockExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterBlockExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockExprStatement(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitBlockExprStatement(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitBlockExprStatement(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitBlockExprStatement(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitBlockExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitBlockExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitBlockExprStatement(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitBlockExprStatement(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitBlockExprStatement(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitBlockExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitBlockExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public BlockExprStatementContext blockExprStatement() {
		BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_blockExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_blockExprStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
BlockExprStatementContext _localctx = new BlockExprStatementContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new BlockExprStatementContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new BlockExprStatementContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new BlockExprStatementContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 30, RULE_blockExprStatement);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 30, RULE_blockExprStatement)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 30, RULE_blockExprStatement)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_blockExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_blockExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 170;
			blockExpr();
			State = 171;
			Match(Termination);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 170;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 170		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
170		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 171;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 171		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
171		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Termination);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class BlockVariableInstatiationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assignment() { return GetToken(JuliaParser.Assignment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}
		public BlockVariableInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableInstatiation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assignment() { return GetToken(JuliaParser.Assignment, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Assignment, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Assignment, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Assignment, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Assignment, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Assignment		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Assignment		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Assignment		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr() {
			return GetRuleContext<BlockExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<BlockExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockExprContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockExprContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public BlockVariableInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_blockVariableInstatiation; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_blockVariableInstatiation; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_blockVariableInstatiation; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_blockVariableInstatiation; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_blockVariableInstatiation;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_blockVariableInstatiation		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterBlockVariableInstatiation(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterBlockVariableInstatiation(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterBlockVariableInstatiation(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterBlockVariableInstatiation		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterBlockVariableInstatiation		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitBlockVariableInstatiation(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitBlockVariableInstatiation(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitBlockVariableInstatiation(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitBlockVariableInstatiation		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitBlockVariableInstatiation		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitBlockVariableInstatiation(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitBlockVariableInstatiation(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitBlockVariableInstatiation(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitBlockVariableInstatiation		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitBlockVariableInstatiation		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public BlockVariableInstatiationContext blockVariableInstatiation() {
		BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);
		EnterRule(_localctx, 32, RULE_blockVariableInstatiation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);
		EnterRule(_localctx, 32, RULE_blockVariableInstatiation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
BlockVariableInstatiationContext _localctx = new BlockVariableInstatiationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new BlockVariableInstatiationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new BlockVariableInstatiationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new BlockVariableInstatiationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 32, RULE_blockVariableInstatiation);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 32, RULE_blockVariableInstatiation)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 32, RULE_blockVariableInstatiation)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_blockVariableInstatiation		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_blockVariableInstatiation		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 173;
			Match(Assignment);
			State = 174;
			blockExpr();
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 173;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 173		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
173		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Assignment);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Assignment)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Assignment)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Assignment		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Assignment		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 174;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 174		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
174		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class BlockArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ValueType() { return GetToken(JuliaParser.ValueType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public BlockArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Identifier, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ValueType() { return GetToken(JuliaParser.ValueType, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.ValueType, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.ValueType, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.ValueType, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.ValueType, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.ValueType		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.ValueType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ValueType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<TypeContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<TypeContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<TypeContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<TypeContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TypeContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public BlockArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_blockArg; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_blockArg; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_blockArg; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_blockArg; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_blockArg;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockArg(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterBlockArg(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterBlockArg(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterBlockArg(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterBlockArg		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterBlockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockArg(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitBlockArg(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitBlockArg(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitBlockArg(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitBlockArg		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitBlockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitBlockArg(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitBlockArg(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitBlockArg(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitBlockArg		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitBlockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public BlockArgContext blockArg() {
		BlockArgContext _localctx = new BlockArgContext(Context, State);
		EnterRule(_localctx, 34, RULE_blockArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		BlockArgContext _localctx = new BlockArgContext(Context, State);
		EnterRule(_localctx, 34, RULE_blockArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
BlockArgContext _localctx = new BlockArgContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
BlockArgContext _localctx = new BlockArgContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new BlockArgContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new BlockArgContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new BlockArgContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 34, RULE_blockArg);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 34, RULE_blockArg)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 34, RULE_blockArg)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 176;
			Match(Identifier);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}

			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 176;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 176		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
176		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Identifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 179;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 179		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
179		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==ValueType) {
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==ValueType		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ValueType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 177;
				Match(ValueType);
				State = 178;
				type();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 177;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 177		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
177		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(ValueType);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(ValueType)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ValueType)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ValueType		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ValueType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 178;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 178		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
178		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
type();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
type()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class BlockVariableDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Global() { return GetToken(JuliaParser.Global, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }
		public BlockVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockVariableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg() {
			return GetRuleContext<BlockArgContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<BlockArgContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockArgContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockArgContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockArgContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockArgContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(JuliaParser.Const, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Const, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Const, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Const, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Const, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Const		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Const		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockVariableInstatiationContext blockVariableInstatiation() {
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<BlockVariableInstatiationContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockVariableInstatiationContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockVariableInstatiationContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockVariableInstatiationContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockVariableInstatiationContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Global() { return GetToken(JuliaParser.Global, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Global, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Global, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Global, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Global, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Global		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Global		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Local() { return GetToken(JuliaParser.Local, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Local, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Local, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Local, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Local, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Local		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Local		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public BlockVariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_blockVariableDeclaration; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_blockVariableDeclaration; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_blockVariableDeclaration; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_blockVariableDeclaration; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_blockVariableDeclaration;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_blockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterBlockVariableDeclaration(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterBlockVariableDeclaration(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterBlockVariableDeclaration(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterBlockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterBlockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitBlockVariableDeclaration(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitBlockVariableDeclaration(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitBlockVariableDeclaration(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitBlockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitBlockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitBlockVariableDeclaration(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitBlockVariableDeclaration(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitBlockVariableDeclaration(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitBlockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitBlockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public BlockVariableDeclarationContext blockVariableDeclaration() {
		BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 36, RULE_blockVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);
		EnterRule(_localctx, 36, RULE_blockVariableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
BlockVariableDeclarationContext _localctx = new BlockVariableDeclarationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new BlockVariableDeclarationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new BlockVariableDeclarationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new BlockVariableDeclarationContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 36, RULE_blockVariableDeclaration);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 36, RULE_blockVariableDeclaration)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 36, RULE_blockVariableDeclaration)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_blockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_blockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}

			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 187;
			blockArg();
			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}

			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 182;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 182		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
182		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Const) {
				{
				State = 181;
				Match(Const);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Const		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 181;
				Match(Const);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 181;
				Match(Const);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 181;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 181		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
181		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Const);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Const)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Const)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 185;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 185		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
185		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Global || _la==Local) {
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Global || _la==Local		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la==Global		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_la==Local		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 184;
				_la = TokenStream.LA(1);
				if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 184;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 184		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
184		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if ( !(_la==Global || _la==Local) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!(_la==Global || _la==Local)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
(_la==Global || _la==Local)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
_la==Global || _la==Local		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la==Global		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_la==Local		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				ErrorHandler.RecoverInline(this);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ErrorHandler.RecoverInline(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.RecoverInline(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.RecoverInline		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RecoverInline		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
{
					ErrorHandler.ReportMatch(this);
				    Consume();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ErrorHandler.ReportMatch(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportMatch(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportMatch		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportMatch		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
Consume();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Consume()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Consume		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 187;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 187		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
187		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockArg();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockArg()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 189;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 189		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
189		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Assignment) {
				{
				State = 188;
				blockVariableInstatiation();
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Assignment		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Assignment		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 188;
				blockVariableInstatiation();
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 188;
				blockVariableInstatiation();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 188;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 188		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
188		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockVariableInstatiation();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockVariableInstatiation()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockVariableInstatiation		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class FunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShortFunctionContext shortFunction() {
			return GetRuleContext<ShortFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LongFunctionContext longFunction() {
			return GetRuleContext<LongFunctionContext>(0);
		}
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ShortFunctionContext shortFunction() {
			return GetRuleContext<ShortFunctionContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<ShortFunctionContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ShortFunctionContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ShortFunctionContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ShortFunctionContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ShortFunctionContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public LongFunctionContext longFunction() {
			return GetRuleContext<LongFunctionContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<LongFunctionContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<LongFunctionContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<LongFunctionContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<LongFunctionContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<LongFunctionContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_function; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_function; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_function; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_function; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_function;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterFunction(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterFunction		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitFunction(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitFunction		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitFunction(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitFunction		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 38, RULE_function);
		try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 38, RULE_function);
		try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
FunctionContext _localctx = new FunctionContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
FunctionContext _localctx = new FunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new FunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new FunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new FunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 38, RULE_function);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 38, RULE_function)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 38, RULE_function)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_function		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			State = 193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 193;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 193		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
193		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;
			case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				shortFunction();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case Identifier:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 191;
				shortFunction();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 191;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 191		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
191		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
shortFunction();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
shortFunction()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
shortFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case Function:
				EnterOuterAlt(_localctx, 2);
				{
				State = 192;
				longFunction();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case Function:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterOuterAlt(_localctx, 2);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 2)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 192;
				longFunction();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 192;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 192		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
192		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
longFunction();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
longFunction()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
longFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
default:
				throw new NoViableAltException(this);		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
default:		Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax
throw new NoViableAltException(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new NoViableAltException(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NoViableAltException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class FunctionHeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NamedTupleContext namedTuple() {
			return GetRuleContext<NamedTupleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public NamedTupleContext namedTuple() {
			return GetRuleContext<NamedTupleContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<NamedTupleContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<NamedTupleContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<NamedTupleContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<NamedTupleContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<NamedTupleContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ModuleRefContext moduleRef() {
			return GetRuleContext<ModuleRefContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<ModuleRefContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ModuleRefContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ModuleRefContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ModuleRefContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ModuleRefContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Identifier, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_functionHeader; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_functionHeader; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_functionHeader; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_functionHeader; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_functionHeader;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_functionHeader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterFunctionHeader(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterFunctionHeader(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterFunctionHeader(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterFunctionHeader		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterFunctionHeader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitFunctionHeader(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitFunctionHeader(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitFunctionHeader(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitFunctionHeader		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitFunctionHeader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitFunctionHeader(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitFunctionHeader(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitFunctionHeader		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitFunctionHeader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public FunctionHeaderContext functionHeader() {
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 40, RULE_functionHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);
		EnterRule(_localctx, 40, RULE_functionHeader);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
FunctionHeaderContext _localctx = new FunctionHeaderContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new FunctionHeaderContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new FunctionHeaderContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new FunctionHeaderContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 40, RULE_functionHeader);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 40, RULE_functionHeader)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 40, RULE_functionHeader)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_functionHeader		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_functionHeader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 197;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}
			State = 199;
			namedTuple();
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 197;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 197		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
197		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				{
				State = 195;
				moduleRef();
				}
				break;
			case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;
			}		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
Interpreter.AdaptivePredict(TokenStream,23,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,23,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 1:
				{
				State = 195;
				moduleRef();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 1:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 195;
				moduleRef();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 195;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 195		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
195		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
moduleRef();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
moduleRef()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
moduleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case 2:
				{
				State = 196;
				Match(Identifier);
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 2:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 196;
				Match(Identifier);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 196;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 196		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
196		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Identifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
State = 199;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 199		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
199		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
namedTuple();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
namedTuple()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
namedTuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class FunctionItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprStatementContext blockExprStatement() {
			return GetRuleContext<BlockExprStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public FunctionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockExprStatementContext blockExprStatement() {
			return GetRuleContext<BlockExprStatementContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<BlockExprStatementContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockExprStatementContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockExprStatementContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockExprStatementContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockExprStatementContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Termination, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public FunctionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_functionItem; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_functionItem; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_functionItem; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_functionItem; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_functionItem;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_functionItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionItem(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterFunctionItem(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterFunctionItem(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterFunctionItem(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterFunctionItem		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterFunctionItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionItem(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitFunctionItem(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitFunctionItem(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitFunctionItem(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitFunctionItem		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitFunctionItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitFunctionItem(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitFunctionItem(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitFunctionItem(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitFunctionItem		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitFunctionItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public FunctionItemContext functionItem() {
		FunctionItemContext _localctx = new FunctionItemContext(Context, State);
		EnterRule(_localctx, 42, RULE_functionItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		FunctionItemContext _localctx = new FunctionItemContext(Context, State);
		EnterRule(_localctx, 42, RULE_functionItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
FunctionItemContext _localctx = new FunctionItemContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
FunctionItemContext _localctx = new FunctionItemContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new FunctionItemContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new FunctionItemContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new FunctionItemContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 42, RULE_functionItem);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 42, RULE_functionItem)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 42, RULE_functionItem)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_functionItem		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_functionItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 201;
			blockExprStatement();
			State = 202;
			Match(Termination);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 201;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 201		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
201		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockExprStatement();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockExprStatement()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 202;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 202		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
202		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Termination);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolIdentifierContext symbolIdentifier() {
			return GetRuleContext<SymbolIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TupleContext tuple() {
			return GetRuleContext<TupleContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public SymbolIdentifierContext symbolIdentifier() {
			return GetRuleContext<SymbolIdentifierContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<SymbolIdentifierContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<SymbolIdentifierContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<SymbolIdentifierContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<SymbolIdentifierContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<SymbolIdentifierContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public TupleContext tuple() {
			return GetRuleContext<TupleContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<TupleContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<TupleContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<TupleContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<TupleContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TupleContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_functionCall; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_functionCall; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_functionCall; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_functionCall; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_functionCall;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_functionCall		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterFunctionCall(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterFunctionCall(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterFunctionCall(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterFunctionCall		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterFunctionCall		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitFunctionCall(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitFunctionCall(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitFunctionCall(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitFunctionCall		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitFunctionCall		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitFunctionCall(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitFunctionCall(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitFunctionCall		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitFunctionCall		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 44, RULE_functionCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 44, RULE_functionCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
FunctionCallContext _localctx = new FunctionCallContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
FunctionCallContext _localctx = new FunctionCallContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new FunctionCallContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new FunctionCallContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new FunctionCallContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 44, RULE_functionCall);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 44, RULE_functionCall)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 44, RULE_functionCall)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_functionCall		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_functionCall		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 204;
			symbolIdentifier();
			State = 205;
			tuple();
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 204;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 204		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
204		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
symbolIdentifier();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
symbolIdentifier()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
symbolIdentifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 205;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 205		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
205		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
tuple();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tuple()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class ShortFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(JuliaParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem() {
			return GetRuleContext<FunctionItemContext>(0);
		}
		public ShortFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shortFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<FunctionHeaderContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<FunctionHeaderContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<FunctionHeaderContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<FunctionHeaderContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<FunctionHeaderContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(JuliaParser.Assign, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Assign, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Assign, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Assign, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Assign, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Assign		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Assign		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Assign		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem() {
			return GetRuleContext<FunctionItemContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<FunctionItemContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<FunctionItemContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<FunctionItemContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<FunctionItemContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<FunctionItemContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public ShortFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_shortFunction; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_shortFunction; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_shortFunction; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_shortFunction; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_shortFunction;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_shortFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterShortFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterShortFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterShortFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterShortFunction(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterShortFunction		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterShortFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitShortFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitShortFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitShortFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitShortFunction(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitShortFunction		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitShortFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitShortFunction(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitShortFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitShortFunction(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitShortFunction		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitShortFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public ShortFunctionContext shortFunction() {
		ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);
		EnterRule(_localctx, 46, RULE_shortFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);
		EnterRule(_localctx, 46, RULE_shortFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ShortFunctionContext _localctx = new ShortFunctionContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ShortFunctionContext _localctx = new ShortFunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new ShortFunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new ShortFunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new ShortFunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 46, RULE_shortFunction);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 46, RULE_shortFunction)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 46, RULE_shortFunction)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_shortFunction		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_shortFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 207;
			functionHeader();
			State = 208;
			Match(Assign);
			State = 209;
			functionItem();
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 207;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 207		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
207		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
functionHeader();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
functionHeader()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
functionHeader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 208;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 208		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
208		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Assign);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Assign)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Assign)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Assign		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Assign		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 209;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 209		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
209		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
functionItem();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
functionItem()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
functionItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class LongFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(JuliaParser.Function, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext[] functionItem() {
			return GetRuleContexts<FunctionItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem(int i) {
			return GetRuleContext<FunctionItemContext>(i);
		}
		public LongFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_longFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(JuliaParser.Function, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Function, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Function, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Function, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Function, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Function		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Function		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<FunctionHeaderContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<FunctionHeaderContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<FunctionHeaderContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<FunctionHeaderContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<FunctionHeaderContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Termination, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public EndExprContext endExpr() {
			return GetRuleContext<EndExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<EndExprContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<EndExprContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<EndExprContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<EndExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<EndExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext[] functionItem() {
			return GetRuleContexts<FunctionItemContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionItemContext[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContexts<FunctionItemContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContexts<FunctionItemContext>();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContexts<FunctionItemContext>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContexts<FunctionItemContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<FunctionItemContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
[System.Diagnostics.DebuggerNonUserCode] public FunctionItemContext functionItem(int i) {
			return GetRuleContext<FunctionItemContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetRuleContext<FunctionItemContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<FunctionItemContext>(i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<FunctionItemContext>(i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<FunctionItemContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<FunctionItemContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public LongFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_longFunction; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_longFunction; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_longFunction; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_longFunction; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_longFunction;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_longFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterLongFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterLongFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterLongFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterLongFunction(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterLongFunction		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterLongFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitLongFunction(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitLongFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitLongFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitLongFunction(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitLongFunction		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitLongFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitLongFunction(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitLongFunction(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitLongFunction(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitLongFunction		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitLongFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public LongFunctionContext longFunction() {
		LongFunctionContext _localctx = new LongFunctionContext(Context, State);
		EnterRule(_localctx, 48, RULE_longFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		LongFunctionContext _localctx = new LongFunctionContext(Context, State);
		EnterRule(_localctx, 48, RULE_longFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
LongFunctionContext _localctx = new LongFunctionContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
LongFunctionContext _localctx = new LongFunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new LongFunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new LongFunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new LongFunctionContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 48, RULE_longFunction);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 48, RULE_longFunction)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 48, RULE_longFunction)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_longFunction		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_longFunction		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 211;
			Match(Function);
			State = 212;
			functionHeader();
			State = 213;
			Match(Termination);
			State = 217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 220;
			endExpr();
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 211;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 211		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
211		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Function);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Function)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Function)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 212;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 212		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
212		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
functionHeader();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
functionHeader()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
functionHeader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 213;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 213		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
213		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Termination);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 217;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 217		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
217		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax
(((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
((_la) & ~0x3f) == 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
((_la) & ~0x3f)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(_la) & ~0x3f		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(_la)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
~0x3f		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
0x3f		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier)))		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << _la)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << _la		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << Global) | (1L << Const) | (1L << Local)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << Global) | (1L << Const)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << Global)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Global		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Const)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Const		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Local)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Local		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				{
				{
				State = 214;
				functionItem();
				}
				}
				State = 219;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				{
				State = 214;
				functionItem();
				}
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 214;
				functionItem();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 214;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 214		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
214		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
functionItem();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
functionItem()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
functionItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 219;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 219		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
219		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
State = 220;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 220		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
220		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
endExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
endExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
endExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class TupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.RightParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.RightParen, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.RightParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.RightParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<TupleListContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<TupleListContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<TupleListContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<TupleListContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TupleListContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.LeftParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.LeftParen, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.LeftParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.LeftParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public TupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_tuple; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_tuple; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_tuple; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_tuple; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_tuple;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_tuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterTuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterTuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterTuple(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterTuple		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterTuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitTuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitTuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitTuple(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitTuple		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitTuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitTuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitTuple(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitTuple		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitTuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public TupleContext tuple() {
		TupleContext _localctx = new TupleContext(Context, State);
		EnterRule(_localctx, 50, RULE_tuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		TupleContext _localctx = new TupleContext(Context, State);
		EnterRule(_localctx, 50, RULE_tuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
TupleContext _localctx = new TupleContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
TupleContext _localctx = new TupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new TupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new TupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new TupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 50, RULE_tuple);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 50, RULE_tuple)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 50, RULE_tuple)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_tuple		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_tuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 222;
			Match(RightParen);
			State = 223;
			tupleList();
			State = 224;
			Match(LeftParen);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 222;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 222		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
222		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(RightParen);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(RightParen)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(RightParen)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 223;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 223		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
223		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
tupleList();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tupleList()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tupleList		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 224;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 224		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
224		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(LeftParen);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(LeftParen)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(LeftParen)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class NamedTupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext[] blockArg() {
			return GetRuleContexts<BlockArgContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg(int i) {
			return GetRuleContext<BlockArgContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		public NamedTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedTuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.RightParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.RightParen, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.RightParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.RightParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.LeftParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.LeftParen, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.LeftParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.LeftParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext[] blockArg() {
			return GetRuleContexts<BlockArgContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockArgContext[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContexts<BlockArgContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContexts<BlockArgContext>();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContexts<BlockArgContext>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContexts<BlockArgContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockArgContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockArgContext blockArg(int i) {
			return GetRuleContext<BlockArgContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetRuleContext<BlockArgContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockArgContext>(i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockArgContext>(i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockArgContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockArgContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetTokens(JuliaParser.Comma); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetTokens(JuliaParser.Comma);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetTokens(JuliaParser.Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetTokens		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Comma		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Comma		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetToken(JuliaParser.Comma, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Comma, i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Comma, i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Comma, i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Comma		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Comma		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public NamedTupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_namedTuple; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_namedTuple; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_namedTuple; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_namedTuple; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_namedTuple;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_namedTuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterNamedTuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterNamedTuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterNamedTuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterNamedTuple(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterNamedTuple		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterNamedTuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitNamedTuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitNamedTuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitNamedTuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitNamedTuple(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitNamedTuple		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitNamedTuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitNamedTuple(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitNamedTuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitNamedTuple(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitNamedTuple		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitNamedTuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public NamedTupleContext namedTuple() {
		NamedTupleContext _localctx = new NamedTupleContext(Context, State);
		EnterRule(_localctx, 52, RULE_namedTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		NamedTupleContext _localctx = new NamedTupleContext(Context, State);
		EnterRule(_localctx, 52, RULE_namedTuple);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
NamedTupleContext _localctx = new NamedTupleContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
NamedTupleContext _localctx = new NamedTupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new NamedTupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new NamedTupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new NamedTupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 52, RULE_namedTuple);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 52, RULE_namedTuple)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 52, RULE_namedTuple)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_namedTuple		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_namedTuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
int _alt;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _alt		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 226;
			Match(RightParen);
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}

			State = 238;
			Match(LeftParen);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 226;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 226		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
226		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(RightParen);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(RightParen)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(RightParen)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 236;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 236		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
236		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Identifier) {
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 232;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}
				State = 235;
				blockArg();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 232;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 232		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
232		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,25,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Interpreter.AdaptivePredict(TokenStream,25,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,25,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax
_alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt!=2		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime.Atn.ATN		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime.Atn		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
global::Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax
global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Atn		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
INVALID_ALT_NUMBER		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
					if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}
					State = 234;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if ( _alt==1 ) {
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_alt==1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
						{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						} 
					}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
						{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}
						}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
						State = 227;
						blockArg();
						State = 228;
						Match(Comma);
						}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 227;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 227		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
227		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockArg();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockArg()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 228;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 228		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
228		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Comma);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 234;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 234		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
234		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_alt = Interpreter.AdaptivePredict(TokenStream,25,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_alt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Interpreter.AdaptivePredict(TokenStream,25,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,25,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 235;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 235		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
235		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockArg();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockArg()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 238;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 238		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
238		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(LeftParen);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(LeftParen)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(LeftParen)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class TypetupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(JuliaParser.Comma, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }
		public TypetupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typetuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(JuliaParser.RightParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.RightParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.RightParen, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.RightParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.RightParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public TupleListContext tupleList() {
			return GetRuleContext<TupleListContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<TupleListContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<TupleListContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<TupleListContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<TupleListContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TupleListContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(JuliaParser.Comma, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Comma, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Comma, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Comma, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Comma, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Comma		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Comma		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(JuliaParser.LeftParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.LeftParen, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.LeftParen, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.LeftParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.LeftParen, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public TypetupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_typetuple; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_typetuple; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_typetuple; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_typetuple; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_typetuple;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_typetuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypetuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterTypetuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterTypetuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterTypetuple(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterTypetuple		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterTypetuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypetuple(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitTypetuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitTypetuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitTypetuple(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitTypetuple		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitTypetuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitTypetuple(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitTypetuple(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitTypetuple(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitTypetuple		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitTypetuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public TypetupleContext typetuple() {
		TypetupleContext _localctx = new TypetupleContext(Context, State);
		EnterRule(_localctx, 54, RULE_typetuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		TypetupleContext _localctx = new TypetupleContext(Context, State);
		EnterRule(_localctx, 54, RULE_typetuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
TypetupleContext _localctx = new TypetupleContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
TypetupleContext _localctx = new TypetupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new TypetupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new TypetupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new TypetupleContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 54, RULE_typetuple);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 54, RULE_typetuple)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 54, RULE_typetuple)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_typetuple		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_typetuple		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 240;
			Match(RightParen);
			State = 241;
			tupleList();
			State = 242;
			Match(Comma);
			State = 243;
			Match(LeftParen);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 240;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 240		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
240		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(RightParen);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(RightParen)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(RightParen)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RightParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 241;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 241		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
241		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
tupleList();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tupleList()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tupleList		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 242;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 242		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
242		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Comma);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 243;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 243		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
243		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(LeftParen);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(LeftParen)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(LeftParen)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
LeftParen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class TupleListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext[] blockExpr() {
			return GetRuleContexts<BlockExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr(int i) {
			return GetRuleContext<BlockExprContext>(i);
		}
		public TupleListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(JuliaParser.Comma); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetTokens(JuliaParser.Comma); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetTokens(JuliaParser.Comma);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetTokens(JuliaParser.Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetTokens		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Comma		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Comma		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(JuliaParser.Comma, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetToken(JuliaParser.Comma, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Comma, i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Comma, i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Comma, i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Comma		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Comma		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext[] blockExpr() {
			return GetRuleContexts<BlockExprContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContexts<BlockExprContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContexts<BlockExprContext>();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContexts<BlockExprContext>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContexts<BlockExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
[System.Diagnostics.DebuggerNonUserCode] public BlockExprContext blockExpr(int i) {
			return GetRuleContext<BlockExprContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetRuleContext<BlockExprContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<BlockExprContext>(i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<BlockExprContext>(i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<BlockExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<BlockExprContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public TupleListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_tupleList; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_tupleList; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_tupleList; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_tupleList; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_tupleList;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_tupleList		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTupleList(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterTupleList(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterTupleList(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterTupleList(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterTupleList		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterTupleList		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTupleList(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitTupleList(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitTupleList(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitTupleList(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitTupleList		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitTupleList		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitTupleList(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitTupleList(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitTupleList(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitTupleList		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitTupleList		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public TupleListContext tupleList() {
		TupleListContext _localctx = new TupleListContext(Context, State);
		EnterRule(_localctx, 56, RULE_tupleList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		TupleListContext _localctx = new TupleListContext(Context, State);
		EnterRule(_localctx, 56, RULE_tupleList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
TupleListContext _localctx = new TupleListContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
TupleListContext _localctx = new TupleListContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new TupleListContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new TupleListContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new TupleListContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 56, RULE_tupleList);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 56, RULE_tupleList)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 56, RULE_tupleList)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_tupleList		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_tupleList		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 253;
			Match(Comma);
			State = 254;
			blockExpr();
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 250;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 250		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
250		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)) {
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax
(((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
((_la) & ~0x3f) == 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
((_la) & ~0x3f)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(_la) & ~0x3f		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(_la)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
~0x3f		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
0x3f		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))) != 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
((1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier)))		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(1L << _la) & ((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << _la)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << _la		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier))		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(1L << Global) | (1L << Const) | (1L << Local) | (1L << Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << Global) | (1L << Const) | (1L << Local)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << Global) | (1L << Const)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(1L << Global)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Global		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Const)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Const		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Local)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Local		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1L << Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
1L << Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1L		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}
				State = 252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 245;
				blockExpr();
				State = 246;
				Match(Comma);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 245;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 245		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
245		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 246;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 246		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
246		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Comma);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 252;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 252		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
252		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
State = 253;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 253		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
253		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Comma);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Comma)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Comma		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 254;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 254		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
254		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
blockExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
blockExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extend() { return GetToken(JuliaParser.Extend, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Identifier, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extend() { return GetToken(JuliaParser.Extend, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Extend, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Extend, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Extend, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Extend, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Extend		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Extend		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Extend		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<TypeContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<TypeContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<TypeContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<TypeContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TypeContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_typeName; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_typeName; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_typeName; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_typeName; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_typeName;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_typeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterTypeName(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterTypeName(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterTypeName(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterTypeName		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterTypeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitTypeName(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitTypeName(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitTypeName(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitTypeName		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitTypeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitTypeName(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitTypeName(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitTypeName		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitTypeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 58, RULE_typeName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 58, RULE_typeName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
TypeNameContext _localctx = new TypeNameContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
TypeNameContext _localctx = new TypeNameContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new TypeNameContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new TypeNameContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new TypeNameContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 58, RULE_typeName);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 58, RULE_typeName)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 58, RULE_typeName)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_typeName		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_typeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 256;
			Match(Identifier);
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}

			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 256;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 256		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
256		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Identifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 259;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 259		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
259		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Extend) {
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Extend		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Extend		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 257;
				Match(Extend);
				State = 258;
				type();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 257;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 257		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
257		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Extend);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Extend)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Extend)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Extend		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Extend		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 258;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 258		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
258		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
type();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
type()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class ParameterizedTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RightBrace() { return GetTokens(JuliaParser.RightBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace(int i) {
			return GetToken(JuliaParser.RightBrace, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LeftBrace() { return GetTokens(JuliaParser.LeftBrace); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace(int i) {
			return GetToken(JuliaParser.LeftBrace, i);
		}
		public ParameterizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterizedType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Identifier, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RightBrace() { return GetTokens(JuliaParser.RightBrace); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetTokens(JuliaParser.RightBrace); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetTokens(JuliaParser.RightBrace);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetTokens(JuliaParser.RightBrace)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetTokens		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.RightBrace)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.RightBrace		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.RightBrace		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RightBrace		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace(int i) {
			return GetToken(JuliaParser.RightBrace, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetToken(JuliaParser.RightBrace, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.RightBrace, i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.RightBrace, i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.RightBrace, i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.RightBrace		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.RightBrace		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RightBrace		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeContext[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContexts<TypeContext>();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContexts<TypeContext>();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContexts<TypeContext>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContexts<TypeContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TypeContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetRuleContext<TypeContext>(i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<TypeContext>(i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<TypeContext>(i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<TypeContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TypeContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LeftBrace() { return GetTokens(JuliaParser.LeftBrace); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetTokens(JuliaParser.LeftBrace); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetTokens(JuliaParser.LeftBrace);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetTokens(JuliaParser.LeftBrace)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetTokens		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.LeftBrace)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.LeftBrace		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.LeftBrace		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LeftBrace		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace(int i) {
			return GetToken(JuliaParser.LeftBrace, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
			return GetToken(JuliaParser.LeftBrace, i);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.LeftBrace, i);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.LeftBrace, i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.LeftBrace, i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.LeftBrace		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.LeftBrace		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LeftBrace		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public ParameterizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_parameterizedType; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_parameterizedType; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_parameterizedType; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_parameterizedType; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_parameterizedType;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_parameterizedType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterParameterizedType(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterParameterizedType(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterParameterizedType(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterParameterizedType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterParameterizedType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitParameterizedType(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitParameterizedType(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitParameterizedType(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitParameterizedType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitParameterizedType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitParameterizedType(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitParameterizedType(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitParameterizedType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitParameterizedType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public ParameterizedTypeContext parameterizedType() {
		ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_parameterizedType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_parameterizedType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new ParameterizedTypeContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new ParameterizedTypeContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new ParameterizedTypeContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 60, RULE_parameterizedType);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 60, RULE_parameterizedType)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 60, RULE_parameterizedType)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_parameterizedType		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_parameterizedType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 261;
			Match(Identifier);
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 261;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 261		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
261		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Identifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 266;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 266		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
266		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
do {
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==RightBrace );		Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax
{
				{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 262;
				Match(RightBrace);
				State = 263;
				type();
				State = 264;
				Match(LeftBrace);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 262;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 262		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
262		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(RightBrace);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(RightBrace)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(RightBrace)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
RightBrace		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RightBrace		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 263;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 263		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
263		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
type();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
type()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
State = 264;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 264		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
264		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(LeftBrace);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(LeftBrace)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(LeftBrace)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
LeftBrace		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
LeftBrace		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 268;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 268		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
268		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_la==RightBrace		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RightBrace		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterizedTypeContext parameterizedType() {
			return GetRuleContext<ParameterizedTypeContext>(0);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Identifier, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Identifier, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Identifier, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ParameterizedTypeContext parameterizedType() {
			return GetRuleContext<ParameterizedTypeContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
			return GetRuleContext<ParameterizedTypeContext>(0);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetRuleContext<ParameterizedTypeContext>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetRuleContext<ParameterizedTypeContext>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetRuleContext<ParameterizedTypeContext>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<ParameterizedTypeContext>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_type; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_type; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_type; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_type; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_type;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterType(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterType(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterType(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterType(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitType(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitType(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitType(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitType(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitType(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitType(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_type);
		try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_type);
		try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
TypeContext _localctx = new TypeContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
TypeContext _localctx = new TypeContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new TypeContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new TypeContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new TypeContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 62, RULE_type);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 62, RULE_type)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 62, RULE_type)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_type		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
try {
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			State = 272;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 272;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 272		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
272		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;
			}		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax
Interpreter.AdaptivePredict(TokenStream,30,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Interpreter.AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Interpreter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AdaptivePredict		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(TokenStream,30,Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(Identifier);
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 1:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 270;
				Match(Identifier);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 270;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 270		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
270		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Identifier);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Identifier)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 271;
				parameterizedType();
				}
				break;		Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax
case 2:		Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
EnterOuterAlt(_localctx, 2);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 2)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
				State = 271;
				parameterizedType();
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 271;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 271		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
271		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
parameterizedType();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
parameterizedType()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
parameterizedType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
break;		Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public partial class EndExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(JuliaParser.End, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }
		public EndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}
	}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(JuliaParser.End, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.End, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.End, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.End, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.End, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.End		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.End		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
End		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Termination() { return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{ return GetToken(JuliaParser.Termination, 0); }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return GetToken(JuliaParser.Termination, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetToken(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.Termination, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JuliaParser.Termination		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public EndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ParserRuleContext parent, int invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ParserRuleContext parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: base(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent, invokingState)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
invokingState		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public override int RuleIndex { get { return RULE_endExpr; } }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get { return RULE_endExpr; } }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get { return RULE_endExpr; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
{ return RULE_endExpr; }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return RULE_endExpr;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
RULE_endExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.EnterEndExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.EnterEndExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.EnterEndExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.EnterEndExpr(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.EnterEndExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterEndExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTreeListener listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeListener listener		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaListener typedListener = listener as IJuliaListener;
			if (typedListener != null) typedListener.ExitEndExpr(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaListener typedListener = listener as IJuliaListener;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaListener typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedListener = listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
listener as IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedListener != null) typedListener.ExitEndExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedListener != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typedListener.ExitEndExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typedListener.ExitEndExpr(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedListener.ExitEndExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExitEndExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[System.Diagnostics.DebuggerNonUserCode]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Diagnostics.DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Diagnostics		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DebuggerNonUserCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(IParseTreeVisitor<TResult> visitor)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTreeVisitor<TResult> visitor		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTreeVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJuliaVisitor<TResult> typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typedVisitor = visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
visitor as IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJuliaVisitor<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<TResult>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
TResult		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (typedVisitor != null) return typedVisitor.VisitEndExpr(this);
			else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
typedVisitor != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return typedVisitor.VisitEndExpr(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
typedVisitor.VisitEndExpr(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
typedVisitor.VisitEndExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typedVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitEndExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
else return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
return visitor.VisitChildren(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
visitor.VisitChildren(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
visitor.VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
visitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitChildren		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
[RuleVersion(0)]
	public EndExprContext endExpr() {
		EndExprContext _localctx = new EndExprContext(Context, State);
		EnterRule(_localctx, 64, RULE_endExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[RuleVersion(0)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
RuleVersion(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
RuleVersion		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
		EndExprContext _localctx = new EndExprContext(Context, State);
		EnterRule(_localctx, 64, RULE_endExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EndExprContext _localctx = new EndExprContext(Context, State);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
EndExprContext _localctx = new EndExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_localctx = new EndExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new EndExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new EndExprContext(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Context, State)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnterRule(_localctx, 64, RULE_endExpr);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterRule(_localctx, 64, RULE_endExpr)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 64, RULE_endExpr)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
RULE_endExpr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
RULE_endExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int _la;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int _la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax
{
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
EnterOuterAlt(_localctx, 1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
EnterOuterAlt(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnterOuterAlt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_localctx, 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
			State = 275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}

			State = 277;
			Match(End);
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 275;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 275		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
275		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ErrorHandler.Sync(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Sync(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Sync		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sync		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
_la = TokenStream.LA(1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_la = TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TokenStream.LA(1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
TokenStream.LA		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
TokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LA		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_la==Termination) {
				{
				State = 274;
				Match(Termination);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_la==Termination		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_la		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
				{
				State = 274;
				Match(Termination);
				}
			}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
{
				State = 274;
				Match(Termination);
				}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
State = 274;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 274		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
274		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(Termination);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Termination)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Termination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
State = 277;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
State = 277		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
State		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
277		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Match(End);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Match(End)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Match		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(End)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
End		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
End		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax
(RecognitionException re)		Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_localctx.exception = re;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_localctx.exception = re		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_localctx.exception		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.ReportError(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.ReportError(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ReportError		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ErrorHandler.Recover(this, re);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ErrorHandler.Recover(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ErrorHandler.Recover		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ErrorHandler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Recover		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, re)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
re		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
finally {
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax
{
			ExitRule();
		}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExitRule();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExitRule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ExitRule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return _localctx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_localctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private static int[] _serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	};		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int[] _serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
_serializedATN = {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	}		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= {
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	}		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
{
		4,1,67,280,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,4,0,70,8,0,11,0,12,
		0,71,3,0,74,8,0,1,0,1,0,3,0,78,8,0,1,1,3,1,81,8,1,1,1,1,1,1,1,1,1,1,1,
		3,1,88,8,1,1,2,3,2,91,8,2,1,2,3,2,94,8,2,1,2,1,2,3,2,98,8,2,1,3,1,3,1,
		3,5,3,103,8,3,10,3,12,3,106,9,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,
		6,5,6,118,8,6,10,6,12,6,121,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,3,8,131,
		8,8,1,9,1,9,1,10,3,10,136,8,10,1,10,1,10,1,11,1,11,3,11,142,8,11,1,11,
		1,11,5,11,146,8,11,10,11,12,11,149,9,11,1,11,1,11,1,12,3,12,154,8,12,1,
		12,1,12,1,13,3,13,159,8,13,1,13,1,13,3,13,163,8,13,1,13,1,13,1,14,1,14,
		3,14,169,8,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,3,17,180,8,
		17,1,18,3,18,183,8,18,1,18,3,18,186,8,18,1,18,1,18,3,18,190,8,18,1,19,
		1,19,3,19,194,8,19,1,20,1,20,3,20,198,8,20,1,20,1,20,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,216,8,24,10,
		24,12,24,219,9,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,5,
		26,231,8,26,10,26,12,26,234,9,26,1,26,3,26,237,8,26,1,26,1,26,1,27,1,27,
		1,27,1,27,1,27,1,28,1,28,1,28,5,28,249,8,28,10,28,12,28,252,9,28,1,28,
		1,28,1,28,1,29,1,29,1,29,3,29,260,8,29,1,30,1,30,1,30,1,30,1,30,4,30,267,
		8,30,11,30,12,30,268,1,31,1,31,3,31,273,8,31,1,32,3,32,276,8,32,1,32,1,
		32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,2,0,5,5,7,7,281,0,77,1,0,0,
		0,2,80,1,0,0,0,4,90,1,0,0,0,6,99,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,
		12,119,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,132,1,0,0,0,20,135,1,0,
		0,0,22,141,1,0,0,0,24,153,1,0,0,0,26,158,1,0,0,0,28,168,1,0,0,0,30,170,
		1,0,0,0,32,173,1,0,0,0,34,176,1,0,0,0,36,182,1,0,0,0,38,193,1,0,0,0,40,
		197,1,0,0,0,42,201,1,0,0,0,44,204,1,0,0,0,46,207,1,0,0,0,48,211,1,0,0,
		0,50,222,1,0,0,0,52,226,1,0,0,0,54,240,1,0,0,0,56,250,1,0,0,0,58,256,1,
		0,0,0,60,261,1,0,0,0,62,272,1,0,0,0,64,275,1,0,0,0,66,78,5,0,0,1,67,74,
		3,2,1,0,68,70,3,8,4,0,69,68,1,0,0,0,70,71,1,0,0,0,71,69,1,0,0,0,71,72,
		1,0,0,0,72,74,1,0,0,0,73,67,1,0,0,0,73,69,1,0,0,0,74,75,1,0,0,0,75,76,
		5,0,0,1,76,78,1,0,0,0,77,66,1,0,0,0,77,73,1,0,0,0,78,1,1,0,0,0,79,81,5,
		57,0,0,80,79,1,0,0,0,80,81,1,0,0,0,81,87,1,0,0,0,82,88,3,22,11,0,83,88,
		3,4,2,0,84,88,3,6,3,0,85,88,3,10,5,0,86,88,3,28,14,0,87,82,1,0,0,0,87,
		83,1,0,0,0,87,84,1,0,0,0,87,85,1,0,0,0,87,86,1,0,0,0,88,3,1,0,0,0,89,91,
		5,6,0,0,90,89,1,0,0,0,90,91,1,0,0,0,91,93,1,0,0,0,92,94,5,7,0,0,93,92,
		1,0,0,0,93,94,1,0,0,0,94,95,1,0,0,0,95,97,3,34,17,0,96,98,3,32,16,0,97,
		96,1,0,0,0,97,98,1,0,0,0,98,5,1,0,0,0,99,100,5,10,0,0,100,104,5,61,0,0,
		101,103,3,2,1,0,102,101,1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,
		1,0,0,0,105,107,1,0,0,0,106,104,1,0,0,0,107,108,3,64,32,0,108,7,1,0,0,
		0,109,110,3,2,1,0,110,111,5,57,0,0,111,9,1,0,0,0,112,113,5,3,0,0,113,114,
		3,12,6,0,114,11,1,0,0,0,115,116,5,61,0,0,116,118,5,55,0,0,117,115,1,0,
		0,0,118,121,1,0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,122,1,0,0,0,121,
		119,1,0,0,0,122,123,5,61,0,0,123,13,1,0,0,0,124,125,3,12,6,0,125,126,5,
		55,0,0,126,127,5,61,0,0,127,15,1,0,0,0,128,131,3,14,7,0,129,131,5,61,0,
		0,130,128,1,0,0,0,130,129,1,0,0,0,131,17,1,0,0,0,132,133,5,2,0,0,133,19,
		1,0,0,0,134,136,5,8,0,0,135,134,1,0,0,0,135,136,1,0,0,0,136,137,1,0,0,
		0,137,138,5,11,0,0,138,21,1,0,0,0,139,142,3,18,9,0,140,142,3,20,10,0,141,
		139,1,0,0,0,141,140,1,0,0,0,142,143,1,0,0,0,143,147,3,58,29,0,144,146,
		3,26,13,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,
		0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,3,64,32,0,151,23,1,0,0,0,152,
		154,5,6,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,155,1,0,0,0,155,156,3,
		34,17,0,156,25,1,0,0,0,157,159,5,57,0,0,158,157,1,0,0,0,158,159,1,0,0,
		0,159,162,1,0,0,0,160,163,3,38,19,0,161,163,3,24,12,0,162,160,1,0,0,0,
		162,161,1,0,0,0,163,164,1,0,0,0,164,165,5,57,0,0,165,27,1,0,0,0,166,169,
		3,44,22,0,167,169,3,36,18,0,168,166,1,0,0,0,168,167,1,0,0,0,169,29,1,0,
		0,0,170,171,3,28,14,0,171,172,5,57,0,0,172,31,1,0,0,0,173,174,5,59,0,0,
		174,175,3,28,14,0,175,33,1,0,0,0,176,179,5,61,0,0,177,178,5,50,0,0,178,
		180,3,62,31,0,179,177,1,0,0,0,179,180,1,0,0,0,180,35,1,0,0,0,181,183,5,
		6,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,185,1,0,0,0,184,186,7,0,0,0,
		185,184,1,0,0,0,185,186,1,0,0,0,186,187,1,0,0,0,187,189,3,34,17,0,188,
		190,3,32,16,0,189,188,1,0,0,0,189,190,1,0,0,0,190,37,1,0,0,0,191,194,3,
		46,23,0,192,194,3,48,24,0,193,191,1,0,0,0,193,192,1,0,0,0,194,39,1,0,0,
		0,195,198,3,12,6,0,196,198,5,61,0,0,197,195,1,0,0,0,197,196,1,0,0,0,198,
		199,1,0,0,0,199,200,3,52,26,0,200,41,1,0,0,0,201,202,3,30,15,0,202,203,
		5,57,0,0,203,43,1,0,0,0,204,205,3,16,8,0,205,206,3,50,25,0,206,45,1,0,
		0,0,207,208,3,40,20,0,208,209,5,53,0,0,209,210,3,42,21,0,210,47,1,0,0,
		0,211,212,5,9,0,0,212,213,3,40,20,0,213,217,5,57,0,0,214,216,3,42,21,0,
		215,214,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,
		1,0,0,0,219,217,1,0,0,0,220,221,3,64,32,0,221,49,1,0,0,0,222,223,5,22,
		0,0,223,224,3,56,28,0,224,225,5,21,0,0,225,51,1,0,0,0,226,236,5,22,0,0,
		227,228,3,34,17,0,228,229,5,52,0,0,229,231,1,0,0,0,230,227,1,0,0,0,231,
		234,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,235,1,0,0,0,234,232,1,
		0,0,0,235,237,3,34,17,0,236,232,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,
		0,238,239,5,21,0,0,239,53,1,0,0,0,240,241,5,22,0,0,241,242,3,56,28,0,242,
		243,5,52,0,0,243,244,5,21,0,0,244,55,1,0,0,0,245,246,3,28,14,0,246,247,
		5,52,0,0,247,249,1,0,0,0,248,245,1,0,0,0,249,252,1,0,0,0,250,248,1,0,0,
		0,250,251,1,0,0,0,251,253,1,0,0,0,252,250,1,0,0,0,253,254,5,52,0,0,254,
		255,3,28,14,0,255,57,1,0,0,0,256,259,5,61,0,0,257,258,5,4,0,0,258,260,
		3,62,31,0,259,257,1,0,0,0,259,260,1,0,0,0,260,59,1,0,0,0,261,266,5,61,
		0,0,262,263,5,26,0,0,263,264,3,62,31,0,264,265,5,25,0,0,265,267,1,0,0,
		0,266,262,1,0,0,0,267,268,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,
		61,1,0,0,0,270,273,5,61,0,0,271,273,3,60,30,0,272,270,1,0,0,0,272,271,
		1,0,0,0,273,63,1,0,0,0,274,276,5,57,0,0,275,274,1,0,0,0,275,276,1,0,0,
		0,276,277,1,0,0,0,277,278,5,20,0,0,278,65,1,0,0,0,32,71,73,77,80,87,90,
		93,97,104,119,130,135,141,147,153,158,162,168,179,182,185,189,193,197,
		217,232,236,250,259,268,272,275
	}		Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
280		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
70		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
71		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
74		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
78		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
81		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
88		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
91		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
94		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
98		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
103		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
106		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
118		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
121		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
131		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
136		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
142		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
146		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
149		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
154		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
159		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
163		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
169		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
180		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
183		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
186		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
190		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
194		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
198		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
216		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
219		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
231		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
234		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
237		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
249		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
252		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
260		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
267		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
268		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
273		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
276		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
281		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
77		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
80		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
90		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
109		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
112		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
119		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
124		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
130		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
132		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
135		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
141		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
153		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
158		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
168		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
170		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
173		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
176		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
182		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
193		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
197		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
201		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
204		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
207		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
211		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
222		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
226		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
54		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
240		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
250		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
256		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
261		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
272		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
275		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
78		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
74		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
70		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
68		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
70		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
71		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
71		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
71		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
72		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
72		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
74		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
73		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
67		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
73		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
69		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
74		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
75		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
75		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
76		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
76		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
78		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
77		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
66		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
77		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
73		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
78		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
79		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
81		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
80		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
79		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
80		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
81		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
81		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
87		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
82		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
88		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
83		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
88		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
84		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
88		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
85		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
88		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
86		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
88		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
87		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
82		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
87		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
83		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
87		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
84		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
87		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
85		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
87		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
86		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
88		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
89		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
91		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
90		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
89		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
90		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
91		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
91		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
93		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
92		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
94		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
93		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
92		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
93		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
94		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
94		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
95		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
95		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
96		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
98		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
96		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
98		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
98		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
99		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
100		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
100		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
104		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
103		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
102		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
101		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
103		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
106		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
104		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
102		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
104		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
105		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
105		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
107		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
106		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
104		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
107		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
108		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
108		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
109		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
110		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
111		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
112		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
113		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
113		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
114		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
114		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
116		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
118		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
115		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
118		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
121		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
119		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
117		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
119		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
120		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
120		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
122		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
121		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
119		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
122		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
123		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
123		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
124		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
125		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
125		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
126		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
126		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
127		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
127		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
128		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
131		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
129		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
131		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
130		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
128		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
130		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
129		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
131		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
132		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
133		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
133		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
134		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
136		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
135		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
134		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
135		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
136		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
136		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
137		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
137		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
138		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
11		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
138		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
139		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
142		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
140		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
142		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
10		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
141		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
139		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
141		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
140		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
142		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
143		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
143		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
147		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
58		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
144		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
146		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
13		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
145		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
144		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
146		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
149		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
147		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
145		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
147		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
148		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
148		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
150		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
149		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
147		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
150		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
151		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
151		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
152		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
154		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
153		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
152		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
153		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
154		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
154		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
155		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
155		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
156		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
156		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
157		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
159		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
158		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
157		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
158		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
159		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
159		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
162		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
160		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
163		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
38		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
19		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
161		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
163		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
162		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
160		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
162		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
161		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
163		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
164		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
164		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
165		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
165		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
27		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
166		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
169		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
44		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
167		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
169		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
36		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
18		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
168		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
166		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
168		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
167		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
169		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
29		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
170		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
171		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
171		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
172		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
172		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
173		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
174		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
174		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
175		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
175		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
33		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
176		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
179		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
177		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
178		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
178		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
180		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
179		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
177		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
179		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
180		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
180		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
35		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
181		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
183		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
182		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
181		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
182		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
183		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
183		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
185		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
184		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
186		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
7		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
185		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
184		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
185		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
186		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
186		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
187		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
187		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
189		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
188		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
190		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
189		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
188		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
189		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
190		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
190		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
37		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
191		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
194		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
46		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
23		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
192		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
194		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
48		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
24		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
193		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
191		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
193		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
192		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
194		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
39		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
195		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
198		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
12		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
6		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
196		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
198		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
197		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
195		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
197		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
196		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
198		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
199		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
199		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
200		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
200		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
41		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
201		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
202		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
15		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
202		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
203		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
203		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
43		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
204		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
205		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
16		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
8		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
205		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
206		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
50		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
206		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
45		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
207		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
208		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
208		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
209		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
209		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
210		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
210		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
47		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
211		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
212		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
9		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
212		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
213		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
40		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
213		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
217		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
214		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
216		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
42		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
215		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
214		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
216		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
219		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
217		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
215		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
217		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
218		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
218		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
220		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
219		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
217		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
220		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
221		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
64		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
221		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
49		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
222		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
223		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
223		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
224		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
224		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
225		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
225		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
51		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
226		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
236		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
227		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
228		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
228		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
229		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
229		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
231		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
230		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
227		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
231		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
234		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
232		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
230		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
232		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
233		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
233		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
235		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
234		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
232		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
235		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
237		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
34		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
17		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
236		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
232		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
236		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
237		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
237		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
238		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
238		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
239		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
239		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
53		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
240		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
241		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
22		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
241		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
242		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
56		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
242		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
243		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
243		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
244		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
21		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
244		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
55		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
245		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
246		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
246		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
247		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
247		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
249		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
248		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
245		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
249		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
252		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
250		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
248		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
250		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
251		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
251		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
253		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
252		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
250		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
253		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
254		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
52		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
254		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
255		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
28		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
14		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
255		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
256		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
259		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
257		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
258		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
258		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
260		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
259		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
257		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
259		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
260		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
260		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
59		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
261		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
266		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
262		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
263		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
26		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
263		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
264		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
62		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
31		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
264		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
265		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
25		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
265		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
267		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
266		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
262		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
267		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
268		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
268		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
266		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
268		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
269		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
269		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
270		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
273		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
61		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
271		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
273		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
60		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
30		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
272		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
270		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
272		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
271		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
273		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
63		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
274		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
276		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
57		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
275		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
274		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
275		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
276		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
276		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
277		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
277		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
278		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
20		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
278		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
65		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
32		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
71		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
73		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
77		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
80		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
87		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
90		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
93		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
97		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
104		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
119		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
130		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
135		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
141		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
147		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
153		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
158		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
162		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
168		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
179		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
182		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
185		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
189		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
193		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
197		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
217		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
232		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
236		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
250		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
259		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
268		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
272		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
275		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_ATN =
		new ATNDeserializer().Deserialize(_serializedATN)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
=
		new ATNDeserializer().Deserialize(_serializedATN)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new ATNDeserializer().Deserialize(_serializedATN)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
new ATNDeserializer().Deserialize		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
new ATNDeserializer()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
ATNDeserializer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Deserialize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_serializedATN)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_serializedATN		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_serializedATN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace HyperSphere {
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using IToken = Antlr4.Runtime.IToken;

/// <summary>
/// This interface defines a complete generic visitor for a parse tree produced
/// by <see cref="JuliaParser"/>.
/// </summary>
/// <typeparam name="Result">The return type of the visit operation.</typeparam>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaVisitor<Result> : IParseTreeVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context);
}
} // namespace HyperSphere
		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
namespace HyperSphere {
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using IToken = Antlr4.Runtime.IToken;

/// <summary>
/// This interface defines a complete generic visitor for a parse tree produced
/// by <see cref="JuliaParser"/>.
/// </summary>
/// <typeparam name="Result">The return type of the visit operation.</typeparam>
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaVisitor<Result> : IParseTreeVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context);
}
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
HyperSphere		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Misc;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Misc		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Misc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Tree;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Tree		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Tree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using IToken = Antlr4.Runtime.IToken;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
IToken =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
IToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Antlr4.Runtime.IToken		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public interface IJuliaVisitor<Result> : IParseTreeVisitor<Result> {
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.script"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitScript([NotNull] JuliaParser.ScriptContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.module"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModule([NotNull] JuliaParser.ModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.usingModule"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleRef"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.moduleIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.symbolIdentifier"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.abstractStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.compositeStructure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structure"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructure([NotNull] JuliaParser.StructureContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structField"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructField([NotNull] JuliaParser.StructFieldContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.structItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitStructItem([NotNull] JuliaParser.StructItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockExprStatement"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableInstatiation"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockArg"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.blockVariableDeclaration"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.function"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunction([NotNull] JuliaParser.FunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionHeader"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionItem"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.functionCall"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.shortFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.longFunction"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTuple([NotNull] JuliaParser.TupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.namedTuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typetuple"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.tupleList"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTupleList([NotNull] JuliaParser.TupleListContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.typeName"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.parameterizedType"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.type"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitType([NotNull] JuliaParser.TypeContext context);
	/// <summary>
	/// Visit a parse tree produced by <see cref="JuliaParser.endExpr"/>.
	/// </summary>
	/// <param name="context">The parse tree.</param>
	/// <return>The visitor result.</return>
	Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context);
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CodeDom.Compiler.GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom.Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CodeDom		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Compiler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GeneratedCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("ANTLR", "4.10.1")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"ANTLR"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"4.10.1"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[System.CLSCompliant(false)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
System.CLSCompliant(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CLSCompliant		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(false)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
: IParseTreeVisitor<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IParseTreeVisitor<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IParseTreeVisitor<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<Result>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitScript([NotNull] JuliaParser.ScriptContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ScriptContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ScriptContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitModuleExpr([NotNull] JuliaParser.ModuleExprContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitModuleVariableDeclaration([NotNull] JuliaParser.ModuleVariableDeclarationContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitModule([NotNull] JuliaParser.ModuleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitModuleExprStatement([NotNull] JuliaParser.ModuleExprStatementContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitUsingModule([NotNull] JuliaParser.UsingModuleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.UsingModuleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.UsingModuleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitModuleRef([NotNull] JuliaParser.ModuleRefContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleRefContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleRefContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleRefContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitModuleIdentifier([NotNull] JuliaParser.ModuleIdentifierContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ModuleIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ModuleIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitSymbolIdentifier([NotNull] JuliaParser.SymbolIdentifierContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.SymbolIdentifierContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.SymbolIdentifierContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
SymbolIdentifierContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitAbstractStructure([NotNull] JuliaParser.AbstractStructureContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.AbstractStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.AbstractStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AbstractStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitCompositeStructure([NotNull] JuliaParser.CompositeStructureContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.CompositeStructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.CompositeStructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompositeStructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitStructure([NotNull] JuliaParser.StructureContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.StructureContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructureContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitStructField([NotNull] JuliaParser.StructFieldContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.StructFieldContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructFieldContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructFieldContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitStructItem([NotNull] JuliaParser.StructItemContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.StructItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.StructItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitBlockExpr([NotNull] JuliaParser.BlockExprContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.BlockExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitBlockExprStatement([NotNull] JuliaParser.BlockExprStatementContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.BlockExprStatementContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockExprStatementContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprStatementContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitBlockVariableInstatiation([NotNull] JuliaParser.BlockVariableInstatiationContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.BlockVariableInstatiationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableInstatiationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableInstatiationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitBlockArg([NotNull] JuliaParser.BlockArgContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.BlockArgContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockArgContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockArgContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitBlockVariableDeclaration([NotNull] JuliaParser.BlockVariableDeclarationContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.BlockVariableDeclarationContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.BlockVariableDeclarationContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockVariableDeclarationContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitFunction([NotNull] JuliaParser.FunctionContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.FunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitFunctionHeader([NotNull] JuliaParser.FunctionHeaderContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.FunctionHeaderContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionHeaderContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionHeaderContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitFunctionItem([NotNull] JuliaParser.FunctionItemContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.FunctionItemContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionItemContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionItemContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitFunctionCall([NotNull] JuliaParser.FunctionCallContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.FunctionCallContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.FunctionCallContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitShortFunction([NotNull] JuliaParser.ShortFunctionContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ShortFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ShortFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ShortFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitLongFunction([NotNull] JuliaParser.LongFunctionContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.LongFunctionContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.LongFunctionContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LongFunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitTuple([NotNull] JuliaParser.TupleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.TupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitNamedTuple([NotNull] JuliaParser.NamedTupleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.NamedTupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.NamedTupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NamedTupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitTypetuple([NotNull] JuliaParser.TypetupleContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.TypetupleContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypetupleContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypetupleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitTupleList([NotNull] JuliaParser.TupleListContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.TupleListContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TupleListContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TupleListContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitTypeName([NotNull] JuliaParser.TypeNameContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.TypeNameContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeNameContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitParameterizedType([NotNull] JuliaParser.ParameterizedTypeContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.ParameterizedTypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.ParameterizedTypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParameterizedTypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitType([NotNull] JuliaParser.TypeContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.TypeContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.TypeContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Result VisitEndExpr([NotNull] JuliaParser.EndExprContext context);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
Result		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
([NotNull] JuliaParser.EndExprContext context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
[NotNull] JuliaParser.EndExprContext context		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
[NotNull]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
NotNull		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EndExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using System.IO;
using System.Text;
using Antlr4.Runtime;
using Antlr4.Runtime.Tree;
using HyperSphere;
using runtime.core;

namespace runtime.parse
{
    public class JuliaParserErrorListener<Symbol> : IAntlrErrorListener<Symbol>
    {
        private bool EncounteredError;
        private int err_count = 0;

        public void SyntaxError(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine,
            string msg, RecognitionException e) {
            if (err_count++ == 3) 
                Finish();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);
            Console.ResetColor();
        }

        public void Finish() {
            if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");
        }
    }

    public class JuliappParser
    {
        private readonly BaseInputCharStream _stream;
        private readonly JuliaLexer _lexer;
        private readonly JuliaParser _parser;
        private readonly CommonTokenStream _token_stream;
        public readonly JuliaParser.ScriptContext script;

        public JuliappParser(string s) : this(new AntlrInputStream(s)){}
        public JuliappParser(FileInfo file) : this(new AntlrFileStream(file.Name)){}

        public JuliappParser(BaseInputCharStream stream) {
            _stream = stream;
            _lexer = new JuliaLexer(stream);
            _token_stream = new CommonTokenStream(_lexer);
            _parser = new JuliaParser(_token_stream);
            var listener = new JuliaParserErrorListener<IToken>();
            _parser.RemoveErrorListeners();
            _parser.AddErrorListener(listener);
            script = _parser.script();
            listener.Finish();
        }

        public override string ToString() => PrintSyntaxTree(_parser, script);
        
        public static string PrintSyntaxTree(Parser parser, IParseTree root) {
            StringBuilder buf = new StringBuilder();
            Recursive(root, buf, 0,  parser.RuleNames);
            return buf.ToString();
        }

        private static void Recursive(IParseTree aRoot, StringBuilder buf, int offset, string[] ruleNames) {
            for (int i = 0; i < offset; i++) buf.Append("  ");
            buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");
            if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
        }
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.IO;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.IO		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IO		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Text;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Text		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Text		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Tree;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Tree		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Tree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using HyperSphere;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
HyperSphere		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.parse
{
    public class JuliaParserErrorListener<Symbol> : IAntlrErrorListener<Symbol>
    {
        private bool EncounteredError;
        private int err_count = 0;

        public void SyntaxError(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine,
            string msg, RecognitionException e) {
            if (err_count++ == 3) 
                Finish();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);
            Console.ResetColor();
        }

        public void Finish() {
            if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");
        }
    }

    public class JuliappParser
    {
        private readonly BaseInputCharStream _stream;
        private readonly JuliaLexer _lexer;
        private readonly JuliaParser _parser;
        private readonly CommonTokenStream _token_stream;
        public readonly JuliaParser.ScriptContext script;

        public JuliappParser(string s) : this(new AntlrInputStream(s)){}
        public JuliappParser(FileInfo file) : this(new AntlrFileStream(file.Name)){}

        public JuliappParser(BaseInputCharStream stream) {
            _stream = stream;
            _lexer = new JuliaLexer(stream);
            _token_stream = new CommonTokenStream(_lexer);
            _parser = new JuliaParser(_token_stream);
            var listener = new JuliaParserErrorListener<IToken>();
            _parser.RemoveErrorListeners();
            _parser.AddErrorListener(listener);
            script = _parser.script();
            listener.Finish();
        }

        public override string ToString() => PrintSyntaxTree(_parser, script);
        
        public static string PrintSyntaxTree(Parser parser, IParseTree root) {
            StringBuilder buf = new StringBuilder();
            Recursive(root, buf, 0,  parser.RuleNames);
            return buf.ToString();
        }

        private static void Recursive(IParseTree aRoot, StringBuilder buf, int offset, string[] ruleNames) {
            for (int i = 0; i < offset; i++) buf.Append("  ");
            buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");
            if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
        }
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.parse		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parse		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JuliaParserErrorListener<Symbol> : IAntlrErrorListener<Symbol>
    {
        private bool EncounteredError;
        private int err_count = 0;

        public void SyntaxError(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine,
            string msg, RecognitionException e) {
            if (err_count++ == 3) 
                Finish();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);
            Console.ResetColor();
        }

        public void Finish() {
            if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");
        }
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
<Symbol>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
Symbol		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
: IAntlrErrorListener<Symbol>		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IAntlrErrorListener<Symbol>		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IAntlrErrorListener<Symbol>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<Symbol>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
Symbol		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private bool EncounteredError;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
bool EncounteredError		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
EncounteredError		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private int err_count = 0;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int err_count = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
err_count = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public void SyntaxError(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine,
            string msg, RecognitionException e) {
            if (err_count++ == 3) 
                Finish();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);
            Console.ResetColor();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine,
            string msg, RecognitionException e)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
TextWriter output		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IRecognizer recognizer		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IRecognizer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Symbol offendingSymbol		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Symbol		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int line		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
int charPositionInLine		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
string msg		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
RecognitionException e		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
RecognitionException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            if (err_count++ == 3) 
                Finish();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);
            Console.ResetColor();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (err_count++ == 3) 
                Finish();		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
err_count++ == 3		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
err_count++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
err_count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
3		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Finish();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Finish()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Finish		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Console.ForegroundColor = ConsoleColor.Red;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Console.ForegroundColor = ConsoleColor.Red		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Console.ForegroundColor		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ForegroundColor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ConsoleColor.Red		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ConsoleColor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Red		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Console.Error.WriteLine("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Console.Error.WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console.Error		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Error		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t" + msg		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Parsing Error @ Line:" + line + ":" + charPositionInLine + "\t"		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Parsing Error @ Line:" + line + ":" + charPositionInLine		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Parsing Error @ Line:" + line + ":"		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Parsing Error @ Line:" + line		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Parsing Error @ Line:"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
line		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
":"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
charPositionInLine		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
"\t"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
msg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.ResetColor();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Console.ResetColor()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Console.ResetColor		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ResetColor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public void Finish() {
            if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
            if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (err_count > 0) 
                throw new JuliaException("Encountered " + err_count + " Parser Failures!");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
err_count > 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
err_count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
throw new JuliaException("Encountered " + err_count + " Parser Failures!");		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new JuliaException("Encountered " + err_count + " Parser Failures!")		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Encountered " + err_count + " Parser Failures!")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Encountered " + err_count + " Parser Failures!"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Encountered " + err_count + " Parser Failures!"		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Encountered " + err_count		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Encountered "		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
err_count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
" Parser Failures!"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public class JuliappParser
    {
        private readonly BaseInputCharStream _stream;
        private readonly JuliaLexer _lexer;
        private readonly JuliaParser _parser;
        private readonly CommonTokenStream _token_stream;
        public readonly JuliaParser.ScriptContext script;

        public JuliappParser(string s) : this(new AntlrInputStream(s)){}
        public JuliappParser(FileInfo file) : this(new AntlrFileStream(file.Name)){}

        public JuliappParser(BaseInputCharStream stream) {
            _stream = stream;
            _lexer = new JuliaLexer(stream);
            _token_stream = new CommonTokenStream(_lexer);
            _parser = new JuliaParser(_token_stream);
            var listener = new JuliaParserErrorListener<IToken>();
            _parser.RemoveErrorListeners();
            _parser.AddErrorListener(listener);
            script = _parser.script();
            listener.Finish();
        }

        public override string ToString() => PrintSyntaxTree(_parser, script);
        
        public static string PrintSyntaxTree(Parser parser, IParseTree root) {
            StringBuilder buf = new StringBuilder();
            Recursive(root, buf, 0,  parser.RuleNames);
            return buf.ToString();
        }

        private static void Recursive(IParseTree aRoot, StringBuilder buf, int offset, string[] ruleNames) {
            for (int i = 0; i < offset; i++) buf.Append("  ");
            buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");
            if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
        }
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
private readonly BaseInputCharStream _stream;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
BaseInputCharStream _stream		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
BaseInputCharStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_stream		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private readonly JuliaLexer _lexer;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JuliaLexer _lexer		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JuliaLexer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_lexer		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private readonly JuliaParser _parser;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JuliaParser _parser		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_parser		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private readonly CommonTokenStream _token_stream;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
CommonTokenStream _token_stream		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
CommonTokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_token_stream		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly JuliaParser.ScriptContext script;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JuliaParser.ScriptContext script		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JuliaParser.ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
script		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public JuliappParser(string s) : this(new AntlrInputStream(s)){}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(string s)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string s		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
: this(new AntlrInputStream(s))		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(new AntlrInputStream(s))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
new AntlrInputStream(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
new AntlrInputStream(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
AntlrInputStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public JuliappParser(FileInfo file) : this(new AntlrFileStream(file.Name)){}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(FileInfo file)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
FileInfo file		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
FileInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: this(new AntlrFileStream(file.Name))		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(new AntlrFileStream(file.Name))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
new AntlrFileStream(file.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
new AntlrFileStream(file.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
AntlrFileStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(file.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
file.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
file.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
file		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public JuliappParser(BaseInputCharStream stream) {
            _stream = stream;
            _lexer = new JuliaLexer(stream);
            _token_stream = new CommonTokenStream(_lexer);
            _parser = new JuliaParser(_token_stream);
            var listener = new JuliaParserErrorListener<IToken>();
            _parser.RemoveErrorListeners();
            _parser.AddErrorListener(listener);
            script = _parser.script();
            listener.Finish();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(BaseInputCharStream stream)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
BaseInputCharStream stream		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
BaseInputCharStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            _stream = stream;
            _lexer = new JuliaLexer(stream);
            _token_stream = new CommonTokenStream(_lexer);
            _parser = new JuliaParser(_token_stream);
            var listener = new JuliaParserErrorListener<IToken>();
            _parser.RemoveErrorListeners();
            _parser.AddErrorListener(listener);
            script = _parser.script();
            listener.Finish();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_stream = stream;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_stream = stream		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_stream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
stream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_lexer = new JuliaLexer(stream);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_lexer = new JuliaLexer(stream)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_lexer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new JuliaLexer(stream)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaLexer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(stream)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
stream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
stream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_token_stream = new CommonTokenStream(_lexer);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_token_stream = new CommonTokenStream(_lexer)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_token_stream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new CommonTokenStream(_lexer)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
CommonTokenStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_lexer)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_lexer		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_lexer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_parser = new JuliaParser(_token_stream);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_parser = new JuliaParser(_token_stream)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_parser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new JuliaParser(_token_stream)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_token_stream)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_token_stream		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_token_stream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var listener = new JuliaParserErrorListener<IToken>();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var listener = new JuliaParserErrorListener<IToken>()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
listener = new JuliaParserErrorListener<IToken>()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new JuliaParserErrorListener<IToken>()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new JuliaParserErrorListener<IToken>()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaParserErrorListener<IToken>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IToken>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IToken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_parser.RemoveErrorListeners();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_parser.RemoveErrorListeners()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_parser.RemoveErrorListeners		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_parser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RemoveErrorListeners		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_parser.AddErrorListener(listener);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_parser.AddErrorListener(listener)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_parser.AddErrorListener		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_parser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AddErrorListener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(listener)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
script = _parser.script();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
script = _parser.script()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
script		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_parser.script()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_parser.script		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_parser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
script		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
listener.Finish();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
listener.Finish()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
listener.Finish		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
listener		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Finish		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public override string ToString() => PrintSyntaxTree(_parser, script);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> PrintSyntaxTree(_parser, script)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
PrintSyntaxTree(_parser, script)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
PrintSyntaxTree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_parser, script)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_parser		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_parser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
script		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
script		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static string PrintSyntaxTree(Parser parser, IParseTree root) {
            StringBuilder buf = new StringBuilder();
            Recursive(root, buf, 0,  parser.RuleNames);
            return buf.ToString();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Parser parser, IParseTree root)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Parser parser		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Parser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IParseTree root		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            StringBuilder buf = new StringBuilder();
            Recursive(root, buf, 0,  parser.RuleNames);
            return buf.ToString();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
StringBuilder buf = new StringBuilder();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
StringBuilder buf = new StringBuilder()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
StringBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
buf = new StringBuilder()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new StringBuilder()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new StringBuilder()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
StringBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Recursive(root, buf, 0,  parser.RuleNames);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Recursive(root, buf, 0,  parser.RuleNames)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Recursive		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(root, buf, 0,  parser.RuleNames)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
root		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
root		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
buf		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
buf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
parser.RuleNames		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parser.RuleNames		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
parser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
RuleNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return buf.ToString();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
buf.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
buf.ToString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
buf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
private static void Recursive(IParseTree aRoot, StringBuilder buf, int offset, string[] ruleNames) {
            for (int i = 0; i < offset; i++) buf.Append("  ");
            buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");
            if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IParseTree aRoot, StringBuilder buf, int offset, string[] ruleNames)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IParseTree aRoot		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IParseTree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StringBuilder buf		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
StringBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int offset		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
string[] ruleNames		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{
            for (int i = 0; i < offset; i++) buf.Append("  ");
            buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");
            if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
for (int i = 0; i < offset; i++) buf.Append("  ");		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < offset		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
offset		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
buf.Append("  ");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
buf.Append("  ")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
buf.Append		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
buf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Append		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("  ")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"  "		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"  "		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append("\n")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
buf.Append(Trees.GetNodeText(aRoot, ruleNames)).Append		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
buf.Append(Trees.GetNodeText(aRoot, ruleNames))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
buf.Append		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
buf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Append		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Trees.GetNodeText(aRoot, ruleNames))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Trees.GetNodeText(aRoot, ruleNames)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Trees.GetNodeText(aRoot, ruleNames)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Trees.GetNodeText		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Trees		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNodeText		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(aRoot, ruleNames)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
aRoot		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
aRoot		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ruleNames		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ruleNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Append		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("\n")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"\n"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"\n"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (aRoot is ParserRuleContext) {
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
aRoot is ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
aRoot		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                ParserRuleContext prc = (ParserRuleContext) aRoot;
                if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ParserRuleContext prc = (ParserRuleContext) aRoot;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ParserRuleContext prc = (ParserRuleContext) aRoot		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
prc = (ParserRuleContext) aRoot		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= (ParserRuleContext) aRoot		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
(ParserRuleContext) aRoot		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
ParserRuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
aRoot		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (prc.children != null) {
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
prc.children != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
prc.children		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
prc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
children		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
                    foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }
                }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
foreach (IParseTree child in prc.children) {
                        Recursive(child, buf, offset + 1, ruleNames);
                    }		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
IParseTree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
prc.children		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
prc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
children		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                        Recursive(child, buf, offset + 1, ruleNames);
                    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Recursive(child, buf, offset + 1, ruleNames);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Recursive(child, buf, offset + 1, ruleNames)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Recursive		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(child, buf, offset + 1, ruleNames)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
child		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
child		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
buf		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
buf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
offset + 1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
offset + 1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
offset		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ruleNames		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ruleNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using Antlr4.Runtime.Tree;
using HyperSphere;
using runtime.core;
using runtime.core.JIL;
using runtime.core.Runtime;

namespace runtime.parse
{
    internal class ExprFrame {
        public JILTypeBuilder Type;
        public JILModuleBuilder Module;
        public JILExprBuilder Expr;

        internal ExprFrame(JILTypeBuilder type, JILModuleBuilder module, JILExprBuilder expr) {
            Module = module;
            Expr = expr;
            Type = type;
        }
    }

    internal struct JuliaStaticCompiler {
        private JuliappParser _p;

        public JRuntimeExpr Compile(JuliappParser p, JRuntimeModule evaluationModule) {
            _p = p;
            Console.WriteLine(_p.ToString());
            return Compile(_p.script, evaluationModule);
        }
        
        public JILFieldBuilder CompileField(ITerminalNode nameID, JuliaParser.TypeContext type, ExprFrame frame, bool isConst, bool isGlobal) {
            var f = new JILFieldBuilder(Compile(nameID), frame.Expr);
            f.IsConst = isConst;
            f.IsGlobal = isGlobal;

            var ty = type != null ? Compile(type.Identifier()) : "Any";
            f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);

            return f;
        }

        public void Compile(JuliaParser.BlockExprContext ctx, ExprFrame frame) {
            if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
        }

        public void Compile(JuliaParser.ModuleContext ctx, ExprFrame frame)
        {
            var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));
            if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
            mod.Create();
        }

        public void Compile(JuliaParser.FunctionContext ctx, ExprFrame frame) {
            
        }

        public string Compile(ITerminalNode n) => n.GetText();

        public void Compile(JuliaParser.TypeNameContext ctx, out string TypeName, out IJType ExtendedTypeName) {
            TypeName = ctx.Identifier().GetText();
            if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;
        }
        
        public void Compile(JuliaParser.StructureContext ctx, ExprFrame frame)
        {
            string name = Compile(ctx.typeName().Identifier());
            JTypeType typetype = JTypeType.None;

            if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;

            var tb = frame.Module.DefineType(name);
            tb.Type = typetype;
            frame.Type = tb;
            foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }

            frame.Expr.Code.InstantiateType(tb);
            
            frame.Type = null;
        }
        
        public void Compile(JuliaParser.UsingModuleContext ctx, ExprFrame frame) {
            var ids = ctx.moduleRef().Identifier();
            var str = ctx.moduleRef().GetText().Substring(5);
            frame.Module.AddName(str, true, false);
        }
        
        public object Compile(JuliaParser.FunctionCallContext ctx, ExprFrame frame) => null;
        public void Compile(JuliaParser.ModuleExprContext ctx, ExprFrame frame) {
            if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
        }
        
        public JRuntimeExpr Compile(JuliaParser.ScriptContext ctx, JRuntimeModule evaluationModule) {
            JILBuilder eb = new(evaluationModule);
            ExprFrame frame = new(null, eb, eb);
            
            if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }

            return eb.CreateExpression();
        }
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using Antlr4.Runtime.Tree;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
Antlr4.Runtime.Tree		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Antlr4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Tree		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using HyperSphere;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
HyperSphere		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.JIL;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.Runtime;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.parse
{
    internal class ExprFrame {
        public JILTypeBuilder Type;
        public JILModuleBuilder Module;
        public JILExprBuilder Expr;

        internal ExprFrame(JILTypeBuilder type, JILModuleBuilder module, JILExprBuilder expr) {
            Module = module;
            Expr = expr;
            Type = type;
        }
    }

    internal struct JuliaStaticCompiler {
        private JuliappParser _p;

        public JRuntimeExpr Compile(JuliappParser p, JRuntimeModule evaluationModule) {
            _p = p;
            Console.WriteLine(_p.ToString());
            return Compile(_p.script, evaluationModule);
        }
        
        public JILFieldBuilder CompileField(ITerminalNode nameID, JuliaParser.TypeContext type, ExprFrame frame, bool isConst, bool isGlobal) {
            var f = new JILFieldBuilder(Compile(nameID), frame.Expr);
            f.IsConst = isConst;
            f.IsGlobal = isGlobal;

            var ty = type != null ? Compile(type.Identifier()) : "Any";
            f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);

            return f;
        }

        public void Compile(JuliaParser.BlockExprContext ctx, ExprFrame frame) {
            if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
        }

        public void Compile(JuliaParser.ModuleContext ctx, ExprFrame frame)
        {
            var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));
            if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
            mod.Create();
        }

        public void Compile(JuliaParser.FunctionContext ctx, ExprFrame frame) {
            
        }

        public string Compile(ITerminalNode n) => n.GetText();

        public void Compile(JuliaParser.TypeNameContext ctx, out string TypeName, out IJType ExtendedTypeName) {
            TypeName = ctx.Identifier().GetText();
            if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;
        }
        
        public void Compile(JuliaParser.StructureContext ctx, ExprFrame frame)
        {
            string name = Compile(ctx.typeName().Identifier());
            JTypeType typetype = JTypeType.None;

            if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;

            var tb = frame.Module.DefineType(name);
            tb.Type = typetype;
            frame.Type = tb;
            foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }

            frame.Expr.Code.InstantiateType(tb);
            
            frame.Type = null;
        }
        
        public void Compile(JuliaParser.UsingModuleContext ctx, ExprFrame frame) {
            var ids = ctx.moduleRef().Identifier();
            var str = ctx.moduleRef().GetText().Substring(5);
            frame.Module.AddName(str, true, false);
        }
        
        public object Compile(JuliaParser.FunctionCallContext ctx, ExprFrame frame) => null;
        public void Compile(JuliaParser.ModuleExprContext ctx, ExprFrame frame) {
            if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
        }
        
        public JRuntimeExpr Compile(JuliaParser.ScriptContext ctx, JRuntimeModule evaluationModule) {
            JILBuilder eb = new(evaluationModule);
            ExprFrame frame = new(null, eb, eb);
            
            if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }

            return eb.CreateExpression();
        }
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.parse		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parse		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal class ExprFrame {
        public JILTypeBuilder Type;
        public JILModuleBuilder Module;
        public JILExprBuilder Expr;

        internal ExprFrame(JILTypeBuilder type, JILModuleBuilder module, JILExprBuilder expr) {
            Module = module;
            Expr = expr;
            Type = type;
        }
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
public JILTypeBuilder Type;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JILTypeBuilder Type		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILTypeBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public JILModuleBuilder Module;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JILModuleBuilder Module		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public JILExprBuilder Expr;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JILExprBuilder Expr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Expr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal ExprFrame(JILTypeBuilder type, JILModuleBuilder module, JILExprBuilder expr) {
            Module = module;
            Expr = expr;
            Type = type;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JILTypeBuilder type, JILModuleBuilder module, JILExprBuilder expr)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILTypeBuilder type		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILTypeBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILModuleBuilder module		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILExprBuilder expr		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            Module = module;
            Expr = expr;
            Type = type;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Module = module;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Module = module		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Expr = expr;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Expr = expr		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Expr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
expr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type = type;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Type = type		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal struct JuliaStaticCompiler {
        private JuliappParser _p;

        public JRuntimeExpr Compile(JuliappParser p, JRuntimeModule evaluationModule) {
            _p = p;
            Console.WriteLine(_p.ToString());
            return Compile(_p.script, evaluationModule);
        }
        
        public JILFieldBuilder CompileField(ITerminalNode nameID, JuliaParser.TypeContext type, ExprFrame frame, bool isConst, bool isGlobal) {
            var f = new JILFieldBuilder(Compile(nameID), frame.Expr);
            f.IsConst = isConst;
            f.IsGlobal = isGlobal;

            var ty = type != null ? Compile(type.Identifier()) : "Any";
            f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);

            return f;
        }

        public void Compile(JuliaParser.BlockExprContext ctx, ExprFrame frame) {
            if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
        }

        public void Compile(JuliaParser.ModuleContext ctx, ExprFrame frame)
        {
            var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));
            if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
            mod.Create();
        }

        public void Compile(JuliaParser.FunctionContext ctx, ExprFrame frame) {
            
        }

        public string Compile(ITerminalNode n) => n.GetText();

        public void Compile(JuliaParser.TypeNameContext ctx, out string TypeName, out IJType ExtendedTypeName) {
            TypeName = ctx.Identifier().GetText();
            if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;
        }
        
        public void Compile(JuliaParser.StructureContext ctx, ExprFrame frame)
        {
            string name = Compile(ctx.typeName().Identifier());
            JTypeType typetype = JTypeType.None;

            if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;

            var tb = frame.Module.DefineType(name);
            tb.Type = typetype;
            frame.Type = tb;
            foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }

            frame.Expr.Code.InstantiateType(tb);
            
            frame.Type = null;
        }
        
        public void Compile(JuliaParser.UsingModuleContext ctx, ExprFrame frame) {
            var ids = ctx.moduleRef().Identifier();
            var str = ctx.moduleRef().GetText().Substring(5);
            frame.Module.AddName(str, true, false);
        }
        
        public object Compile(JuliaParser.FunctionCallContext ctx, ExprFrame frame) => null;
        public void Compile(JuliaParser.ModuleExprContext ctx, ExprFrame frame) {
            if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
        }
        
        public JRuntimeExpr Compile(JuliaParser.ScriptContext ctx, JRuntimeModule evaluationModule) {
            JILBuilder eb = new(evaluationModule);
            ExprFrame frame = new(null, eb, eb);
            
            if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }

            return eb.CreateExpression();
        }
    }		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
private JuliappParser _p;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JuliappParser _p		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JuliappParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_p		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public JRuntimeExpr Compile(JuliappParser p, JRuntimeModule evaluationModule) {
            _p = p;
            Console.WriteLine(_p.ToString());
            return Compile(_p.script, evaluationModule);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JRuntimeExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliappParser p, JRuntimeModule evaluationModule)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JuliappParser p		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JuliappParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JRuntimeModule evaluationModule		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JRuntimeModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            _p = p;
            Console.WriteLine(_p.ToString());
            return Compile(_p.script, evaluationModule);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_p = p;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_p = p		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.WriteLine(_p.ToString());		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Console.WriteLine(_p.ToString())		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Console.WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_p.ToString())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_p.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_p.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_p.ToString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return Compile(_p.script, evaluationModule);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
Compile(_p.script, evaluationModule)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_p.script, evaluationModule)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_p.script		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_p.script		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
script		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
evaluationModule		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
evaluationModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JILFieldBuilder CompileField(ITerminalNode nameID, JuliaParser.TypeContext type, ExprFrame frame, bool isConst, bool isGlobal) {
            var f = new JILFieldBuilder(Compile(nameID), frame.Expr);
            f.IsConst = isConst;
            f.IsGlobal = isGlobal;

            var ty = type != null ? Compile(type.Identifier()) : "Any";
            f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);

            return f;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JILFieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ITerminalNode nameID, JuliaParser.TypeContext type, ExprFrame frame, bool isConst, bool isGlobal)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ITerminalNode nameID		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JuliaParser.TypeContext type		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JuliaParser.TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExprFrame frame		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ExprFrame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool isConst		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
bool isGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
            var f = new JILFieldBuilder(Compile(nameID), frame.Expr);
            f.IsConst = isConst;
            f.IsGlobal = isGlobal;

            var ty = type != null ? Compile(type.Identifier()) : "Any";
            f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);

            return f;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var f = new JILFieldBuilder(Compile(nameID), frame.Expr);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var f = new JILFieldBuilder(Compile(nameID), frame.Expr)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
f = new JILFieldBuilder(Compile(nameID), frame.Expr)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new JILFieldBuilder(Compile(nameID), frame.Expr)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new JILFieldBuilder(Compile(nameID), frame.Expr)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JILFieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Compile(nameID), frame.Expr)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Compile(nameID)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Compile(nameID)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(nameID)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
nameID		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameID		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
frame.Expr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame.Expr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Expr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
f.IsConst = isConst;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
f.IsConst = isConst		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
f.IsConst		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsConst		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
isConst		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
f.IsGlobal = isGlobal;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
f.IsGlobal = isGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
f.IsGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
isGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var ty = type != null ? Compile(type.Identifier()) : "Any";		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var ty = type != null ? Compile(type.Identifier()) : "Any"		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ty = type != null ? Compile(type.Identifier()) : "Any"		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= type != null ? Compile(type.Identifier()) : "Any"		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
type != null ? Compile(type.Identifier()) : "Any"		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
type != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Compile(type.Identifier())		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(type.Identifier())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
type.Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
type.Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
type.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Any"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
f.TypeRef = (frame.Expr as IJExpr).GetNameRef(ty)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
f.TypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(frame.Expr as IJExpr).GetNameRef(ty)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
(frame.Expr as IJExpr).GetNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
(frame.Expr as IJExpr)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
frame.Expr as IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
frame.Expr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Expr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ty)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ty		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ty		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return f;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Compile(JuliaParser.BlockExprContext ctx, ExprFrame frame) {
            if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JuliaParser.BlockExprContext ctx, ExprFrame frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JuliaParser.BlockExprContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JuliaParser.BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BlockExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExprFrame frame		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ExprFrame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (ctx.blockVariableDeclaration() != null) {
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            } else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.blockVariableDeclaration() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.blockVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.blockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
blockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
                var bctx = ctx.blockVariableDeclaration();
                CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var bctx = ctx.blockVariableDeclaration();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var bctx = ctx.blockVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bctx = ctx.blockVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= ctx.blockVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
ctx.blockVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.blockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
blockVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
CompileField(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CompileField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(bctx.blockArg().Identifier(), bctx.blockArg().type(), 
                    frame, bctx.Const() != null, bctx.Local() == null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
bctx.blockArg().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
bctx.blockArg().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
bctx.blockArg().Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
bctx.blockArg()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
bctx.blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
bctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
bctx.blockArg().type()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
bctx.blockArg().type()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
bctx.blockArg().type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
bctx.blockArg()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
bctx.blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
bctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bctx.Const() != null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
bctx.Const() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
bctx.Const()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
bctx.Const		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
bctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
bctx.Local() == null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
bctx.Local() == null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
bctx.Local()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
bctx.Local		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
bctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
else if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (ctx.functionCall() != null) 
                Compile(ctx.functionCall(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.functionCall() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.functionCall()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.functionCall		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
functionCall		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Compile(ctx.functionCall(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Compile(ctx.functionCall(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ctx.functionCall(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ctx.functionCall()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ctx.functionCall()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.functionCall		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
functionCall		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Compile(JuliaParser.ModuleContext ctx, ExprFrame frame)
        {
            var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));
            if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
            mod.Create();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JuliaParser.ModuleContext ctx, ExprFrame frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JuliaParser.ModuleContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JuliaParser.ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExprFrame frame		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ExprFrame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));
            if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }
            mod.Create();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var mod = frame.Module.DefineModule(Compile(ctx.Identifier()));		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var mod = frame.Module.DefineModule(Compile(ctx.Identifier()))		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mod = frame.Module.DefineModule(Compile(ctx.Identifier()))		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= frame.Module.DefineModule(Compile(ctx.Identifier()))		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
frame.Module.DefineModule(Compile(ctx.Identifier()))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
frame.Module.DefineModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame.Module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DefineModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Compile(ctx.Identifier()))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Compile(ctx.Identifier())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Compile(ctx.Identifier())		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ctx.Identifier())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ctx.Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ctx.Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
if (ctx.moduleExpr() != null) {
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.moduleExpr() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.moduleExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
                ExprFrame frame2 = new(null, mod, mod);
                foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExprFrame frame2 = new(null, mod, mod);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ExprFrame frame2 = new(null, mod, mod)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ExprFrame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
frame2 = new(null, mod, mod)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(null, mod, mod)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(null, mod, mod)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(null, mod, mod)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
mod		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mod		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
foreach(var v in ctx.moduleExpr())
                    Compile(v, frame2);		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ctx.moduleExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Compile(v, frame2);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Compile(v, frame2)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v, frame2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
frame2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mod.Create();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
mod.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
mod.Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
mod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public void Compile(JuliaParser.FunctionContext ctx, ExprFrame frame) {
            
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JuliaParser.FunctionContext ctx, ExprFrame frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JuliaParser.FunctionContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JuliaParser.FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExprFrame frame		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ExprFrame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public string Compile(ITerminalNode n) => n.GetText();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(ITerminalNode n)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ITerminalNode n		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ITerminalNode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> n.GetText()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
n.GetText()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
n.GetText		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
n		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetText		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public void Compile(JuliaParser.TypeNameContext ctx, out string TypeName, out IJType ExtendedTypeName) {
            TypeName = ctx.Identifier().GetText();
            if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JuliaParser.TypeNameContext ctx, out string TypeName, out IJType ExtendedTypeName)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JuliaParser.TypeNameContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JuliaParser.TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeNameContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out string TypeName		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out IJType ExtendedTypeName		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            TypeName = ctx.Identifier().GetText();
            if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
TypeName = ctx.Identifier().GetText();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
TypeName = ctx.Identifier().GetText()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
TypeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ctx.Identifier().GetText()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.Identifier().GetText		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx.Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
GetText		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
if (ctx.type() != null) {
                ExtendedTypeName = null;
            }
            else ExtendedTypeName = null;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.type() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.type()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
                ExtendedTypeName = null;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ExtendedTypeName = null;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExtendedTypeName = null		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
ExtendedTypeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
else ExtendedTypeName = null;		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
ExtendedTypeName = null;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ExtendedTypeName = null		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
ExtendedTypeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public void Compile(JuliaParser.StructureContext ctx, ExprFrame frame)
        {
            string name = Compile(ctx.typeName().Identifier());
            JTypeType typetype = JTypeType.None;

            if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;

            var tb = frame.Module.DefineType(name);
            tb.Type = typetype;
            frame.Type = tb;
            foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }

            frame.Expr.Code.InstantiateType(tb);
            
            frame.Type = null;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JuliaParser.StructureContext ctx, ExprFrame frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JuliaParser.StructureContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JuliaParser.StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StructureContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExprFrame frame		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ExprFrame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            string name = Compile(ctx.typeName().Identifier());
            JTypeType typetype = JTypeType.None;

            if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;

            var tb = frame.Module.DefineType(name);
            tb.Type = typetype;
            frame.Type = tb;
            foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }

            frame.Expr.Code.InstantiateType(tb);
            
            frame.Type = null;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
string name = Compile(ctx.typeName().Identifier());		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
string name = Compile(ctx.typeName().Identifier())		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
name = Compile(ctx.typeName().Identifier())		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Compile(ctx.typeName().Identifier())		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Compile(ctx.typeName().Identifier())		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ctx.typeName().Identifier())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ctx.typeName().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ctx.typeName().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.typeName().Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx.typeName()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.typeName		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JTypeType typetype = JTypeType.None;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
JTypeType typetype = JTypeType.None		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typetype = JTypeType.None		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= JTypeType.None		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
JTypeType.None		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (ctx.abstractStructure() != null)
                typetype = JTypeType.Abstract;
            else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.abstractStructure() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.abstractStructure()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.abstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
abstractStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typetype = JTypeType.Abstract;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typetype = JTypeType.Abstract		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
typetype		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JTypeType.Abstract		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Abstract		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (ctx.compositeStructure() != null)
                typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.compositeStructure() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.compositeStructure()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.compositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
compositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
typetype = ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
typetype		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ctx.compositeStructure().Mutable() != null ? JTypeType.Mutable : JTypeType.Struct		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
ctx.compositeStructure().Mutable() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.compositeStructure().Mutable()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.compositeStructure().Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx.compositeStructure()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.compositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
compositeStructure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
JTypeType.Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JTypeType.Struct		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Struct		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var tb = frame.Module.DefineType(name);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var tb = frame.Module.DefineType(name)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tb = frame.Module.DefineType(name)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= frame.Module.DefineType(name)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
frame.Module.DefineType(name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
frame.Module.DefineType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame.Module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DefineType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tb.Type = typetype;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tb.Type = typetype		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
tb.Type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typetype		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
frame.Type = tb;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
frame.Type = tb		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
frame.Type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
foreach (var item in ctx.structItem()) {
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ctx.structItem()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.structItem		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
structItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
{
                if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (item.function() != null) {
                    Compile(item.function(), frame);
                }else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
item.function() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
item.function()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
item.function		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
item		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
                    Compile(item.function(), frame);
                }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Compile(item.function(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Compile(item.function(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(item.function(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
item.function()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
item.function()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
item.function		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
item		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else {
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
{
                    var sctx = item.structField();
                    tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));
                }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var sctx = item.structField();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var sctx = item.structField()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sctx = item.structField()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= item.structField()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
item.structField()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
item.structField		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
item		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
structField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tb.AddField(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tb.AddField		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AddField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
CompileField(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CompileField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(sctx.blockArg().Identifier(), sctx.blockArg().type(), frame, false, false)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
sctx.blockArg().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
sctx.blockArg().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
sctx.blockArg().Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
sctx.blockArg()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
sctx.blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
sctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
sctx.blockArg().type()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
sctx.blockArg().type()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
sctx.blockArg().type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
sctx.blockArg()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
sctx.blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
sctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
frame.Expr.Code.InstantiateType(tb);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
frame.Expr.Code.InstantiateType(tb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
frame.Expr.Code.InstantiateType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame.Expr.Code		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame.Expr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Expr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
InstantiateType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(tb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
tb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
frame.Type = null;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
frame.Type = null		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
frame.Type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public void Compile(JuliaParser.UsingModuleContext ctx, ExprFrame frame) {
            var ids = ctx.moduleRef().Identifier();
            var str = ctx.moduleRef().GetText().Substring(5);
            frame.Module.AddName(str, true, false);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JuliaParser.UsingModuleContext ctx, ExprFrame frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JuliaParser.UsingModuleContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JuliaParser.UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UsingModuleContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExprFrame frame		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ExprFrame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            var ids = ctx.moduleRef().Identifier();
            var str = ctx.moduleRef().GetText().Substring(5);
            frame.Module.AddName(str, true, false);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var ids = ctx.moduleRef().Identifier();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var ids = ctx.moduleRef().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ids = ctx.moduleRef().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= ctx.moduleRef().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
ctx.moduleRef().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleRef().Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx.moduleRef()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
moduleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
var str = ctx.moduleRef().GetText().Substring(5);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var str = ctx.moduleRef().GetText().Substring(5)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
str = ctx.moduleRef().GetText().Substring(5)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= ctx.moduleRef().GetText().Substring(5)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
ctx.moduleRef().GetText().Substring(5)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleRef().GetText().Substring		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx.moduleRef().GetText()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleRef().GetText		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx.moduleRef()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
moduleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
GetText		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Substring		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(5)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
5		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
frame.Module.AddName(str, true, false);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
frame.Module.AddName(str, true, false)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
frame.Module.AddName		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame.Module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AddName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(str, true, false)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
str		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
str		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public object Compile(JuliaParser.FunctionCallContext ctx, ExprFrame frame) => null;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JuliaParser.FunctionCallContext ctx, ExprFrame frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JuliaParser.FunctionCallContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JuliaParser.FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FunctionCallContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExprFrame frame		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ExprFrame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> null		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public void Compile(JuliaParser.ModuleExprContext ctx, ExprFrame frame) {
            if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JuliaParser.ModuleExprContext ctx, ExprFrame frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JuliaParser.ModuleExprContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JuliaParser.ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleExprContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExprFrame frame		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ExprFrame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (ctx.usingModule() != null)
                Compile(ctx.usingModule(), frame);
            else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.usingModule() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.usingModule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.usingModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
usingModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Compile(ctx.usingModule(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Compile(ctx.usingModule(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ctx.usingModule(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ctx.usingModule()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ctx.usingModule()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.usingModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
usingModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (ctx.module() != null)
                Compile(ctx.module(), frame);
            else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.module() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.module()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Compile(ctx.module(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Compile(ctx.module(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ctx.module(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ctx.module()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ctx.module()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (ctx.blockExpr() != null)
                Compile(ctx.blockExpr(), frame);
            else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.blockExpr() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.blockExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Compile(ctx.blockExpr(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Compile(ctx.blockExpr(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ctx.blockExpr(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ctx.blockExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ctx.blockExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
blockExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (ctx.structure() != null)
                Compile(ctx.structure(), frame);
            else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.structure() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.structure()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.structure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
structure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Compile(ctx.structure(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Compile(ctx.structure(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ctx.structure(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ctx.structure()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ctx.structure()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.structure		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
structure		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (ctx.moduleVariableDeclaration() != null) {
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.moduleVariableDeclaration() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.moduleVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
moduleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
                var mvd = ctx.moduleVariableDeclaration();
                CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var mvd = ctx.moduleVariableDeclaration();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var mvd = ctx.moduleVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mvd = ctx.moduleVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= ctx.moduleVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
ctx.moduleVariableDeclaration()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
moduleVariableDeclaration		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
CompileField(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CompileField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(mvd.blockArg().Identifier(), mvd.blockArg().type(), frame, mvd.Const() != null, mvd.Local() == null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
mvd.blockArg().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mvd.blockArg().Identifier()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
mvd.blockArg().Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
mvd.blockArg()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
mvd.blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
mvd		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Identifier		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
mvd.blockArg().type()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mvd.blockArg().type()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
mvd.blockArg().type		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
mvd.blockArg()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
mvd.blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
mvd		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
blockArg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mvd.Const() != null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mvd.Const() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
mvd.Const()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
mvd.Const		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
mvd		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
mvd.Local() == null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mvd.Local() == null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
mvd.Local()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
mvd.Local		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
mvd		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public JRuntimeExpr Compile(JuliaParser.ScriptContext ctx, JRuntimeModule evaluationModule) {
            JILBuilder eb = new(evaluationModule);
            ExprFrame frame = new(null, eb, eb);
            
            if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }

            return eb.CreateExpression();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JRuntimeExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JuliaParser.ScriptContext ctx, JRuntimeModule evaluationModule)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JuliaParser.ScriptContext ctx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JuliaParser.ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
JuliaParser		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ScriptContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JRuntimeModule evaluationModule		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JRuntimeModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            JILBuilder eb = new(evaluationModule);
            ExprFrame frame = new(null, eb, eb);
            
            if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }

            return eb.CreateExpression();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
JILBuilder eb = new(evaluationModule);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
JILBuilder eb = new(evaluationModule)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
eb = new(evaluationModule)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(evaluationModule)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(evaluationModule)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(evaluationModule)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
evaluationModule		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
evaluationModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ExprFrame frame = new(null, eb, eb);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
ExprFrame frame = new(null, eb, eb)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ExprFrame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
frame = new(null, eb, eb)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(null, eb, eb)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(null, eb, eb)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(null, eb, eb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
eb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
eb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (ctx.moduleExpr() != null)
                Compile(ctx.moduleExpr(), frame);
            else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
ctx.moduleExpr() != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ctx.moduleExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Compile(ctx.moduleExpr(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Compile(ctx.moduleExpr(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ctx.moduleExpr(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ctx.moduleExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ctx.moduleExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else {
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
{
                foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
foreach(var v in ctx.moduleExprStatement())
                    Compile(v.moduleExpr(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ctx.moduleExprStatement()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ctx.moduleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
moduleExprStatement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Compile(v.moduleExpr(), frame);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Compile(v.moduleExpr(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Compile		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v.moduleExpr(), frame)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v.moduleExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v.moduleExpr()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v.moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
moduleExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
frame		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return eb.CreateExpression();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
eb.CreateExpression()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
eb.CreateExpression		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CreateExpression		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
using System;
using System.Runtime.CompilerServices;

namespace runtime.Utils
{
    public static class EnumExtensions
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static long ConvertToInt64<T>(T value) => Unsafe.As<T, long>(ref value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static T ConvertFromInt64<T>(long value) => Unsafe.As<long, T>(ref value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Include<T>(this T value, T append) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Remove<T>(this T value, T rem) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Set<T>(this T value, T flagSet, bool v = true) where T : Enum {
            if (v) return Include(value, flagSet);
            return Remove(value, flagSet);
        }
        
        
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Runtime.CompilerServices;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Runtime.CompilerServices		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompilerServices		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.Utils
{
    public static class EnumExtensions
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static long ConvertToInt64<T>(T value) => Unsafe.As<T, long>(ref value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static T ConvertFromInt64<T>(long value) => Unsafe.As<long, T>(ref value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Include<T>(this T value, T append) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Remove<T>(this T value, T rem) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Set<T>(this T value, T flagSet, bool v = true) where T : Enum {
            if (v) return Include(value, flagSet);
            return Remove(value, flagSet);
        }
        
        
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.Utils		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Utils		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static class EnumExtensions
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static long ConvertToInt64<T>(T value) => Unsafe.As<T, long>(ref value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] private static T ConvertFromInt64<T>(long value) => Unsafe.As<long, T>(ref value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Include<T>(this T value, T append) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Remove<T>(this T value, T rem) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Set<T>(this T value, T flagSet, bool v = true) where T : Enum {
            if (v) return Include(value, flagSet);
            return Remove(value, flagSet);
        }
        
        
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)] private static long ConvertToInt64<T>(T value) => Unsafe.As<T, long>(ref value);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
MethodImpl(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
MethodImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodImplOptions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
long		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(T value)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
T value		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Unsafe.As<T, long>(ref value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Unsafe.As<T, long>(ref value)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Unsafe.As<T, long>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Unsafe		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
As<T, long>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T, long>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
long		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(ref value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ref value		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)] private static T ConvertFromInt64<T>(long value) => Unsafe.As<long, T>(ref value);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
MethodImpl(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
MethodImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodImplOptions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(long value)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
long value		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
long		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Unsafe.As<long, T>(ref value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Unsafe.As<long, T>(ref value)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Unsafe.As<long, T>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Unsafe		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
As<long, T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<long, T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
long		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ref value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ref value		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Include<T>(this T value, T append) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
MethodImpl(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
MethodImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodImplOptions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(this T value, T append)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
this T value		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
T append		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
where T : Enum		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Enum		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
Enum		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=>
            ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ConvertFromInt64<T>(ConvertToInt64(value) | ConvertToInt64(append))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ConvertFromInt64<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ConvertToInt64(value) | ConvertToInt64(append))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ConvertToInt64(value) | ConvertToInt64(append)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ConvertToInt64(value) | ConvertToInt64(append)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ConvertToInt64(value)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ConvertToInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ConvertToInt64(append)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ConvertToInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(append)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
append		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
append		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Remove<T>(this T value, T rem) where T : Enum =>
            ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
MethodImpl(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
MethodImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodImplOptions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(this T value, T rem)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
this T value		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
T rem		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
where T : Enum		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Enum		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
Enum		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=>
            ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ConvertFromInt64<T>(ConvertToInt64(value) & ~ConvertToInt64(rem))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ConvertFromInt64<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ConvertToInt64(value) & ~ConvertToInt64(rem))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ConvertToInt64(value) & ~ConvertToInt64(rem)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ConvertToInt64(value) & ~ConvertToInt64(rem)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ConvertToInt64(value)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ConvertToInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
~ConvertToInt64(rem)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
ConvertToInt64(rem)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ConvertToInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(rem)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
rem		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
rem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Set<T>(this T value, T flagSet, bool v = true) where T : Enum {
            if (v) return Include(value, flagSet);
            return Remove(value, flagSet);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
MethodImpl(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
MethodImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodImplOptions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(this T value, T flagSet, bool v = true)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
this T value		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
T flagSet		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool v = true		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= true		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
where T : Enum		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Enum		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
Enum		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            if (v) return Include(value, flagSet);
            return Remove(value, flagSet);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (v) return Include(value, flagSet);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return Include(value, flagSet);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
Include(value, flagSet)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Include		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(value, flagSet)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
flagSet		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
flagSet		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return Remove(value, flagSet);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
Remove(value, flagSet)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Remove		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(value, flagSet)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
flagSet		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
flagSet		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using System.Collections.Generic;

namespace runtime.Utils
{
    internal struct InternElement {
        internal int hash;
        internal int idx;
    }

    internal class MInternElementEquality<T> : IEqualityComparer<InternElement> {
        private MInternContainer<T> _c;
        
        internal MInternElementEquality(MInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }

    public class MInternContainer<T> {
        internal HashSet<InternElement> S;
        public readonly List<T> Data;
        protected internal T checkItem;
        
        public MInternContainer() : this(new()){}

        public MInternContainer(List<T> v) {
            S = new(new MInternElementEquality<T>(this));
            Data = v;
        }

        public T Get(int idx) => Data[idx];
        
        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = Data[idx].GetHashCode();
            e.idx = idx;
            S.Remove(e);
            Data[idx] = v;
            e.hash = v.GetHashCode();
            S.Add(e);
        }

        public int Load(T v)
        {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = Data.Count;
            Data.Add(v);
            S.Add(e);
            return e.idx;
        }

        public int GetIndex(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            return -1;
        }
    }
    
    internal class UInternElementEquality<T> : IEqualityComparer<InternElement> where T: unmanaged{
        private UInternContainer<T> _c;
        
        internal UInternElementEquality(UInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }
    
    public class UInternContainer<T> where T: unmanaged
    {
        private readonly HashSet<InternElement> _s;
        internal readonly UnsafeList<T> _data = new();
        internal T CheckItem = default;
        
        public UInternContainer() => _s = new(new UInternElementEquality<T>(this));

        public ref T Get(int idx) => ref _data.GetRef(idx);

        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = _data[idx].GetHashCode();
            e.idx = idx;
            _s.Remove(e);
            _data[idx] = v;
            e.hash = v.GetHashCode();
            _s.Add(e);
        }
        
        public int Load(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            CheckItem = v;
            if (_s.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = _data.Count;
            _data.Add(v);
            _s.Add(e);
            return e.idx;
        }
        
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Collections.Generic;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Collections.Generic		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Collections		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Collections		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Generic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.Utils
{
    internal struct InternElement {
        internal int hash;
        internal int idx;
    }

    internal class MInternElementEquality<T> : IEqualityComparer<InternElement> {
        private MInternContainer<T> _c;
        
        internal MInternElementEquality(MInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }

    public class MInternContainer<T> {
        internal HashSet<InternElement> S;
        public readonly List<T> Data;
        protected internal T checkItem;
        
        public MInternContainer() : this(new()){}

        public MInternContainer(List<T> v) {
            S = new(new MInternElementEquality<T>(this));
            Data = v;
        }

        public T Get(int idx) => Data[idx];
        
        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = Data[idx].GetHashCode();
            e.idx = idx;
            S.Remove(e);
            Data[idx] = v;
            e.hash = v.GetHashCode();
            S.Add(e);
        }

        public int Load(T v)
        {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = Data.Count;
            Data.Add(v);
            S.Add(e);
            return e.idx;
        }

        public int GetIndex(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            return -1;
        }
    }
    
    internal class UInternElementEquality<T> : IEqualityComparer<InternElement> where T: unmanaged{
        private UInternContainer<T> _c;
        
        internal UInternElementEquality(UInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }
    
    public class UInternContainer<T> where T: unmanaged
    {
        private readonly HashSet<InternElement> _s;
        internal readonly UnsafeList<T> _data = new();
        internal T CheckItem = default;
        
        public UInternContainer() => _s = new(new UInternElementEquality<T>(this));

        public ref T Get(int idx) => ref _data.GetRef(idx);

        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = _data[idx].GetHashCode();
            e.idx = idx;
            _s.Remove(e);
            _data[idx] = v;
            e.hash = v.GetHashCode();
            _s.Add(e);
        }
        
        public int Load(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            CheckItem = v;
            if (_s.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = _data.Count;
            _data.Add(v);
            _s.Add(e);
            return e.idx;
        }
        
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.Utils		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Utils		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal struct InternElement {
        internal int hash;
        internal int idx;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
internal int hash;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int hash		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal int idx;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int idx		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal class MInternElementEquality<T> : IEqualityComparer<InternElement> {
        private MInternContainer<T> _c;
        
        internal MInternElementEquality(MInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
: IEqualityComparer<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IEqualityComparer<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IEqualityComparer<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private MInternContainer<T> _c;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
MInternContainer<T> _c		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
MInternContainer<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal MInternElementEquality(MInternContainer<T> c) => _c = c;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(MInternContainer<T> c)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
MInternContainer<T> c		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
MInternContainer<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _c = c		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_c = c		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(InternElement x, InternElement y)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
InternElement x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
InternElement y		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]));		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
x.hash == y.hash && (x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]))		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
x.hash == y.hash		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
x.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
y.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
y		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx]))		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
x.idx == -1 ? _c.checkItem.Equals(_c.Data[y.idx]) : y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
x.idx == -1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
x.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_c.checkItem.Equals(_c.Data[y.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_c.checkItem.Equals		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c.checkItem		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
checkItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Equals		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_c.Data[y.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_c.Data[y.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_c.Data[y.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_c.Data		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[y.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
y.idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
y.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
y		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
y.idx == -1 && _c.checkItem.Equals(_c.Data[x.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
y.idx == -1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
y.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
y		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_c.checkItem.Equals(_c.Data[x.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_c.checkItem.Equals		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c.checkItem		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
checkItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Equals		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_c.Data[x.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_c.Data[x.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_c.Data[x.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_c.Data		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[x.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
x.idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int GetHashCode(InternElement obj) => obj.hash;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(InternElement obj)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
InternElement obj		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> obj.hash		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
obj.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
obj		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class MInternContainer<T> {
        internal HashSet<InternElement> S;
        public readonly List<T> Data;
        protected internal T checkItem;
        
        public MInternContainer() : this(new()){}

        public MInternContainer(List<T> v) {
            S = new(new MInternElementEquality<T>(this));
            Data = v;
        }

        public T Get(int idx) => Data[idx];
        
        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = Data[idx].GetHashCode();
            e.idx = idx;
            S.Remove(e);
            Data[idx] = v;
            e.hash = v.GetHashCode();
            S.Add(e);
        }

        public int Load(T v)
        {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = Data.Count;
            Data.Add(v);
            S.Add(e);
            return e.idx;
        }

        public int GetIndex(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            return -1;
        }
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
internal HashSet<InternElement> S;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
HashSet<InternElement> S		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
HashSet<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
S		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly List<T> Data;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<T> Data		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Data		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
protected internal T checkItem;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
T checkItem		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
checkItem		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public MInternContainer() : this(new()){}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
: this(new())		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(new())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public MInternContainer(List<T> v) {
            S = new(new MInternElementEquality<T>(this));
            Data = v;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(List<T> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
List<T> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
List<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            S = new(new MInternElementEquality<T>(this));
            Data = v;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
S = new(new MInternElementEquality<T>(this));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
S = new(new MInternElementEquality<T>(this))		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
S		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new(new MInternElementEquality<T>(this))		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(new MInternElementEquality<T>(this))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
new MInternElementEquality<T>(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
new MInternElementEquality<T>(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
MInternElementEquality<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
Data = v;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Data = v		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public T Get(int idx) => Data[idx];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int idx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Data[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Data[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = Data[idx].GetHashCode();
            e.idx = idx;
            S.Remove(e);
            Data[idx] = v;
            e.hash = v.GetHashCode();
            S.Add(e);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int idx, T v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int idx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
T v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            InternElement e = new();
            e.hash = Data[idx].GetHashCode();
            e.idx = idx;
            S.Remove(e);
            Data[idx] = v;
            e.hash = v.GetHashCode();
            S.Add(e);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
InternElement e = new();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
InternElement e = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e.hash = Data[idx].GetHashCode();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.hash = Data[idx].GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Data[idx].GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Data[idx].GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Data[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e.idx = idx;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.idx = idx		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
S.Remove(e);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
S.Remove(e)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
S.Remove		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
S		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Remove		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(e)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Data[idx] = v;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Data[idx] = v		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Data[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e.hash = v.GetHashCode();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.hash = v.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v.GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
S.Add(e);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
S.Add(e)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
S.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
S		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(e)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int Load(T v)
        {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = Data.Count;
            Data.Add(v);
            S.Add(e);
            return e.idx;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(T v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
T v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = Data.Count;
            Data.Add(v);
            S.Add(e);
            return e.idx;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
InternElement e = new();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
InternElement e = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e.hash = v.GetHashCode();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.hash = v.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v.GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e.idx = -1;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.idx = -1		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
checkItem = v;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
checkItem = v		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
checkItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (S.TryGetValue(e, out var rE))
                return rE.idx;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
S.TryGetValue(e, out var rE)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
S.TryGetValue		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
S		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TryGetValue		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(e, out var rE)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out var rE		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
var rE		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
rE		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
return rE.idx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
rE.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
rE		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e.idx = Data.Count;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.idx = Data.Count		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Data.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Data.Add(v);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Data.Add(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Data.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
S.Add(e);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
S.Add(e)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
S.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
S		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(e)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return e.idx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
e.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int GetIndex(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            return -1;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(T v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
T v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            checkItem = v;
            if (S.TryGetValue(e, out var rE))
                return rE.idx;
            return -1;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
InternElement e = new();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
InternElement e = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e.hash = v.GetHashCode();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.hash = v.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v.GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e.idx = -1;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.idx = -1		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
checkItem = v;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
checkItem = v		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
checkItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (S.TryGetValue(e, out var rE))
                return rE.idx;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
S.TryGetValue(e, out var rE)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
S.TryGetValue		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
S		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TryGetValue		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(e, out var rE)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out var rE		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
var rE		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
rE		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
return rE.idx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
rE.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
rE		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return -1;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
internal class UInternElementEquality<T> : IEqualityComparer<InternElement> where T: unmanaged{
        private UInternContainer<T> _c;
        
        internal UInternElementEquality(UInternContainer<T> c) => _c = c;
        public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));
        }

        public int GetHashCode(InternElement obj) => obj.hash;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
: IEqualityComparer<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IEqualityComparer<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IEqualityComparer<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
where T: unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private UInternContainer<T> _c;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
UInternContainer<T> _c		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
UInternContainer<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal UInternElementEquality(UInternContainer<T> c) => _c = c;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(UInternContainer<T> c)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
UInternContainer<T> c		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
UInternContainer<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _c = c		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_c = c		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool Equals(InternElement x, InternElement y) {
            return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(InternElement x, InternElement y)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
InternElement x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
InternElement y		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
return x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]));		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
x.hash == y.hash && (x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]))		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
x.hash == y.hash		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
x.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
y.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
y		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx]))		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
x.idx == -1 ? _c.CheckItem.Equals(_c._data[y.idx]) : y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
x.idx == -1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
x.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_c.CheckItem.Equals(_c._data[y.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_c.CheckItem.Equals		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c.CheckItem		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CheckItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Equals		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_c._data[y.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_c._data[y.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_c._data[y.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_c._data		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[y.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
y.idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
y.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
y		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
y.idx == -1 && _c.CheckItem.Equals(_c._data[x.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
y.idx == -1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
y.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
y		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_c.CheckItem.Equals(_c._data[x.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_c.CheckItem.Equals		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c.CheckItem		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CheckItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Equals		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_c._data[x.idx])		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_c._data[x.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_c._data[x.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_c._data		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[x.idx]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
x.idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int GetHashCode(InternElement obj) => obj.hash;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(InternElement obj)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
InternElement obj		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> obj.hash		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
obj.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
obj		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class UInternContainer<T> where T: unmanaged
    {
        private readonly HashSet<InternElement> _s;
        internal readonly UnsafeList<T> _data = new();
        internal T CheckItem = default;
        
        public UInternContainer() => _s = new(new UInternElementEquality<T>(this));

        public ref T Get(int idx) => ref _data.GetRef(idx);

        public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = _data[idx].GetHashCode();
            e.idx = idx;
            _s.Remove(e);
            _data[idx] = v;
            e.hash = v.GetHashCode();
            _s.Add(e);
        }
        
        public int Load(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            CheckItem = v;
            if (_s.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = _data.Count;
            _data.Add(v);
            _s.Add(e);
            return e.idx;
        }
        
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
where T: unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private readonly HashSet<InternElement> _s;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
HashSet<InternElement> _s		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
HashSet<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<InternElement>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_s		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal readonly UnsafeList<T> _data = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
UnsafeList<T> _data = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
UnsafeList<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_data = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
internal T CheckItem = default;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
T CheckItem = default		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CheckItem = default		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= default		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
default		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public UInternContainer() => _s = new(new UInternElementEquality<T>(this));		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _s = new(new UInternElementEquality<T>(this))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_s = new(new UInternElementEquality<T>(this))		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new(new UInternElementEquality<T>(this))		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(new UInternElementEquality<T>(this))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
new UInternElementEquality<T>(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
new UInternElementEquality<T>(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
UInternElementEquality<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public ref T Get(int idx) => ref _data.GetRef(idx);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ref T		Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int idx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> ref _data.GetRef(idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ref _data.GetRef(idx)		Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax
_data.GetRef(idx)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_data.GetRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Set(int idx, T v) {
            InternElement e = new();
            e.hash = _data[idx].GetHashCode();
            e.idx = idx;
            _s.Remove(e);
            _data[idx] = v;
            e.hash = v.GetHashCode();
            _s.Add(e);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int idx, T v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int idx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
T v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            InternElement e = new();
            e.hash = _data[idx].GetHashCode();
            e.idx = idx;
            _s.Remove(e);
            _data[idx] = v;
            e.hash = v.GetHashCode();
            _s.Add(e);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
InternElement e = new();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
InternElement e = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e.hash = _data[idx].GetHashCode();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.hash = _data[idx].GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_data[idx].GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_data[idx].GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_data[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e.idx = idx;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.idx = idx		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_s.Remove(e);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_s.Remove(e)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_s.Remove		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Remove		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(e)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_data[idx] = v;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_data[idx] = v		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_data[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e.hash = v.GetHashCode();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.hash = v.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v.GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_s.Add(e);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_s.Add(e)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_s.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(e)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int Load(T v) {
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            CheckItem = v;
            if (_s.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = _data.Count;
            _data.Add(v);
            _s.Add(e);
            return e.idx;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(T v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
T v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            InternElement e = new();
            e.hash = v.GetHashCode();
            e.idx = -1;
            CheckItem = v;
            if (_s.TryGetValue(e, out var rE))
                return rE.idx;
            e.idx = _data.Count;
            _data.Add(v);
            _s.Add(e);
            return e.idx;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
InternElement e = new();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
InternElement e = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
InternElement		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e.hash = v.GetHashCode();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.hash = v.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.hash		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
hash		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v.GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e.idx = -1;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.idx = -1		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
CheckItem = v;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
CheckItem = v		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
CheckItem		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (_s.TryGetValue(e, out var rE))
                return rE.idx;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_s.TryGetValue(e, out var rE)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_s.TryGetValue		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TryGetValue		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(e, out var rE)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out var rE		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
var rE		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
rE		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
return rE.idx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
rE.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
rE		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
e.idx = _data.Count;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
e.idx = _data.Count		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
e.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_data.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_data.Add(v);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_data.Add(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_data.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_s.Add(e);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_s.Add(e)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_s.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(e)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return e.idx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
e.idx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using runtime.core;

namespace runtime.Utils
{
    public unsafe class UnsafeStream
    {
        internal byte[] _items;
        internal int _size;
        internal byte* ptr;
        public int Count => _size;

        public UnsafeStream(int initCapacity = 4)
        {
            //Does not Free Handle
            _items = Array.Empty<byte>();
            _size = 0;
            Capacity = initCapacity;
        }

        public UnsafeStream(byte[] items)
        {
            _items = items;
            _size = items.Length;
        }

        public int Capacity
        {
            get => _items.Length;
            set => ptr = Resize(value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected byte* Resize(int value)
        {
            if (value < _size)
                throw new JuliaException("Index to Small!");
            if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }

            return ptr;
        }

        public T[] ReadArray<T>(int idx) where T : unmanaged
        {
            T[] v = new T[Read<int>(idx)];
            idx += sizeof(int);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
            return v;
        }

        public T* WriteArray<T>(T[] v, out int aptr) where T : unmanaged
        {
            var p = WriteArray<T>(v.Length, out aptr);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
            return p;
        }

        public T* WriteArray<T>(int size, out int aptr) where T : unmanaged
        {
            var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));
            *p++ = size;
            return (T*) p;
        }

        public int WriteList<T>(UnsafeList<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));
            return aptr;
        }

        public int WriteList<T>(List<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];
            return aptr;
        }

        public T* WritePtr<T>(int nel, out int pptr, int pad = 0) where T : unmanaged {
            pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);
            return (T*)(pptr + ptr);
        }

        public int Write<T>(ref T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        public int Write<T>(T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        protected int EnsureSizeWrite(int size)
        {
            byte[] array = _items;
            if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }

            var loc = _size;
            _size = size;
            return loc;
        }

        public byte[] ToByteArray() {
            var bytes = new byte[Count];
            fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);
            return bytes;
        }

        public byte* GetDataPointer(int idx) => ptr + idx;

        public ref T Read<T>() where T : unmanaged => ref Read<T>(_size);
        public ref T Read<T>(int idx) where T : unmanaged => ref Unsafe.AsRef<T>(ptr + idx);
        public byte* GetDataPointer() => ptr;
        public void SetCount(int p) => _size = p;
    }

   

    public class UnsafeList<T> : UnsafeStream, IList<T> where T : unmanaged
    {
        public UnsafeList() : base(sizeof(int)) => Write<int>(0);

        public IEnumerator<T> GetEnumerator() => throw new NotImplementedException();
        IEnumerator IEnumerable.GetEnumerator() => throw new NotImplementedException();

        public void Add(T item) =>  Write(item);
        public void Clear() => Capacity = 0;
        public bool Contains(T item) => throw new NotImplementedException();
        public void CopyTo(T[] array, int arrayIndex) => throw new NotImplementedException();
        public bool Remove(T item) => throw new NotImplementedException();
        public bool IsReadOnly => false;
        public int IndexOf(T item) => throw new NotImplementedException();
        public void Insert(int index, T item) => throw new NotImplementedException();
        public void RemoveAt(int index) => throw new NotImplementedException();
        public void PopLast() => Capacity--;

        public T this[int index]
        {
            get => Read<T>(index + sizeof(int));
            set => Read<T>(index + sizeof(int)) = value;
        }

        public ref T GetRef(int index) => ref Read<T>(index + sizeof(int));
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Collections;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Collections		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Collections		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Collections.Generic;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Collections.Generic		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Collections		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Collections		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Generic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Runtime.CompilerServices;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Runtime.CompilerServices		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompilerServices		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.Utils
{
    public unsafe class UnsafeStream
    {
        internal byte[] _items;
        internal int _size;
        internal byte* ptr;
        public int Count => _size;

        public UnsafeStream(int initCapacity = 4)
        {
            //Does not Free Handle
            _items = Array.Empty<byte>();
            _size = 0;
            Capacity = initCapacity;
        }

        public UnsafeStream(byte[] items)
        {
            _items = items;
            _size = items.Length;
        }

        public int Capacity
        {
            get => _items.Length;
            set => ptr = Resize(value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected byte* Resize(int value)
        {
            if (value < _size)
                throw new JuliaException("Index to Small!");
            if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }

            return ptr;
        }

        public T[] ReadArray<T>(int idx) where T : unmanaged
        {
            T[] v = new T[Read<int>(idx)];
            idx += sizeof(int);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
            return v;
        }

        public T* WriteArray<T>(T[] v, out int aptr) where T : unmanaged
        {
            var p = WriteArray<T>(v.Length, out aptr);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
            return p;
        }

        public T* WriteArray<T>(int size, out int aptr) where T : unmanaged
        {
            var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));
            *p++ = size;
            return (T*) p;
        }

        public int WriteList<T>(UnsafeList<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));
            return aptr;
        }

        public int WriteList<T>(List<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];
            return aptr;
        }

        public T* WritePtr<T>(int nel, out int pptr, int pad = 0) where T : unmanaged {
            pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);
            return (T*)(pptr + ptr);
        }

        public int Write<T>(ref T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        public int Write<T>(T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        protected int EnsureSizeWrite(int size)
        {
            byte[] array = _items;
            if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }

            var loc = _size;
            _size = size;
            return loc;
        }

        public byte[] ToByteArray() {
            var bytes = new byte[Count];
            fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);
            return bytes;
        }

        public byte* GetDataPointer(int idx) => ptr + idx;

        public ref T Read<T>() where T : unmanaged => ref Read<T>(_size);
        public ref T Read<T>(int idx) where T : unmanaged => ref Unsafe.AsRef<T>(ptr + idx);
        public byte* GetDataPointer() => ptr;
        public void SetCount(int p) => _size = p;
    }

   

    public class UnsafeList<T> : UnsafeStream, IList<T> where T : unmanaged
    {
        public UnsafeList() : base(sizeof(int)) => Write<int>(0);

        public IEnumerator<T> GetEnumerator() => throw new NotImplementedException();
        IEnumerator IEnumerable.GetEnumerator() => throw new NotImplementedException();

        public void Add(T item) =>  Write(item);
        public void Clear() => Capacity = 0;
        public bool Contains(T item) => throw new NotImplementedException();
        public void CopyTo(T[] array, int arrayIndex) => throw new NotImplementedException();
        public bool Remove(T item) => throw new NotImplementedException();
        public bool IsReadOnly => false;
        public int IndexOf(T item) => throw new NotImplementedException();
        public void Insert(int index, T item) => throw new NotImplementedException();
        public void RemoveAt(int index) => throw new NotImplementedException();
        public void PopLast() => Capacity--;

        public T this[int index]
        {
            get => Read<T>(index + sizeof(int));
            set => Read<T>(index + sizeof(int)) = value;
        }

        public ref T GetRef(int index) => ref Read<T>(index + sizeof(int));
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.Utils		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Utils		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public unsafe class UnsafeStream
    {
        internal byte[] _items;
        internal int _size;
        internal byte* ptr;
        public int Count => _size;

        public UnsafeStream(int initCapacity = 4)
        {
            //Does not Free Handle
            _items = Array.Empty<byte>();
            _size = 0;
            Capacity = initCapacity;
        }

        public UnsafeStream(byte[] items)
        {
            _items = items;
            _size = items.Length;
        }

        public int Capacity
        {
            get => _items.Length;
            set => ptr = Resize(value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected byte* Resize(int value)
        {
            if (value < _size)
                throw new JuliaException("Index to Small!");
            if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }

            return ptr;
        }

        public T[] ReadArray<T>(int idx) where T : unmanaged
        {
            T[] v = new T[Read<int>(idx)];
            idx += sizeof(int);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
            return v;
        }

        public T* WriteArray<T>(T[] v, out int aptr) where T : unmanaged
        {
            var p = WriteArray<T>(v.Length, out aptr);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
            return p;
        }

        public T* WriteArray<T>(int size, out int aptr) where T : unmanaged
        {
            var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));
            *p++ = size;
            return (T*) p;
        }

        public int WriteList<T>(UnsafeList<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));
            return aptr;
        }

        public int WriteList<T>(List<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];
            return aptr;
        }

        public T* WritePtr<T>(int nel, out int pptr, int pad = 0) where T : unmanaged {
            pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);
            return (T*)(pptr + ptr);
        }

        public int Write<T>(ref T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        public int Write<T>(T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }

        protected int EnsureSizeWrite(int size)
        {
            byte[] array = _items;
            if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }

            var loc = _size;
            _size = size;
            return loc;
        }

        public byte[] ToByteArray() {
            var bytes = new byte[Count];
            fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);
            return bytes;
        }

        public byte* GetDataPointer(int idx) => ptr + idx;

        public ref T Read<T>() where T : unmanaged => ref Read<T>(_size);
        public ref T Read<T>(int idx) where T : unmanaged => ref Unsafe.AsRef<T>(ptr + idx);
        public byte* GetDataPointer() => ptr;
        public void SetCount(int p) => _size = p;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
internal byte[] _items;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte[] _items		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal int _size;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int _size		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal byte* ptr;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte* ptr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public int Count => _size;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _size		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public UnsafeStream(int initCapacity = 4)
        {
            //Does not Free Handle
            _items = Array.Empty<byte>();
            _size = 0;
            Capacity = initCapacity;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(int initCapacity = 4)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int initCapacity = 4		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= 4		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
            //Does not Free Handle
            _items = Array.Empty<byte>();
            _size = 0;
            Capacity = initCapacity;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_items = Array.Empty<byte>();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_items = Array.Empty<byte>()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Array.Empty<byte>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Array.Empty<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Empty<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_size = 0;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_size = 0		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Capacity = initCapacity;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Capacity = initCapacity		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Capacity		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
initCapacity		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public UnsafeStream(byte[] items)
        {
            _items = items;
            _size = items.Length;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(byte[] items)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
byte[] items		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{
            _items = items;
            _size = items.Length;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_items = items;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_items = items		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_size = items.Length;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_size = items.Length		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
items.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int Capacity
        {
            get => _items.Length;
            set => ptr = Resize(value);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
            get => _items.Length;
            set => ptr = Resize(value);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get => _items.Length;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
=> _items.Length		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_items.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
set => ptr = Resize(value);		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
=> ptr = Resize(value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ptr = Resize(value)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Resize(value)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Resize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected byte* Resize(int value)
        {
            if (value < _size)
                throw new JuliaException("Index to Small!");
            if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }

            return ptr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
MethodImpl(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
MethodImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodImplOptions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int value)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int value		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
            if (value < _size)
                throw new JuliaException("Index to Small!");
            if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }

            return ptr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (value < _size)
                throw new JuliaException("Index to Small!");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
value < _size		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
throw new JuliaException("Index to Small!");		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new JuliaException("Index to Small!")		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Index to Small!")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Index to Small!"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Index to Small!"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (value != _items.Length)
            {
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
value != _items.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_items.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }

                _items = Array.Empty<byte>();
                _size = 0;
                return null;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (value > 0)
                {
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
value > 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
                    byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);
                    if (_size > 0)
                        Array.Copy(_items, newItems, _size);
                    _items = newItems;
                    fixed (byte* bptr = newItems)
                        return bptr;
                }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
byte[] newItems = GC.AllocateUninitializedArray<byte>(value, true)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
newItems = GC.AllocateUninitializedArray<byte>(value, true)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= GC.AllocateUninitializedArray<byte>(value, true)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
GC.AllocateUninitializedArray<byte>(value, true)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GC.AllocateUninitializedArray<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
GC		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AllocateUninitializedArray<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(value, true)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_size > 0)
                        Array.Copy(_items, newItems, _size);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_size > 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Array.Copy(_items, newItems, _size);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Array.Copy(_items, newItems, _size)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Array.Copy		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Copy		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_items, newItems, _size)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
newItems		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
newItems		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_items = newItems;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_items = newItems		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
newItems		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
fixed (byte* bptr = newItems)
                        return bptr;		Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax
byte* bptr = newItems		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
bptr = newItems		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= newItems		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
newItems		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return bptr;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
bptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_items = Array.Empty<byte>();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_items = Array.Empty<byte>()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Array.Empty<byte>()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Array.Empty<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Empty<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<byte>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_size = 0;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_size = 0		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return null;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return ptr;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public T[] ReadArray<T>(int idx) where T : unmanaged
        {
            T[] v = new T[Read<int>(idx)];
            idx += sizeof(int);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
            return v;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
T[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(int idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int idx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            T[] v = new T[Read<int>(idx)];
            idx += sizeof(int);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);
            return v;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
T[] v = new T[Read<int>(idx)];		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
T[] v = new T[Read<int>(idx)]		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
T[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
v = new T[Read<int>(idx)]		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new T[Read<int>(idx)]		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new T[Read<int>(idx)]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax
T[Read<int>(idx)]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[Read<int>(idx)]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
Read<int>(idx)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Read<int>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<int>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx += sizeof(int);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
idx += sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
fixed (T* dptr = v)
                Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);		Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax
T* dptr = v		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
T*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
dptr = v		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= v		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Unsafe.CopyBlock(dptr, (T*)(ptr + idx), (uint)v.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Unsafe.CopyBlock		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Unsafe		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CopyBlock		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(dptr, (T*)(ptr + idx), (uint)v.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
dptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
dptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(T*)(ptr + idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(T*)(ptr + idx)		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
T*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ptr + idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
ptr + idx		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(uint)v.Length		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(uint)v.Length		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
uint		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
v.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return v;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public T* WriteArray<T>(T[] v, out int aptr) where T : unmanaged
        {
            var p = WriteArray<T>(v.Length, out aptr);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
            return p;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
T*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(T[] v, out int aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
T[] v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
out int aptr		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            var p = WriteArray<T>(v.Length, out aptr);
            fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));
            return p;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var p = WriteArray<T>(v.Length, out aptr);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var p = WriteArray<T>(v.Length, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
p = WriteArray<T>(v.Length, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= WriteArray<T>(v.Length, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
WriteArray<T>(v.Length, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
WriteArray<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v.Length, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v.Length		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out aptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
fixed (T* dptr = v)
                Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));		Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax
T* dptr = v		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
T*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
dptr = v		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= v		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Unsafe.CopyBlock(p, dptr, (uint)(sizeof(T) * v.Length))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Unsafe.CopyBlock		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Unsafe		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CopyBlock		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(p, dptr, (uint)(sizeof(T) * v.Length))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
dptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
dptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(uint)(sizeof(T) * v.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(uint)(sizeof(T) * v.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
uint		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(sizeof(T) * v.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
sizeof(T) * v.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
sizeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return p;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public T* WriteArray<T>(int size, out int aptr) where T : unmanaged
        {
            var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));
            *p++ = size;
            return (T*) p;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
T*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(int size, out int aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int size		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out int aptr		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));
            *p++ = size;
            return (T*) p;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var p = (int*) WritePtr<T>(size, out aptr, sizeof(int));		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var p = (int*) WritePtr<T>(size, out aptr, sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
p = (int*) WritePtr<T>(size, out aptr, sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= (int*) WritePtr<T>(size, out aptr, sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
(int*) WritePtr<T>(size, out aptr, sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
int*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
WritePtr<T>(size, out aptr, sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
WritePtr<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(size, out aptr, sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
size		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out aptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
*p++ = size;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
*p++ = size		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
*p++		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
p++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return (T*) p;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
(T*) p		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
T*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int WriteList<T>(UnsafeList<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));
            return aptr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(UnsafeList<T> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
UnsafeList<T> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
UnsafeList<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));
            return aptr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
int aptr;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int aptr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
var p = WriteArray<T>(v.Count, out aptr);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var p = WriteArray<T>(v.Count, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
p = WriteArray<T>(v.Count, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= WriteArray<T>(v.Count, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
WriteArray<T>(v.Count, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
WriteArray<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v.Count, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v.Count		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out aptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Unsafe.CopyBlock(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Unsafe.CopyBlock		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Unsafe		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CopyBlock		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(p, v.GetDataPointer(sizeof(int)), (uint)(v.Count * sizeof(T)))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v.GetDataPointer(sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v.GetDataPointer(sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v.GetDataPointer		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetDataPointer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(uint)(v.Count * sizeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(uint)(v.Count * sizeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
uint		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(v.Count * sizeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
v.Count * sizeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
v.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sizeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return aptr;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int WriteList<T>(List<T> v) where T : unmanaged
        {
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];
            return aptr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(List<T> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
List<T> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
List<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            int aptr;
            var p = WriteArray<T>(v.Count, out aptr);
            for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];
            return aptr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
int aptr;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int aptr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
var p = WriteArray<T>(v.Count, out aptr);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var p = WriteArray<T>(v.Count, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
p = WriteArray<T>(v.Count, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= WriteArray<T>(v.Count, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
WriteArray<T>(v.Count, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
WriteArray<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v.Count, out aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v.Count		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out aptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
for (int i = 0, n = v.Count; i < n; i++)
                p[i] = v[i];		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0, n = v.Count		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
n = v.Count		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= v.Count		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
v.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i < n		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
n		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
p[i] = v[i];		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
p[i] = v[i]		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
p[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return aptr;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public T* WritePtr<T>(int nel, out int pptr, int pad = 0) where T : unmanaged {
            pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);
            return (T*)(pptr + ptr);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
T*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(int nel, out int pptr, int pad = 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int nel		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out int pptr		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
int pad = 0		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);
            return (T*)(pptr + ptr);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
pptr = EnsureSizeWrite(_size + sizeof(T) * nel + pad)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
pptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EnsureSizeWrite(_size + sizeof(T) * nel + pad)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
EnsureSizeWrite		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_size + sizeof(T) * nel + pad)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_size + sizeof(T) * nel + pad		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_size + sizeof(T) * nel + pad		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_size + sizeof(T) * nel		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sizeof(T) * nel		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
sizeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
nel		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
pad		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return (T*)(pptr + ptr);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
(T*)(pptr + ptr)		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
T*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(pptr + ptr)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
pptr + ptr		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
pptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int Write<T>(ref T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(ref T v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ref T v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
*WritePtr<T>(1, out int aptr) = v;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
*WritePtr<T>(1, out int aptr) = v		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
*WritePtr<T>(1, out int aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
WritePtr<T>(1, out int aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
WritePtr<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1, out int aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
out int aptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
int aptr		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return aptr;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int Write<T>(T v) where T : unmanaged {
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(T v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
T v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            *WritePtr<T>(1, out int aptr) = v;
            return aptr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
*WritePtr<T>(1, out int aptr) = v;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
*WritePtr<T>(1, out int aptr) = v		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
*WritePtr<T>(1, out int aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
WritePtr<T>(1, out int aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
WritePtr<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(1, out int aptr)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
out int aptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
int aptr		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return aptr;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
aptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
protected int EnsureSizeWrite(int size)
        {
            byte[] array = _items;
            if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }

            var loc = _size;
            _size = size;
            return loc;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int size)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int size		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
            byte[] array = _items;
            if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }

            var loc = _size;
            _size = size;
            return loc;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
byte[] array = _items;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
byte[] array = _items		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
array = _items		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= _items		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if ((uint)size >= (uint)array.Length) {
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
(uint)size >= (uint)array.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(uint)size		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
uint		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(uint)array.Length		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
uint		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
array.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                int min = size + 1;
                if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
int min = size + 1;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int min = size + 1		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
min = size + 1		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= size + 1		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
size + 1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (_items.Length < min)
                {
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_items.Length < min		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_items.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
min		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                    int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;
                    if (newCapacity < min)
                        newCapacity = min;
                    Capacity = newCapacity;
                }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
int newCapacity = _items.Length == 0 ? 4 : _items.Length * 2		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
newCapacity = _items.Length == 0 ? 4 : _items.Length * 2		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= _items.Length == 0 ? 4 : _items.Length * 2		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
_items.Length == 0 ? 4 : _items.Length * 2		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
_items.Length == 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_items.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_items.Length * 2		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_items.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_items		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (newCapacity < min)
                        newCapacity = min;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
newCapacity < min		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
newCapacity		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
min		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
newCapacity = min;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
newCapacity = min		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
newCapacity		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
min		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Capacity = newCapacity;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Capacity = newCapacity		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Capacity		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
newCapacity		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var loc = _size;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var loc = _size		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
loc = _size		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= _size		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_size = size;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_size = size		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return loc;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
loc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public byte[] ToByteArray() {
            var bytes = new byte[Count];
            fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);
            return bytes;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
            var bytes = new byte[Count];
            fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);
            return bytes;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var bytes = new byte[Count];		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var bytes = new byte[Count]		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bytes = new byte[Count]		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new byte[Count]		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new byte[Count]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax
byte[Count]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[Count]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
fixed(byte* dest = bytes)
                Unsafe.CopyBlock(dest, ptr, (uint) Count);		Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax
byte* dest = bytes		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
dest = bytes		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= bytes		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
bytes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Unsafe.CopyBlock(dest, ptr, (uint) Count);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Unsafe.CopyBlock(dest, ptr, (uint) Count)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Unsafe.CopyBlock		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Unsafe		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CopyBlock		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(dest, ptr, (uint) Count)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
dest		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
dest		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(uint) Count		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(uint) Count		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
uint		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return bytes;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
bytes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public byte* GetDataPointer(int idx) => ptr + idx;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int idx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> ptr + idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ptr + idx		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public ref T Read<T>() where T : unmanaged => ref Read<T>(_size);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ref T		Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> ref Read<T>(_size)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ref Read<T>(_size)		Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax
Read<T>(_size)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Read<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_size)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public ref T Read<T>(int idx) where T : unmanaged => ref Unsafe.AsRef<T>(ptr + idx);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ref T		Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(int idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int idx		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> ref Unsafe.AsRef<T>(ptr + idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ref Unsafe.AsRef<T>(ptr + idx)		Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax
Unsafe.AsRef<T>(ptr + idx)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Unsafe.AsRef<T>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Unsafe		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AsRef<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ptr + idx)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ptr + idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ptr + idx		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public byte* GetDataPointer() => ptr;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> ptr		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ptr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void SetCount(int p) => _size = p;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int p)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int p		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _size = p		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_size = p		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class UnsafeList<T> : UnsafeStream, IList<T> where T : unmanaged
    {
        public UnsafeList() : base(sizeof(int)) => Write<int>(0);

        public IEnumerator<T> GetEnumerator() => throw new NotImplementedException();
        IEnumerator IEnumerable.GetEnumerator() => throw new NotImplementedException();

        public void Add(T item) =>  Write(item);
        public void Clear() => Capacity = 0;
        public bool Contains(T item) => throw new NotImplementedException();
        public void CopyTo(T[] array, int arrayIndex) => throw new NotImplementedException();
        public bool Remove(T item) => throw new NotImplementedException();
        public bool IsReadOnly => false;
        public int IndexOf(T item) => throw new NotImplementedException();
        public void Insert(int index, T item) => throw new NotImplementedException();
        public void RemoveAt(int index) => throw new NotImplementedException();
        public void PopLast() => Capacity--;

        public T this[int index]
        {
            get => Read<T>(index + sizeof(int));
            set => Read<T>(index + sizeof(int)) = value;
        }

        public ref T GetRef(int index) => ref Read<T>(index + sizeof(int));
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
: UnsafeStream, IList<T>		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
UnsafeStream		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
UnsafeStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IList<T>		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IList<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public UnsafeList() : base(sizeof(int)) => Write<int>(0);		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
: base(sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Write<int>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Write<int>(0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Write<int>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<int>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public IEnumerator<T> GetEnumerator() => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IEnumerator<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
IEnumerator IEnumerable.GetEnumerator() => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IEnumerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IEnumerable.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IEnumerable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public void Add(T item) =>  Write(item);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(T item)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
T item		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=>  Write(item)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Write(item)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(item)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
item		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
item		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Clear() => Capacity = 0;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Capacity = 0		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Capacity = 0		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Capacity		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public bool Contains(T item) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(T item)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
T item		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public void CopyTo(T[] array, int arrayIndex) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(T[] array, int arrayIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
T[] array		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
int arrayIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public bool Remove(T item) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(T item)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
T item		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public bool IsReadOnly => false;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> false		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public int IndexOf(T item) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(T item)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
T item		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public void Insert(int index, T item) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int index, T item)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int index		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
T item		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public void RemoveAt(int index) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int index)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int index		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public void PopLast() => Capacity--;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Capacity--		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Capacity--		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
Capacity		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public T this[int index]
        {
            get => Read<T>(index + sizeof(int));
            set => Read<T>(index + sizeof(int)) = value;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[int index]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax
int index		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
            get => Read<T>(index + sizeof(int));
            set => Read<T>(index + sizeof(int)) = value;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get => Read<T>(index + sizeof(int));		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
=> Read<T>(index + sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Read<T>(index + sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Read<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(index + sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
index + sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
index + sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
index		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
set => Read<T>(index + sizeof(int)) = value;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
=> Read<T>(index + sizeof(int)) = value		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Read<T>(index + sizeof(int)) = value		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Read<T>(index + sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Read<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(index + sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
index + sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
index + sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
index		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public ref T GetRef(int index) => ref Read<T>(index + sizeof(int));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
ref T		Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int index)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int index		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> ref Read<T>(index + sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ref Read<T>(index + sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax
Read<T>(index + sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Read<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(index + sizeof(int))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
index + sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
index + sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
index		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sizeof(int)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
using System.IO;
using runtime.core.Runtime;

namespace runtime.core
{
    public class Julia {
        public static JRootModule MAIN = JRootModule.CreateRootModule("Main");
        public static JRootModule BASE = JRootModule.CreateRootModule("Base");

        public static JRuntimeExpr EvalToExpression(string s) => MAIN.EvalToExpression(s);
       // public static object Eval(string s) => MAIN.Eval(s);
      //  public static object Eval(FileInfo file) => MAIN.Eval(file);
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System.IO;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.IO		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IO		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.Runtime;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core
{
    public class Julia {
        public static JRootModule MAIN = JRootModule.CreateRootModule("Main");
        public static JRootModule BASE = JRootModule.CreateRootModule("Base");

        public static JRuntimeExpr EvalToExpression(string s) => MAIN.EvalToExpression(s);
       // public static object Eval(string s) => MAIN.Eval(s);
      //  public static object Eval(FileInfo file) => MAIN.Eval(file);
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class Julia {
        public static JRootModule MAIN = JRootModule.CreateRootModule("Main");
        public static JRootModule BASE = JRootModule.CreateRootModule("Base");

        public static JRuntimeExpr EvalToExpression(string s) => MAIN.EvalToExpression(s);
       // public static object Eval(string s) => MAIN.Eval(s);
      //  public static object Eval(FileInfo file) => MAIN.Eval(file);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
public static JRootModule MAIN = JRootModule.CreateRootModule("Main");		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JRootModule MAIN = JRootModule.CreateRootModule("Main")		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MAIN = JRootModule.CreateRootModule("Main")		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= JRootModule.CreateRootModule("Main")		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
JRootModule.CreateRootModule("Main")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
JRootModule.CreateRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CreateRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Main")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Main"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Main"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static JRootModule BASE = JRootModule.CreateRootModule("Base");		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JRootModule BASE = JRootModule.CreateRootModule("Base")		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
BASE = JRootModule.CreateRootModule("Base")		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= JRootModule.CreateRootModule("Base")		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
JRootModule.CreateRootModule("Base")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
JRootModule.CreateRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CreateRootModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Base")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Base"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Base"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static JRuntimeExpr EvalToExpression(string s) => MAIN.EvalToExpression(s);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JRuntimeExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string s)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string s		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> MAIN.EvalToExpression(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
MAIN.EvalToExpression(s)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
MAIN.EvalToExpression		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MAIN		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EvalToExpression		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using runtime.core;

namespace runtime.ILCompiler
{
    public struct IlExprBuilder
    {
        private readonly ILGenerator _il;
        private readonly object _internalMethod;

        #region BuilderExtensions

        public struct ILFunctionExprBuilder
        {
            private readonly IlExprBuilder _eb;

            internal ILFunctionExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Invoke<T>(string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod<T>(name, parameters));

            public void Invoke(Type t, string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod(t, name, parameters));

            public void Invoke<T>(params Type[] parameters) => Invoke(SharpReflect.GetConstructor<T>(parameters));
            public void Invoke(Type t, params Type[] parameters) => Invoke(SharpReflect.GetConstructor(t, parameters));

            public void Invoke(MethodInfo info) =>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null);

            public void Invoke(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)
            {
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }

            public void Invoke(ConstructorInfo ci) => _eb._il.Emit(OpCodes.Newobj, ci);

            public void Println(string s) => _eb._il.EmitWriteLine(s);
        }

        public struct ILLoadExprBuilder
        {
            private static readonly MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle");

            private readonly IlExprBuilder _eb;
            internal ILLoadExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Arg(uint i)
            {
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }

            public void String(string str) => _eb._il.Emit(OpCodes.Ldstr, str);
            public void Bool(bool b) => _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
            public void Int64(Int64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void Int32(Int32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void Int16(Int16 v) => Int32(v);
            public void Int8(sbyte v) => Int32(v);
            public void UInt64(UInt64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void UInt32(UInt32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void UInt16(UInt16 v) => UInt32(v);
            public void UInt8(byte v) => UInt32(v);
            public void Float32(float v) => _eb._il.Emit(OpCodes.Ldc_R4, v);
            public void Float64(double v) => _eb._il.Emit(OpCodes.Ldc_R8, v);

            public void Type(System.Type t)
            {
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }

            public void FieldValue(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f);
            public void FieldValue(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb);

            public void FieldAddr(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f);
            public void FieldAddr(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb);

            public void OptFloat(double v)
            {
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }

            public void OptInt(Int64 v)
            {
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }

            public void OptUInt(UInt64 v)
            {
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }

            public void Const(UInt64 v) => OptUInt(v);
            public void Const(Int64 v) => OptInt(v);
            public void Const(double v) => OptFloat(v);
            public void Const(string s) => String(s);
            public void Const(bool b) => Bool(b);
            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Ldloc, lb);

            public void FromPointerInt8() => _eb.Emit(OpCodes.Ldind_I1);
            public void FromPointerInt16() => _eb.Emit(OpCodes.Ldind_I2);
            public void FromPointerInt32() => _eb.Emit(OpCodes.Ldind_I4);
            public void FromPointerInt64() => _eb.Emit(OpCodes.Ldind_I8);
            public void FromPointerFloat32() => _eb.Emit(OpCodes.Ldind_R4);
            public void FromPointerFloat64() => _eb.Emit(OpCodes.Ldind_R8);
            public void FromPointerRef() => _eb.Emit(OpCodes.Ldind_Ref);

            public void FromPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILStoreExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILStoreExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Field(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f);
            public void Field(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb);

            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Stloc, lb);

            public void ToPointerInt8() => _eb.Emit(OpCodes.Stind_I1);
            public void ToPointerInt16() => _eb.Emit(OpCodes.Stind_I2);
            public void ToPointerInt32() => _eb.Emit(OpCodes.Stind_I4);
            public void ToPointerInt64() => _eb.Emit(OpCodes.Stind_I8);
            public void ToPointerFloat32() => _eb.Emit(OpCodes.Stind_R4);
            public void ToPointerFloat64() => _eb.Emit(OpCodes.Stind_R8);
            public void ToPointerRef() => _eb.Emit(OpCodes.Stind_Ref);

            public void ToPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILCreateExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILCreateExprBuilder(IlExprBuilder eb) => _eb = eb;
            public LocalBuilder Local(Type t) => _eb._il.DeclareLocal(t);
            public LocalBuilder Local<T>() => Local(typeof(T));

            public LocalBuilder LocalAndStore(Type t)
            {
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }

            public LocalBuilder LocalAndStore<T>() => LocalAndStore(typeof(T));

            public void Object(ConstructorInfo ci) => _eb.Function.Invoke(ci);
            public void Object(IlExprBuilder cb) => _eb.Function.Invoke(cb, true);
            public void Object<T>(params Type[] parameters) => _eb.Function.Invoke<T>(parameters);
            public void Object(Type t, params Type[] parameters) => _eb.Function.Invoke(t, parameters);
        }

        public struct ILArrayExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILArrayExprBuilder(IlExprBuilder eb) => _eb = eb;
        }

        public struct ILUnsafeExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILUnsafeExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void StackAlloc() => _eb._il.Emit(OpCodes.Localloc);

            public void StackAlloc(Type t, int size)
            {
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }

            public void StackAlloc<T>(int size) => StackAlloc(typeof(T), size);
            public void StoreToPointer(Type t) => _eb.Store.ToPointer(t);
            public void StoreToPointer<T>() => StoreToPointer(typeof(T));
            public void LoadFromPointer(Type t) => _eb.Load.FromPointer(t);
            public void LoadFromPointer<T>() => LoadFromPointer(typeof(T));

            public void CopyBlock(int numBytes)
            {
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }

            public void CopyBlock() => _eb._il.Emit(OpCodes.Cpblk);
        }

        #endregion

        #region BuilderExtensionImpl
        public ILFunctionExprBuilder Function => new(this);
        public ILLoadExprBuilder Load => new(this);
        public ILStoreExprBuilder Store => new(this);
        public ILCreateExprBuilder Create => new(this);
        public ILArrayExprBuilder Array => new(this);
        public ILUnsafeExprBuilder Unsafe => new(this);
        
        #endregion

        private IlExprBuilder(ILGenerator il, object internalMethod) {
            _il = il;
            _internalMethod = internalMethod;
        }

        public IlExprBuilder(MethodBuilder mb) : this(mb.GetILGenerator(), mb) {}

        public IlExprBuilder(ConstructorBuilder cb) : this(cb.GetILGenerator(), cb) {}
        
        #region HelperFunctions
        public void Emit(OpCode code) => _il.Emit(code);

        public void Return() => Emit(OpCodes.Ret);
        public void Add() => Emit(OpCodes.Add);
        public void Sub() => Emit(OpCodes.Sub);
        public void Duplicate() => Emit(OpCodes.Dup);
        public void Box(Type t) => _il.Emit(OpCodes.Box, t);
        public void Box<T>() => Box(typeof(T));

        public void ReturnVoid() {
            _il.Emit(OpCodes.Nop);
            Return();
        }

        public static IlExprBuilder CreateDynamicFunction(out DynamicMethod m, string name = "<Eval>")
        {
            m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);
            return new(m.GetILGenerator(), m);
        }
        
        #endregion
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Reflection;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Reflection.Emit;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Reflection.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Runtime.InteropServices;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Runtime.InteropServices		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
InteropServices		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.ILCompiler
{
    public struct IlExprBuilder
    {
        private readonly ILGenerator _il;
        private readonly object _internalMethod;

        #region BuilderExtensions

        public struct ILFunctionExprBuilder
        {
            private readonly IlExprBuilder _eb;

            internal ILFunctionExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Invoke<T>(string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod<T>(name, parameters));

            public void Invoke(Type t, string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod(t, name, parameters));

            public void Invoke<T>(params Type[] parameters) => Invoke(SharpReflect.GetConstructor<T>(parameters));
            public void Invoke(Type t, params Type[] parameters) => Invoke(SharpReflect.GetConstructor(t, parameters));

            public void Invoke(MethodInfo info) =>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null);

            public void Invoke(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)
            {
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }

            public void Invoke(ConstructorInfo ci) => _eb._il.Emit(OpCodes.Newobj, ci);

            public void Println(string s) => _eb._il.EmitWriteLine(s);
        }

        public struct ILLoadExprBuilder
        {
            private static readonly MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle");

            private readonly IlExprBuilder _eb;
            internal ILLoadExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Arg(uint i)
            {
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }

            public void String(string str) => _eb._il.Emit(OpCodes.Ldstr, str);
            public void Bool(bool b) => _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
            public void Int64(Int64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void Int32(Int32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void Int16(Int16 v) => Int32(v);
            public void Int8(sbyte v) => Int32(v);
            public void UInt64(UInt64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void UInt32(UInt32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void UInt16(UInt16 v) => UInt32(v);
            public void UInt8(byte v) => UInt32(v);
            public void Float32(float v) => _eb._il.Emit(OpCodes.Ldc_R4, v);
            public void Float64(double v) => _eb._il.Emit(OpCodes.Ldc_R8, v);

            public void Type(System.Type t)
            {
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }

            public void FieldValue(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f);
            public void FieldValue(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb);

            public void FieldAddr(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f);
            public void FieldAddr(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb);

            public void OptFloat(double v)
            {
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }

            public void OptInt(Int64 v)
            {
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }

            public void OptUInt(UInt64 v)
            {
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }

            public void Const(UInt64 v) => OptUInt(v);
            public void Const(Int64 v) => OptInt(v);
            public void Const(double v) => OptFloat(v);
            public void Const(string s) => String(s);
            public void Const(bool b) => Bool(b);
            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Ldloc, lb);

            public void FromPointerInt8() => _eb.Emit(OpCodes.Ldind_I1);
            public void FromPointerInt16() => _eb.Emit(OpCodes.Ldind_I2);
            public void FromPointerInt32() => _eb.Emit(OpCodes.Ldind_I4);
            public void FromPointerInt64() => _eb.Emit(OpCodes.Ldind_I8);
            public void FromPointerFloat32() => _eb.Emit(OpCodes.Ldind_R4);
            public void FromPointerFloat64() => _eb.Emit(OpCodes.Ldind_R8);
            public void FromPointerRef() => _eb.Emit(OpCodes.Ldind_Ref);

            public void FromPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILStoreExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILStoreExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Field(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f);
            public void Field(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb);

            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Stloc, lb);

            public void ToPointerInt8() => _eb.Emit(OpCodes.Stind_I1);
            public void ToPointerInt16() => _eb.Emit(OpCodes.Stind_I2);
            public void ToPointerInt32() => _eb.Emit(OpCodes.Stind_I4);
            public void ToPointerInt64() => _eb.Emit(OpCodes.Stind_I8);
            public void ToPointerFloat32() => _eb.Emit(OpCodes.Stind_R4);
            public void ToPointerFloat64() => _eb.Emit(OpCodes.Stind_R8);
            public void ToPointerRef() => _eb.Emit(OpCodes.Stind_Ref);

            public void ToPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILCreateExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILCreateExprBuilder(IlExprBuilder eb) => _eb = eb;
            public LocalBuilder Local(Type t) => _eb._il.DeclareLocal(t);
            public LocalBuilder Local<T>() => Local(typeof(T));

            public LocalBuilder LocalAndStore(Type t)
            {
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }

            public LocalBuilder LocalAndStore<T>() => LocalAndStore(typeof(T));

            public void Object(ConstructorInfo ci) => _eb.Function.Invoke(ci);
            public void Object(IlExprBuilder cb) => _eb.Function.Invoke(cb, true);
            public void Object<T>(params Type[] parameters) => _eb.Function.Invoke<T>(parameters);
            public void Object(Type t, params Type[] parameters) => _eb.Function.Invoke(t, parameters);
        }

        public struct ILArrayExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILArrayExprBuilder(IlExprBuilder eb) => _eb = eb;
        }

        public struct ILUnsafeExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILUnsafeExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void StackAlloc() => _eb._il.Emit(OpCodes.Localloc);

            public void StackAlloc(Type t, int size)
            {
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }

            public void StackAlloc<T>(int size) => StackAlloc(typeof(T), size);
            public void StoreToPointer(Type t) => _eb.Store.ToPointer(t);
            public void StoreToPointer<T>() => StoreToPointer(typeof(T));
            public void LoadFromPointer(Type t) => _eb.Load.FromPointer(t);
            public void LoadFromPointer<T>() => LoadFromPointer(typeof(T));

            public void CopyBlock(int numBytes)
            {
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }

            public void CopyBlock() => _eb._il.Emit(OpCodes.Cpblk);
        }

        #endregion

        #region BuilderExtensionImpl
        public ILFunctionExprBuilder Function => new(this);
        public ILLoadExprBuilder Load => new(this);
        public ILStoreExprBuilder Store => new(this);
        public ILCreateExprBuilder Create => new(this);
        public ILArrayExprBuilder Array => new(this);
        public ILUnsafeExprBuilder Unsafe => new(this);
        
        #endregion

        private IlExprBuilder(ILGenerator il, object internalMethod) {
            _il = il;
            _internalMethod = internalMethod;
        }

        public IlExprBuilder(MethodBuilder mb) : this(mb.GetILGenerator(), mb) {}

        public IlExprBuilder(ConstructorBuilder cb) : this(cb.GetILGenerator(), cb) {}
        
        #region HelperFunctions
        public void Emit(OpCode code) => _il.Emit(code);

        public void Return() => Emit(OpCodes.Ret);
        public void Add() => Emit(OpCodes.Add);
        public void Sub() => Emit(OpCodes.Sub);
        public void Duplicate() => Emit(OpCodes.Dup);
        public void Box(Type t) => _il.Emit(OpCodes.Box, t);
        public void Box<T>() => Box(typeof(T));

        public void ReturnVoid() {
            _il.Emit(OpCodes.Nop);
            Return();
        }

        public static IlExprBuilder CreateDynamicFunction(out DynamicMethod m, string name = "<Eval>")
        {
            m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);
            return new(m.GetILGenerator(), m);
        }
        
        #endregion
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.ILCompiler		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ILCompiler		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public struct IlExprBuilder
    {
        private readonly ILGenerator _il;
        private readonly object _internalMethod;

        #region BuilderExtensions

        public struct ILFunctionExprBuilder
        {
            private readonly IlExprBuilder _eb;

            internal ILFunctionExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Invoke<T>(string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod<T>(name, parameters));

            public void Invoke(Type t, string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod(t, name, parameters));

            public void Invoke<T>(params Type[] parameters) => Invoke(SharpReflect.GetConstructor<T>(parameters));
            public void Invoke(Type t, params Type[] parameters) => Invoke(SharpReflect.GetConstructor(t, parameters));

            public void Invoke(MethodInfo info) =>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null);

            public void Invoke(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)
            {
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }

            public void Invoke(ConstructorInfo ci) => _eb._il.Emit(OpCodes.Newobj, ci);

            public void Println(string s) => _eb._il.EmitWriteLine(s);
        }

        public struct ILLoadExprBuilder
        {
            private static readonly MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle");

            private readonly IlExprBuilder _eb;
            internal ILLoadExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Arg(uint i)
            {
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }

            public void String(string str) => _eb._il.Emit(OpCodes.Ldstr, str);
            public void Bool(bool b) => _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
            public void Int64(Int64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void Int32(Int32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void Int16(Int16 v) => Int32(v);
            public void Int8(sbyte v) => Int32(v);
            public void UInt64(UInt64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void UInt32(UInt32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void UInt16(UInt16 v) => UInt32(v);
            public void UInt8(byte v) => UInt32(v);
            public void Float32(float v) => _eb._il.Emit(OpCodes.Ldc_R4, v);
            public void Float64(double v) => _eb._il.Emit(OpCodes.Ldc_R8, v);

            public void Type(System.Type t)
            {
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }

            public void FieldValue(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f);
            public void FieldValue(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb);

            public void FieldAddr(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f);
            public void FieldAddr(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb);

            public void OptFloat(double v)
            {
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }

            public void OptInt(Int64 v)
            {
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }

            public void OptUInt(UInt64 v)
            {
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }

            public void Const(UInt64 v) => OptUInt(v);
            public void Const(Int64 v) => OptInt(v);
            public void Const(double v) => OptFloat(v);
            public void Const(string s) => String(s);
            public void Const(bool b) => Bool(b);
            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Ldloc, lb);

            public void FromPointerInt8() => _eb.Emit(OpCodes.Ldind_I1);
            public void FromPointerInt16() => _eb.Emit(OpCodes.Ldind_I2);
            public void FromPointerInt32() => _eb.Emit(OpCodes.Ldind_I4);
            public void FromPointerInt64() => _eb.Emit(OpCodes.Ldind_I8);
            public void FromPointerFloat32() => _eb.Emit(OpCodes.Ldind_R4);
            public void FromPointerFloat64() => _eb.Emit(OpCodes.Ldind_R8);
            public void FromPointerRef() => _eb.Emit(OpCodes.Ldind_Ref);

            public void FromPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILStoreExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILStoreExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Field(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f);
            public void Field(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb);

            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Stloc, lb);

            public void ToPointerInt8() => _eb.Emit(OpCodes.Stind_I1);
            public void ToPointerInt16() => _eb.Emit(OpCodes.Stind_I2);
            public void ToPointerInt32() => _eb.Emit(OpCodes.Stind_I4);
            public void ToPointerInt64() => _eb.Emit(OpCodes.Stind_I8);
            public void ToPointerFloat32() => _eb.Emit(OpCodes.Stind_R4);
            public void ToPointerFloat64() => _eb.Emit(OpCodes.Stind_R8);
            public void ToPointerRef() => _eb.Emit(OpCodes.Stind_Ref);

            public void ToPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }

        public struct ILCreateExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILCreateExprBuilder(IlExprBuilder eb) => _eb = eb;
            public LocalBuilder Local(Type t) => _eb._il.DeclareLocal(t);
            public LocalBuilder Local<T>() => Local(typeof(T));

            public LocalBuilder LocalAndStore(Type t)
            {
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }

            public LocalBuilder LocalAndStore<T>() => LocalAndStore(typeof(T));

            public void Object(ConstructorInfo ci) => _eb.Function.Invoke(ci);
            public void Object(IlExprBuilder cb) => _eb.Function.Invoke(cb, true);
            public void Object<T>(params Type[] parameters) => _eb.Function.Invoke<T>(parameters);
            public void Object(Type t, params Type[] parameters) => _eb.Function.Invoke(t, parameters);
        }

        public struct ILArrayExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILArrayExprBuilder(IlExprBuilder eb) => _eb = eb;
        }

        public struct ILUnsafeExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILUnsafeExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void StackAlloc() => _eb._il.Emit(OpCodes.Localloc);

            public void StackAlloc(Type t, int size)
            {
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }

            public void StackAlloc<T>(int size) => StackAlloc(typeof(T), size);
            public void StoreToPointer(Type t) => _eb.Store.ToPointer(t);
            public void StoreToPointer<T>() => StoreToPointer(typeof(T));
            public void LoadFromPointer(Type t) => _eb.Load.FromPointer(t);
            public void LoadFromPointer<T>() => LoadFromPointer(typeof(T));

            public void CopyBlock(int numBytes)
            {
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }

            public void CopyBlock() => _eb._il.Emit(OpCodes.Cpblk);
        }

        #endregion

        #region BuilderExtensionImpl
        public ILFunctionExprBuilder Function => new(this);
        public ILLoadExprBuilder Load => new(this);
        public ILStoreExprBuilder Store => new(this);
        public ILCreateExprBuilder Create => new(this);
        public ILArrayExprBuilder Array => new(this);
        public ILUnsafeExprBuilder Unsafe => new(this);
        
        #endregion

        private IlExprBuilder(ILGenerator il, object internalMethod) {
            _il = il;
            _internalMethod = internalMethod;
        }

        public IlExprBuilder(MethodBuilder mb) : this(mb.GetILGenerator(), mb) {}

        public IlExprBuilder(ConstructorBuilder cb) : this(cb.GetILGenerator(), cb) {}
        
        #region HelperFunctions
        public void Emit(OpCode code) => _il.Emit(code);

        public void Return() => Emit(OpCodes.Ret);
        public void Add() => Emit(OpCodes.Add);
        public void Sub() => Emit(OpCodes.Sub);
        public void Duplicate() => Emit(OpCodes.Dup);
        public void Box(Type t) => _il.Emit(OpCodes.Box, t);
        public void Box<T>() => Box(typeof(T));

        public void ReturnVoid() {
            _il.Emit(OpCodes.Nop);
            Return();
        }

        public static IlExprBuilder CreateDynamicFunction(out DynamicMethod m, string name = "<Eval>")
        {
            m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);
            return new(m.GetILGenerator(), m);
        }
        
        #endregion
    }		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
private readonly ILGenerator _il;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
ILGenerator _il		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ILGenerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private readonly object _internalMethod;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
object _internalMethod		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_internalMethod		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public struct ILFunctionExprBuilder
        {
            private readonly IlExprBuilder _eb;

            internal ILFunctionExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Invoke<T>(string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod<T>(name, parameters));

            public void Invoke(Type t, string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod(t, name, parameters));

            public void Invoke<T>(params Type[] parameters) => Invoke(SharpReflect.GetConstructor<T>(parameters));
            public void Invoke(Type t, params Type[] parameters) => Invoke(SharpReflect.GetConstructor(t, parameters));

            public void Invoke(MethodInfo info) =>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null);

            public void Invoke(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)
            {
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }

            public void Invoke(ConstructorInfo ci) => _eb._il.Emit(OpCodes.Newobj, ci);

            public void Println(string s) => _eb._il.EmitWriteLine(s);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
private readonly IlExprBuilder _eb;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IlExprBuilder _eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal ILFunctionExprBuilder(IlExprBuilder eb) => _eb = eb;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(IlExprBuilder eb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IlExprBuilder eb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Invoke<T>(string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod<T>(name, parameters));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(string name, params Type[] parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
params Type[] parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=>
                Invoke(SharpReflect.GetMethod<T>(name, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Invoke(SharpReflect.GetMethod<T>(name, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(SharpReflect.GetMethod<T>(name, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
SharpReflect.GetMethod<T>(name, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
SharpReflect.GetMethod<T>(name, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
SharpReflect.GetMethod<T>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
SharpReflect		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetMethod<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Invoke(Type t, string name, params Type[] parameters) =>
                Invoke(SharpReflect.GetMethod(t, name, parameters));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Type t, string name, params Type[] parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
params Type[] parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=>
                Invoke(SharpReflect.GetMethod(t, name, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Invoke(SharpReflect.GetMethod(t, name, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(SharpReflect.GetMethod(t, name, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
SharpReflect.GetMethod(t, name, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
SharpReflect.GetMethod(t, name, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
SharpReflect.GetMethod		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
SharpReflect		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t, name, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Invoke<T>(params Type[] parameters) => Invoke(SharpReflect.GetConstructor<T>(parameters));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(params Type[] parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
params Type[] parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=> Invoke(SharpReflect.GetConstructor<T>(parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Invoke(SharpReflect.GetConstructor<T>(parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(SharpReflect.GetConstructor<T>(parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
SharpReflect.GetConstructor<T>(parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
SharpReflect.GetConstructor<T>(parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
SharpReflect.GetConstructor<T>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
SharpReflect		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetConstructor<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Invoke(Type t, params Type[] parameters) => Invoke(SharpReflect.GetConstructor(t, parameters));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Type t, params Type[] parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
params Type[] parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=> Invoke(SharpReflect.GetConstructor(t, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Invoke(SharpReflect.GetConstructor(t, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(SharpReflect.GetConstructor(t, parameters))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
SharpReflect.GetConstructor(t, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
SharpReflect.GetConstructor(t, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
SharpReflect.GetConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
SharpReflect		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Invoke(MethodInfo info) =>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(MethodInfo info)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
MethodInfo info		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
MethodInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=>
                _eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.EmitCall(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.EmitCall		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EmitCall		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, info, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
info.IsVirtual ? OpCodes.Callvirt : OpCodes.Call		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
info.IsVirtual		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
info		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsVirtual		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Callvirt		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Callvirt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Call		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Call		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
info		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
info		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public void Invoke(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)
            {
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IlExprBuilder fb, bool requiresConstructor = false, bool requiresMethod = false)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IlExprBuilder fb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool requiresConstructor = false		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= false		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
bool requiresMethod = false		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= false		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
                if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (fb._internalMethod is MethodBuilder mb && !requiresConstructor)
                    Invoke(mb);
                else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
fb._internalMethod is MethodBuilder mb && !requiresConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
fb._internalMethod is MethodBuilder mb		Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax
fb._internalMethod		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_internalMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MethodBuilder mb		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax
MethodBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mb		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
!requiresConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
requiresConstructor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Invoke(mb);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Invoke(mb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(mb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
mb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (fb._internalMethod is ConstructorBuilder cb && !requiresMethod)
                    Invoke(cb);
                else throw new Exception("Unable To Invoke Unknown Internal Method!");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
fb._internalMethod is ConstructorBuilder cb && !requiresMethod		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
fb._internalMethod is ConstructorBuilder cb		Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax
fb._internalMethod		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_internalMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ConstructorBuilder cb		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax
ConstructorBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
cb		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
!requiresMethod		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
requiresMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Invoke(cb);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Invoke(cb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(cb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
cb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
cb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else throw new Exception("Unable To Invoke Unknown Internal Method!");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
throw new Exception("Unable To Invoke Unknown Internal Method!");		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new Exception("Unable To Invoke Unknown Internal Method!")		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
Exception		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Unable To Invoke Unknown Internal Method!")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Unable To Invoke Unknown Internal Method!"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Unable To Invoke Unknown Internal Method!"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public void Invoke(ConstructorInfo ci) => _eb._il.Emit(OpCodes.Newobj, ci);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(ConstructorInfo ci)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ConstructorInfo ci		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ConstructorInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(OpCodes.Newobj, ci)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Newobj, ci)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Newobj, ci)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Newobj		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Newobj		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Newobj		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ci		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ci		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Println(string s) => _eb._il.EmitWriteLine(s);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(string s)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string s		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _eb._il.EmitWriteLine(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.EmitWriteLine(s)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.EmitWriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EmitWriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public struct ILLoadExprBuilder
        {
            private static readonly MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle");

            private readonly IlExprBuilder _eb;
            internal ILLoadExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Arg(uint i)
            {
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }

            public void String(string str) => _eb._il.Emit(OpCodes.Ldstr, str);
            public void Bool(bool b) => _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
            public void Int64(Int64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void Int32(Int32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void Int16(Int16 v) => Int32(v);
            public void Int8(sbyte v) => Int32(v);
            public void UInt64(UInt64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);
            public void UInt32(UInt32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);
            public void UInt16(UInt16 v) => UInt32(v);
            public void UInt8(byte v) => UInt32(v);
            public void Float32(float v) => _eb._il.Emit(OpCodes.Ldc_R4, v);
            public void Float64(double v) => _eb._il.Emit(OpCodes.Ldc_R8, v);

            public void Type(System.Type t)
            {
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }

            public void FieldValue(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f);
            public void FieldValue(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb);

            public void FieldAddr(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f);
            public void FieldAddr(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb);

            public void OptFloat(double v)
            {
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }

            public void OptInt(Int64 v)
            {
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }

            public void OptUInt(UInt64 v)
            {
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }

            public void Const(UInt64 v) => OptUInt(v);
            public void Const(Int64 v) => OptInt(v);
            public void Const(double v) => OptFloat(v);
            public void Const(string s) => String(s);
            public void Const(bool b) => Bool(b);
            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Ldloc, lb);

            public void FromPointerInt8() => _eb.Emit(OpCodes.Ldind_I1);
            public void FromPointerInt16() => _eb.Emit(OpCodes.Ldind_I2);
            public void FromPointerInt32() => _eb.Emit(OpCodes.Ldind_I4);
            public void FromPointerInt64() => _eb.Emit(OpCodes.Ldind_I8);
            public void FromPointerFloat32() => _eb.Emit(OpCodes.Ldind_R4);
            public void FromPointerFloat64() => _eb.Emit(OpCodes.Ldind_R8);
            public void FromPointerRef() => _eb.Emit(OpCodes.Ldind_Ref);

            public void FromPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
private static readonly MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle");		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
MethodInfo GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle")		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
MethodInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GET_RUNTIME_TYPE = SharpReflect.GetMethod<Type>("GetTypeFromHandle")		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= SharpReflect.GetMethod<Type>("GetTypeFromHandle")		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
SharpReflect.GetMethod<Type>("GetTypeFromHandle")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
SharpReflect.GetMethod<Type>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
SharpReflect		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetMethod<Type>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<Type>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("GetTypeFromHandle")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"GetTypeFromHandle"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"GetTypeFromHandle"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
private readonly IlExprBuilder _eb;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IlExprBuilder _eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal ILLoadExprBuilder(IlExprBuilder eb) => _eb = eb;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(IlExprBuilder eb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IlExprBuilder eb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Arg(uint i)
            {
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(uint i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
uint i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
uint		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
                if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (i < 4)
                {
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }
                else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
i < 4		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
4		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
                    if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);
                }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (i == 0)
                        _eb.Emit(OpCodes.Ldarg_0);
                    else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
i == 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_eb.Emit(OpCodes.Ldarg_0);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_eb.Emit(OpCodes.Ldarg_0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldarg_0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldarg_0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldarg_0		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldarg_0		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (i == 1)
                        _eb.Emit(OpCodes.Ldarg_1);
                    else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
i == 1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_eb.Emit(OpCodes.Ldarg_1);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_eb.Emit(OpCodes.Ldarg_1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldarg_1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldarg_1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldarg_1		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldarg_1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (i == 2)
                        _eb.Emit(OpCodes.Ldarg_2);
                    else _eb.Emit(OpCodes.Ldarg_3);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
i == 2		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
2		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_eb.Emit(OpCodes.Ldarg_2);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_eb.Emit(OpCodes.Ldarg_2)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldarg_2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldarg_2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldarg_2		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldarg_2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else _eb.Emit(OpCodes.Ldarg_3);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
_eb.Emit(OpCodes.Ldarg_3);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_eb.Emit(OpCodes.Ldarg_3)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldarg_3)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldarg_3		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldarg_3		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldarg_3		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (i < 255)
                    _eb._il.Emit(OpCodes.Ldarg_S, i);
                else
                    _eb._il.Emit(OpCodes.Ldarg, i);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
i < 255		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
255		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
_eb._il.Emit(OpCodes.Ldarg_S, i);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_eb._il.Emit(OpCodes.Ldarg_S, i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldarg_S, i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldarg_S		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldarg_S		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldarg_S		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else
                    _eb._il.Emit(OpCodes.Ldarg, i);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
_eb._il.Emit(OpCodes.Ldarg, i);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_eb._il.Emit(OpCodes.Ldarg, i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldarg, i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldarg		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldarg		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldarg		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void String(string str) => _eb._il.Emit(OpCodes.Ldstr, str);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(string str)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string str		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _eb._il.Emit(OpCodes.Ldstr, str)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Ldstr, str)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldstr, str)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldstr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldstr		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldstr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
str		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
str		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Bool(bool b) => _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(bool b)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
bool b		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
b ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
b		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Ldc_I4_1		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldc_I4_1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Ldc_I4_0		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldc_I4_0		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Int64(Int64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Int64 v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Int64 v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Int64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(OpCodes.Ldc_I8, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Ldc_I8, v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldc_I8, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldc_I8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldc_I8		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldc_I8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Int32(Int32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Int32 v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Int32 v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(OpCodes.Ldc_I4, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Ldc_I4, v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldc_I4, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldc_I4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldc_I4		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldc_I4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Int16(Int16 v) => Int32(v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Int16 v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Int16 v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Int16		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Int32(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Int32(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Int8(sbyte v) => Int32(v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(sbyte v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
sbyte v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
sbyte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Int32(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Int32(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void UInt64(UInt64 v) => _eb._il.Emit(OpCodes.Ldc_I8, v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(UInt64 v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
UInt64 v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
UInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(OpCodes.Ldc_I8, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Ldc_I8, v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldc_I8, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldc_I8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldc_I8		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldc_I8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void UInt32(UInt32 v) => _eb._il.Emit(OpCodes.Ldc_I4, v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(UInt32 v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
UInt32 v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
UInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(OpCodes.Ldc_I4, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Ldc_I4, v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldc_I4, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldc_I4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldc_I4		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldc_I4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void UInt16(UInt16 v) => UInt32(v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(UInt16 v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
UInt16 v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
UInt16		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> UInt32(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
UInt32(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
UInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void UInt8(byte v) => UInt32(v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(byte v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
byte v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> UInt32(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
UInt32(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
UInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Float32(float v) => _eb._il.Emit(OpCodes.Ldc_R4, v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(float v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
float v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
float		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _eb._il.Emit(OpCodes.Ldc_R4, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Ldc_R4, v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldc_R4, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldc_R4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldc_R4		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldc_R4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Float64(double v) => _eb._il.Emit(OpCodes.Ldc_R8, v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(double v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
double v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
double		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _eb._il.Emit(OpCodes.Ldc_R8, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Ldc_R8, v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldc_R8, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldc_R8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldc_R8		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldc_R8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Type(System.Type t)
            {
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(System.Type t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
System.Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
System.Type		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                _eb._il.Emit(OpCodes.Ldtoken, t);
                _eb.Function.Invoke(GET_RUNTIME_TYPE);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_eb._il.Emit(OpCodes.Ldtoken, t);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_eb._il.Emit(OpCodes.Ldtoken, t)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldtoken, t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldtoken		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldtoken		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldtoken		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_eb.Function.Invoke(GET_RUNTIME_TYPE);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_eb.Function.Invoke(GET_RUNTIME_TYPE)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Function.Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb.Function		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(GET_RUNTIME_TYPE)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
GET_RUNTIME_TYPE		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
GET_RUNTIME_TYPE		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FieldValue(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(FieldInfo f)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
FieldInfo f		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
FieldInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, f)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
f.IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Ldfld		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldfld		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FieldValue(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(FieldBuilder fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
FieldBuilder fb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
FieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
fb.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
fb.IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Ldfld		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldfld		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FieldAddr(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(FieldInfo f)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
FieldInfo f		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
FieldInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, f)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
f.IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Ldsflda		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldsflda		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FieldAddr(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(FieldBuilder fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
FieldBuilder fb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
FieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld, fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
fb.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
fb.IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Ldsflda		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldsflda		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldsfld		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void OptFloat(double v)
            {
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(double v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
double v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
double		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
                if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (v > float.MaxValue)
                    Float32((float)v);
                else
                    Float64(v);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
v > float.MaxValue		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
float.MaxValue		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
float		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
MaxValue		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Float32((float)v);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Float32((float)v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Float32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((float)v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
(float)v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(float)v		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
float		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else
                    Float64(v);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
Float64(v);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Float64(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Float64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void OptInt(Int64 v)
            {
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Int64 v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Int64 v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Int64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                bool less = v < 0;
                if (less) v *= -1;
                if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
bool less = v < 0;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
bool less = v < 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
less = v < 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= v < 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
v < 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (less) v *= -1;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
less		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v *= -1;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
v *= -1		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (v < System.Int32.MaxValue)
                    Int32((Int32)v * (less ? -1 : 1));
                else
                    Int64(v * (less ? -1 : 1));		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
v < System.Int32.MaxValue		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
System.Int32.MaxValue		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
System.Int32		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MaxValue		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Int32((Int32)v * (less ? -1 : 1));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Int32((Int32)v * (less ? -1 : 1))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((Int32)v * (less ? -1 : 1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
(Int32)v * (less ? -1 : 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(Int32)v * (less ? -1 : 1)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(Int32)v		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(less ? -1 : 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
less ? -1 : 1		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
less		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
else
                    Int64(v * (less ? -1 : 1));		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
Int64(v * (less ? -1 : 1));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Int64(v * (less ? -1 : 1))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Int64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v * (less ? -1 : 1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v * (less ? -1 : 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v * (less ? -1 : 1)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(less ? -1 : 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
less ? -1 : 1		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
less		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public void OptUInt(UInt64 v)
            {
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(UInt64 v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
UInt64 v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
UInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (v < System.Int32.MaxValue)
                    UInt32((UInt32)v);
                else
                    UInt64(v);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
v < System.Int32.MaxValue		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
System.Int32.MaxValue		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
System.Int32		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MaxValue		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UInt32((UInt32)v);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
UInt32((UInt32)v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
UInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((UInt32)v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
(UInt32)v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(UInt32)v		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
UInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else
                    UInt64(v);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
UInt64(v);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
UInt64(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
UInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Const(UInt64 v) => OptUInt(v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(UInt64 v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
UInt64 v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
UInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> OptUInt(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
OptUInt(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
OptUInt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Const(Int64 v) => OptInt(v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Int64 v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Int64 v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Int64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> OptInt(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
OptInt(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
OptInt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Const(double v) => OptFloat(v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(double v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
double v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
double		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> OptFloat(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
OptFloat(v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
OptFloat		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Const(string s) => String(s);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(string s)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string s		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> String(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
String(s)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
String		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Const(bool b) => Bool(b);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(bool b)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
bool b		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Bool(b)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Bool(b)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Bool		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(b)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
b		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
b		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Ldloc, lb);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(LocalBuilder lb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
LocalBuilder lb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
LocalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(OpCodes.Ldloc, lb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Ldloc, lb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldloc, lb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldloc		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldloc		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldloc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
lb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
lb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FromPointerInt8() => _eb.Emit(OpCodes.Ldind_I1);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Ldind_I1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Ldind_I1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldind_I1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldind_I1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldind_I1		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldind_I1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FromPointerInt16() => _eb.Emit(OpCodes.Ldind_I2);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Ldind_I2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Ldind_I2)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldind_I2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldind_I2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldind_I2		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldind_I2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FromPointerInt32() => _eb.Emit(OpCodes.Ldind_I4);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Ldind_I4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Ldind_I4)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldind_I4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldind_I4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldind_I4		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldind_I4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FromPointerInt64() => _eb.Emit(OpCodes.Ldind_I8);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Ldind_I8)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Ldind_I8)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldind_I8)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldind_I8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldind_I8		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldind_I8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FromPointerFloat32() => _eb.Emit(OpCodes.Ldind_R4);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Ldind_R4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Ldind_R4)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldind_R4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldind_R4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldind_R4		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldind_R4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FromPointerFloat64() => _eb.Emit(OpCodes.Ldind_R8);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Ldind_R8)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Ldind_R8)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldind_R8)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldind_R8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldind_R8		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldind_R8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FromPointerRef() => _eb.Emit(OpCodes.Ldind_Ref);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Ldind_Ref)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Ldind_Ref)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ldind_Ref)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ldind_Ref		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ldind_Ref		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ldind_Ref		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void FromPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Type t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t.IsPrimitive		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsPrimitive		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                    if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (t == typeof(byte) || t == typeof(sbyte))
                        FromPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(byte) || t == typeof(sbyte)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t == typeof(byte)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(byte)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
t == typeof(sbyte)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(sbyte)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
sbyte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
FromPointerInt8();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
FromPointerInt8()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
FromPointerInt8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t == typeof(Int16) || t == typeof(UInt16))
                        FromPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(Int16) || t == typeof(UInt16)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t == typeof(Int16)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(Int16)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
Int16		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t == typeof(UInt16)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(UInt16)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
UInt16		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FromPointerInt16();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
FromPointerInt16()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
FromPointerInt16		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t == typeof(Int32) || t == typeof(UInt32))
                        FromPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(Int32) || t == typeof(UInt32)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t == typeof(Int32)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(Int32)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t == typeof(UInt32)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(UInt32)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
UInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FromPointerInt32();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
FromPointerInt32()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
FromPointerInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t == typeof(Int64) || t == typeof(UInt64))
                        FromPointerInt64();
                    else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(Int64) || t == typeof(UInt64)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t == typeof(Int64)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(Int64)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
Int64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t == typeof(UInt64)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(UInt64)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
UInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FromPointerInt64();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
FromPointerInt64()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
FromPointerInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t == typeof(float))
                        FromPointerFloat32();
                    else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(float)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(float)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
float		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
FromPointerFloat32();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
FromPointerFloat32()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
FromPointerFloat32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t == typeof(double))
                        FromPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(double)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(double)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
double		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
FromPointerFloat64();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
FromPointerFloat64()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
FromPointerFloat64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new JuliaException("Unable to Determine Pointer Type T")		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Unable to Determine Pointer Type T")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Unable to Determine Pointer Type T"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Unable to Determine Pointer Type T"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
else if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t.IsByRef)
                {
                    FromPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t.IsByRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsByRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                    FromPointerRef();
                }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
FromPointerRef();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
FromPointerRef()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
FromPointerRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new JuliaException("Unable to Determine Pointer Type T")		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Unable to Determine Pointer Type T")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Unable to Determine Pointer Type T"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Unable to Determine Pointer Type T"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public struct ILStoreExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILStoreExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void Field(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f);
            public void Field(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb);

            public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Stloc, lb);

            public void ToPointerInt8() => _eb.Emit(OpCodes.Stind_I1);
            public void ToPointerInt16() => _eb.Emit(OpCodes.Stind_I2);
            public void ToPointerInt32() => _eb.Emit(OpCodes.Stind_I4);
            public void ToPointerInt64() => _eb.Emit(OpCodes.Stind_I8);
            public void ToPointerFloat32() => _eb.Emit(OpCodes.Stind_R4);
            public void ToPointerFloat64() => _eb.Emit(OpCodes.Stind_R8);
            public void ToPointerRef() => _eb.Emit(OpCodes.Stind_Ref);

            public void ToPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
private readonly IlExprBuilder _eb;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IlExprBuilder _eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal ILStoreExprBuilder(IlExprBuilder eb) => _eb = eb;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(IlExprBuilder eb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IlExprBuilder eb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Field(FieldInfo f) => _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(FieldInfo f)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
FieldInfo f		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
FieldInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, f)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
f.IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Stsfld		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stsfld		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Stfld		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stfld		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Field(FieldBuilder fb) => _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(FieldBuilder fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
FieldBuilder fb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
FieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
fb.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
fb.IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Stsfld		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stsfld		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
OpCodes.Stfld		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stfld		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Local(LocalBuilder lb) => _eb._il.Emit(OpCodes.Stloc, lb);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(LocalBuilder lb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
LocalBuilder lb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
LocalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.Emit(OpCodes.Stloc, lb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Stloc, lb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Stloc, lb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Stloc		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Stloc		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stloc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
lb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
lb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void ToPointerInt8() => _eb.Emit(OpCodes.Stind_I1);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Stind_I1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Stind_I1)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Stind_I1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Stind_I1		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Stind_I1		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stind_I1		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void ToPointerInt16() => _eb.Emit(OpCodes.Stind_I2);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Stind_I2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Stind_I2)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Stind_I2)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Stind_I2		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Stind_I2		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stind_I2		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void ToPointerInt32() => _eb.Emit(OpCodes.Stind_I4);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Stind_I4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Stind_I4)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Stind_I4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Stind_I4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Stind_I4		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stind_I4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void ToPointerInt64() => _eb.Emit(OpCodes.Stind_I8);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Stind_I8)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Stind_I8)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Stind_I8)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Stind_I8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Stind_I8		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stind_I8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void ToPointerFloat32() => _eb.Emit(OpCodes.Stind_R4);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Stind_R4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Stind_R4)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Stind_R4)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Stind_R4		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Stind_R4		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stind_R4		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void ToPointerFloat64() => _eb.Emit(OpCodes.Stind_R8);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Stind_R8)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Stind_R8)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Stind_R8)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Stind_R8		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Stind_R8		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stind_R8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void ToPointerRef() => _eb.Emit(OpCodes.Stind_Ref);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb.Emit(OpCodes.Stind_Ref)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Emit(OpCodes.Stind_Ref)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Stind_Ref)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Stind_Ref		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Stind_Ref		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Stind_Ref		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void ToPointer(Type t)
            {
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Type t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (t.IsPrimitive)
                {
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }
                else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t.IsPrimitive		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsPrimitive		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                    if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");
                }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (t == typeof(byte) || t == typeof(sbyte))
                        ToPointerInt8();
                    else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(byte) || t == typeof(sbyte)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t == typeof(byte)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(byte)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
t == typeof(sbyte)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(sbyte)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
sbyte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
ToPointerInt8();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ToPointerInt8()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ToPointerInt8		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t == typeof(Int16) || t == typeof(UInt16))
                        ToPointerInt16();
                    else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(Int16) || t == typeof(UInt16)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t == typeof(Int16)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(Int16)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
Int16		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t == typeof(UInt16)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(UInt16)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
UInt16		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToPointerInt16();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ToPointerInt16()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ToPointerInt16		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t == typeof(Int32) || t == typeof(UInt32))
                        ToPointerInt32();
                    else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(Int32) || t == typeof(UInt32)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t == typeof(Int32)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(Int32)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t == typeof(UInt32)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(UInt32)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
UInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToPointerInt32();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ToPointerInt32()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ToPointerInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t == typeof(Int64) || t == typeof(UInt64))
                        ToPointerInt64();
                    else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(Int64) || t == typeof(UInt64)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t == typeof(Int64)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(Int64)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
Int64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t == typeof(UInt64)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(UInt64)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
UInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToPointerInt64();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ToPointerInt64()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ToPointerInt64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t == typeof(float))
                        ToPointerFloat32();
                    else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(float)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(float)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
float		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
ToPointerFloat32();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ToPointerFloat32()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ToPointerFloat32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t == typeof(double))
                        ToPointerFloat64();
                    else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t == typeof(double)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(double)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
double		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
ToPointerFloat64();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ToPointerFloat64()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ToPointerFloat64		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new JuliaException("Unable to Determine Pointer Type T")		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Unable to Determine Pointer Type T")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Unable to Determine Pointer Type T"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Unable to Determine Pointer Type T"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
else if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
if (t.IsByRef)
                {
                    ToPointerRef();
                }
                else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
t.IsByRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsByRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                    ToPointerRef();
                }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
ToPointerRef();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ToPointerRef()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ToPointerRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
else throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
throw new JuliaException("Unable to Determine Pointer Type T");		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new JuliaException("Unable to Determine Pointer Type T")		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Unable to Determine Pointer Type T")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Unable to Determine Pointer Type T"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Unable to Determine Pointer Type T"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public struct ILCreateExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILCreateExprBuilder(IlExprBuilder eb) => _eb = eb;
            public LocalBuilder Local(Type t) => _eb._il.DeclareLocal(t);
            public LocalBuilder Local<T>() => Local(typeof(T));

            public LocalBuilder LocalAndStore(Type t)
            {
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }

            public LocalBuilder LocalAndStore<T>() => LocalAndStore(typeof(T));

            public void Object(ConstructorInfo ci) => _eb.Function.Invoke(ci);
            public void Object(IlExprBuilder cb) => _eb.Function.Invoke(cb, true);
            public void Object<T>(params Type[] parameters) => _eb.Function.Invoke<T>(parameters);
            public void Object(Type t, params Type[] parameters) => _eb.Function.Invoke(t, parameters);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
private readonly IlExprBuilder _eb;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IlExprBuilder _eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal ILCreateExprBuilder(IlExprBuilder eb) => _eb = eb;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(IlExprBuilder eb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IlExprBuilder eb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public LocalBuilder Local(Type t) => _eb._il.DeclareLocal(t);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
LocalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Type t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb._il.DeclareLocal(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.DeclareLocal(t)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.DeclareLocal		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
DeclareLocal		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public LocalBuilder Local<T>() => Local(typeof(T));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
LocalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Local(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Local(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public LocalBuilder LocalAndStore(Type t)
            {
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
LocalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Type t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                var lb = Local(t);
                _eb.Store.Local(lb);
                return lb;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var lb = Local(t);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var lb = Local(t)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
lb = Local(t)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Local(t)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Local(t)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_eb.Store.Local(lb);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_eb.Store.Local(lb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Store.Local		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb.Store		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Store		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Local		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(lb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
lb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
lb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return lb;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
lb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public LocalBuilder LocalAndStore<T>() => LocalAndStore(typeof(T));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
LocalBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> LocalAndStore(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
LocalAndStore(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
LocalAndStore		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Object(ConstructorInfo ci) => _eb.Function.Invoke(ci);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(ConstructorInfo ci)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ConstructorInfo ci		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ConstructorInfo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb.Function.Invoke(ci)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Function.Invoke(ci)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Function.Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb.Function		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ci)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ci		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ci		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Object(IlExprBuilder cb) => _eb.Function.Invoke(cb, true);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IlExprBuilder cb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IlExprBuilder cb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb.Function.Invoke(cb, true)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Function.Invoke(cb, true)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Function.Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb.Function		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(cb, true)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
cb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
cb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public void Object<T>(params Type[] parameters) => _eb.Function.Invoke<T>(parameters);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(params Type[] parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
params Type[] parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=> _eb.Function.Invoke<T>(parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Function.Invoke<T>(parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Function.Invoke<T>		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb.Function		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Invoke<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Object(Type t, params Type[] parameters) => _eb.Function.Invoke(t, parameters);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Type t, params Type[] parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
params Type[] parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
=> _eb.Function.Invoke(t, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Function.Invoke(t, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Function.Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb.Function		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Function		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Invoke		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t, parameters)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public struct ILArrayExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILArrayExprBuilder(IlExprBuilder eb) => _eb = eb;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
private readonly IlExprBuilder _eb;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IlExprBuilder _eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal ILArrayExprBuilder(IlExprBuilder eb) => _eb = eb;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(IlExprBuilder eb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IlExprBuilder eb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public struct ILUnsafeExprBuilder
        {
            private readonly IlExprBuilder _eb;
            internal ILUnsafeExprBuilder(IlExprBuilder eb) => _eb = eb;

            public void StackAlloc() => _eb._il.Emit(OpCodes.Localloc);

            public void StackAlloc(Type t, int size)
            {
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }

            public void StackAlloc<T>(int size) => StackAlloc(typeof(T), size);
            public void StoreToPointer(Type t) => _eb.Store.ToPointer(t);
            public void StoreToPointer<T>() => StoreToPointer(typeof(T));
            public void LoadFromPointer(Type t) => _eb.Load.FromPointer(t);
            public void LoadFromPointer<T>() => LoadFromPointer(typeof(T));

            public void CopyBlock(int numBytes)
            {
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }

            public void CopyBlock() => _eb._il.Emit(OpCodes.Cpblk);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
private readonly IlExprBuilder _eb;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IlExprBuilder _eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal ILUnsafeExprBuilder(IlExprBuilder eb) => _eb = eb;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(IlExprBuilder eb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IlExprBuilder eb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb = eb		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void StackAlloc() => _eb._il.Emit(OpCodes.Localloc);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb._il.Emit(OpCodes.Localloc)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Localloc)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Localloc)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Localloc		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Localloc		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Localloc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void StackAlloc(Type t, int size)
            {
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Type t, int size)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
int size		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
                _eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));
                StackAlloc();
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_eb.Load.UInt32((uint)(Marshal.SizeOf(t) * size))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Load.UInt32		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb.Load		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Load		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UInt32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((uint)(Marshal.SizeOf(t) * size))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
(uint)(Marshal.SizeOf(t) * size)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(uint)(Marshal.SizeOf(t) * size)		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
uint		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Marshal.SizeOf(t) * size)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
Marshal.SizeOf(t) * size		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Marshal.SizeOf(t)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Marshal.SizeOf		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Marshal		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
SizeOf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
StackAlloc();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
StackAlloc()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
StackAlloc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public void StackAlloc<T>(int size) => StackAlloc(typeof(T), size);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(int size)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int size		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> StackAlloc(typeof(T), size)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
StackAlloc(typeof(T), size)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
StackAlloc		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T), size)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
size		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
size		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void StoreToPointer(Type t) => _eb.Store.ToPointer(t);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Type t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb.Store.ToPointer(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Store.ToPointer(t)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Store.ToPointer		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb.Store		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Store		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToPointer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void StoreToPointer<T>() => StoreToPointer(typeof(T));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> StoreToPointer(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
StoreToPointer(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
StoreToPointer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void LoadFromPointer(Type t) => _eb.Load.FromPointer(t);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Type t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _eb.Load.FromPointer(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb.Load.FromPointer(t)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Load.FromPointer		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb.Load		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Load		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
FromPointer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void LoadFromPointer<T>() => LoadFromPointer(typeof(T));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> LoadFromPointer(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
LoadFromPointer(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
LoadFromPointer		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void CopyBlock(int numBytes)
            {
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int numBytes)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int numBytes		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
                _eb.Load.Int32(numBytes);
                CopyBlock();
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_eb.Load.Int32(numBytes);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_eb.Load.Int32(numBytes)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb.Load.Int32		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb.Load		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Load		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(numBytes)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
numBytes		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
numBytes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CopyBlock();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
CopyBlock()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
CopyBlock		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public void CopyBlock() => _eb._il.Emit(OpCodes.Cpblk);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> _eb._il.Emit(OpCodes.Cpblk)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_eb._il.Emit(OpCodes.Cpblk)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_eb._il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb._il		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_eb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Cpblk)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Cpblk		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Cpblk		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Cpblk		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public ILFunctionExprBuilder Function => new(this);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
ILFunctionExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public ILLoadExprBuilder Load => new(this);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
ILLoadExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public ILStoreExprBuilder Store => new(this);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
ILStoreExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public ILCreateExprBuilder Create => new(this);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
ILCreateExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public ILArrayExprBuilder Array => new(this);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
ILArrayExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public ILUnsafeExprBuilder Unsafe => new(this);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
ILUnsafeExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
new(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
private IlExprBuilder(ILGenerator il, object internalMethod) {
            _il = il;
            _internalMethod = internalMethod;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ILGenerator il, object internalMethod)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ILGenerator il		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ILGenerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
object internalMethod		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
            _il = il;
            _internalMethod = internalMethod;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_il = il;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_il = il		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_internalMethod = internalMethod;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_internalMethod = internalMethod		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_internalMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internalMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IlExprBuilder(MethodBuilder mb) : this(mb.GetILGenerator(), mb) {}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(MethodBuilder mb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
MethodBuilder mb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
MethodBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: this(mb.GetILGenerator(), mb)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(mb.GetILGenerator(), mb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
mb.GetILGenerator()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mb.GetILGenerator()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
mb.GetILGenerator		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
mb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetILGenerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
mb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public IlExprBuilder(ConstructorBuilder cb) : this(cb.GetILGenerator(), cb) {}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(ConstructorBuilder cb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
ConstructorBuilder cb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ConstructorBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: this(cb.GetILGenerator(), cb)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(cb.GetILGenerator(), cb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
cb.GetILGenerator()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
cb.GetILGenerator()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
cb.GetILGenerator		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
cb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetILGenerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
cb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
cb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public void Emit(OpCode code) => _il.Emit(code);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(OpCode code)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
OpCode code		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
OpCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _il.Emit(code)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_il.Emit(code)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(code)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Return() => Emit(OpCodes.Ret);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Emit(OpCodes.Ret)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Emit(OpCodes.Ret)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Ret)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Ret		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Ret		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ret		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Add() => Emit(OpCodes.Add);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Emit(OpCodes.Add)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Emit(OpCodes.Add)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Add)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Add		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Sub() => Emit(OpCodes.Sub);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Emit(OpCodes.Sub)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Emit(OpCodes.Sub)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Sub)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Sub		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Sub		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Sub		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Duplicate() => Emit(OpCodes.Dup);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Emit(OpCodes.Dup)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Emit(OpCodes.Dup)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Dup)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Dup		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Dup		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Dup		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Box(Type t) => _il.Emit(OpCodes.Box, t);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Type t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Type t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _il.Emit(OpCodes.Box, t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_il.Emit(OpCodes.Box, t)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Box, t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Box		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Box		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Box		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void Box<T>() => Box(typeof(T));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Box(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Box(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Box		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void ReturnVoid() {
            _il.Emit(OpCodes.Nop);
            Return();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
            _il.Emit(OpCodes.Nop);
            Return();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_il.Emit(OpCodes.Nop);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_il.Emit(OpCodes.Nop)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_il.Emit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_il		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Emit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(OpCodes.Nop)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
OpCodes.Nop		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
OpCodes.Nop		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
OpCodes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Nop		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Return();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Return()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Return		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public static IlExprBuilder CreateDynamicFunction(out DynamicMethod m, string name = "<Eval>")
        {
            m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);
            return new(m.GetILGenerator(), m);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IlExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(out DynamicMethod m, string name = "<Eval>")		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
out DynamicMethod m		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
DynamicMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string name = "<Eval>"		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= "<Eval>"		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
"<Eval>"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
            m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);
            return new(m.GetILGenerator(), m);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
m = new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new DynamicMethod(name, typeof(object), Type.EmptyTypes, typeof(string).Module)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
DynamicMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, typeof(object), Type.EmptyTypes, typeof(string).Module)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(object)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(object)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Type.EmptyTypes		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Type.EmptyTypes		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
EmptyTypes		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
typeof(string).Module		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(string).Module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
typeof(string)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return new(m.GetILGenerator(), m);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
new(m.GetILGenerator(), m)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(m.GetILGenerator(), m)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
m.GetILGenerator()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
m.GetILGenerator()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
m.GetILGenerator		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetILGenerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;

namespace runtime.Utils;

public static class ListExtensions
{
    public static bool Visit<T>(this IList<T> l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }
        
    public static bool Visit<T>(this T[] l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }

    public static void Print<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
    
    public static TextWriter Print<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) {
        toStringMethod ??= x => x.ToString();
        tw ??= Console.Out;
        tw.Write("{");
        tw.Write(typeof(T));
        tw.Write("}[");
        if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
        tw.Write("]");
        return tw;
    }

    public static void PrintLn<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l, toStringMethod, tw).WriteLine();
    public static void Print<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Collections;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Collections		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Collections		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Collections.Generic;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Collections.Generic		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Collections		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Collections		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Generic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.IO;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.IO		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IO		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Linq;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Linq		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Linq		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Runtime.CompilerServices;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Runtime.CompilerServices		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompilerServices		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.Utils;

public static class ListExtensions
{
    public static bool Visit<T>(this IList<T> l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }
        
    public static bool Visit<T>(this T[] l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }

    public static void Print<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
    
    public static TextWriter Print<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) {
        toStringMethod ??= x => x.ToString();
        tw ??= Console.Out;
        tw.Write("{");
        tw.Write(typeof(T));
        tw.Write("}[");
        if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
        tw.Write("]");
        return tw;
    }

    public static void PrintLn<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l, toStringMethod, tw).WriteLine();
    public static void Print<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.Utils		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Utils		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static class ListExtensions
{
    public static bool Visit<T>(this IList<T> l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }
        
    public static bool Visit<T>(this T[] l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }

    public static void Print<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
    
    public static TextWriter Print<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) {
        toStringMethod ??= x => x.ToString();
        tw ??= Console.Out;
        tw.Write("{");
        tw.Write(typeof(T));
        tw.Write("}[");
        if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
        tw.Write("]");
        return tw;
    }

    public static void PrintLn<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l, toStringMethod, tw).WriteLine();
    public static void Print<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);
    public static void PrintLn<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
public static bool Visit<T>(this IList<T> l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(this IList<T> l, Func<T, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
this IList<T> l		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IList<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Func<T, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<T, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
foreach (var t in l)
            if (!v(t))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (!v(t))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!v(t)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
v(t)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static bool Visit<T>(this T[] l, Func<T, bool> v)
    {
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(this T[] l, Func<T, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
this T[] l		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Func<T, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<T, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        foreach (var t in l)
            if (!v(t))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
foreach (var t in l)
            if (!v(t))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (!v(t))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!v(t)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
v(t)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public static void Print<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
this IList<T> l		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IList<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Func<T, string> toStringMethod = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
TextWriter tw = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
=> Print(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Print(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
l.GetEnumerator()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
l.GetEnumerator()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
l.GetEnumerator		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetEnumerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static void PrintLn<T>(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(this IList<T> l, Func<T, string> toStringMethod = null, TextWriter tw = null)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
this IList<T> l		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IList<T>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Func<T, string> toStringMethod = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
TextWriter tw = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
=> PrintLn(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
PrintLn(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
PrintLn		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
l.GetEnumerator()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
l.GetEnumerator()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
l.GetEnumerator		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetEnumerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static TextWriter Print<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) {
        toStringMethod ??= x => x.ToString();
        tw ??= Console.Out;
        tw.Write("{");
        tw.Write(typeof(T));
        tw.Write("}[");
        if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
        tw.Write("]");
        return tw;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
this IEnumerator l		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IEnumerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Func<T, string> toStringMethod = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
TextWriter tw = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
        toStringMethod ??= x => x.ToString();
        tw ??= Console.Out;
        tw.Write("{");
        tw.Write(typeof(T));
        tw.Write("}[");
        if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }
        tw.Write("]");
        return tw;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
toStringMethod ??= x => x.ToString();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
toStringMethod ??= x => x.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
x => x.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
x.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
x.ToString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
tw ??= Console.Out;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw ??= Console.Out		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.Out		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Out		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw.Write("{");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write("{")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("{")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"{"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"{"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
tw.Write(typeof(T));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(typeof(T))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
typeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw.Write("}[");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write("}[")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("}[")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"}["		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"}["		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
if (l.MoveNext()) {
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
l.MoveNext()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
l.MoveNext		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MoveNext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
{
            tw.Write(toStringMethod((T) l.Current));
            while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
tw.Write(toStringMethod((T) l.Current));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write(toStringMethod((T) l.Current))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(toStringMethod((T) l.Current))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
toStringMethod((T) l.Current)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
toStringMethod((T) l.Current)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((T) l.Current)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
(T) l.Current		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(T) l.Current		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
l.Current		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Current		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
while (l.MoveNext()) {
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }		Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax
l.MoveNext()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
l.MoveNext		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MoveNext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
{
                tw.Write(", ");
                tw.Write(toStringMethod((T) l.Current));
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
tw.Write(", ");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write(", ")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(", ")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
", "		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
", "		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
tw.Write(toStringMethod((T) l.Current));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write(toStringMethod((T) l.Current))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(toStringMethod((T) l.Current))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
toStringMethod((T) l.Current)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
toStringMethod((T) l.Current)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((T) l.Current)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
(T) l.Current		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(T) l.Current		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
l.Current		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Current		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw.Write("]");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write("]")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("]")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"]"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"]"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return tw;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static void PrintLn<T>(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l, toStringMethod, tw).WriteLine();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(this IEnumerator l, Func<T, string> toStringMethod = null, TextWriter tw = null)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
this IEnumerator l		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IEnumerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Func<T, string> toStringMethod = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
TextWriter tw = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
=> Print(l, toStringMethod, tw).WriteLine()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Print(l, toStringMethod, tw).WriteLine()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print(l, toStringMethod, tw).WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Print(l, toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(l, toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public static void Print<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => Print(l.GetEnumerator(), toStringMethod, tw);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
this T[] l		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Func<T, string> toStringMethod = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
TextWriter tw = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
=> Print(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Print(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
l.GetEnumerator()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
l.GetEnumerator()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
l.GetEnumerator		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetEnumerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static void PrintLn<T>(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null) => PrintLn(l.GetEnumerator(), toStringMethod, tw);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(this T[] l, Func<T, string> toStringMethod = null, TextWriter tw = null)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
this T[] l		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Func<T, string> toStringMethod = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<T, string>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
TextWriter tw = null		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
= null		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
=> PrintLn(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
PrintLn(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
PrintLn		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(l.GetEnumerator(), toStringMethod, tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
l.GetEnumerator()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
l.GetEnumerator()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
l.GetEnumerator		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
l		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetEnumerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
toStringMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
global using JStringRef = System.Int32;
using System;
using runtime.Utils;

namespace runtime.core.JIL;

public readonly struct JNameRef {
    public readonly int CompileTimeNameRefIndex;
    public readonly ushort CompileTimeExprStackDelta;

    public JNameRef(int nameRefIndex, ushort stackDelta) {
        CompileTimeNameRefIndex = nameRefIndex;
        CompileTimeExprStackDelta = stackDelta;
    }

    public override string ToString() => "Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex;
}

public class JILExpr : IJExpr {
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];
    
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    internal JILExpr(JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)
    {
        Modifiers = modifiers;
        Code = code;
        VarTable = variables;
        Names = names;
        Parent = parent;
    }
}

public class JILMethod : JILExpr, IJMethod
{
    public readonly JNameRef[] Parameters;

    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v) {
        var names = Names;
        foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);

    internal JILMethod(JMethodFlags methodModifiers, JNameRef[] parameters, 
            JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        MethodModifiers = methodModifiers;
        Parameters = parameters;
    }
}

public struct JILField : IJField {
    public JStringRef NameRef { get; internal set; }
    public JNameRef TypeRef { get; internal set; }
    public string Name => Parent.Context.GetString(NameRef);
    public IJType Type => throw new NotSupportedException();
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    internal JILField(JStringRef name, JFieldFlags modifiers, JNameRef type, IJExpr parent) {
        NameRef = name;
        Modifiers = modifiers;
        TypeRef = type;
        Parent = parent;
    }
}

public class JILType : IJType{
    public JStringRef NameRef { get; internal set; }
    public readonly JILField[] Fields;
    public readonly JILMethod[] Constructors;
    public IJExpr Parent { get; internal set; }
    public JTypeType Type { get; }

    internal JILType(JStringRef name, JTypeType type, JILField[] fields, JILMethod[] constructors, IJModule parent) {
        NameRef = name;
        Type = type;
        Fields = fields;
        Constructors = constructors;
        Parent = parent;
    }

    public string Name => Parent.Context.GetString(NameRef);
    public JExprFlags Modifiers => JExprFlags.None;
    public IJModule Module => Parent as IJModule;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => Constructors.Visit(x => v(x));
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }
    
    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}

public sealed class JILModule : JILExpr, IJModule {
    public JStringRef NameRef { get; internal set; }
    internal IJCodeContext Ctx;
    public JModuleFlags ModuleModifiers { get; }

    internal JILModule(JStringRef name, JModuleFlags flags, 
        JExprFlags modifiers, byte[] code, JNameRef[] variables, 
        JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        NameRef = name;
        ModuleModifiers = flags;
        Parent = parent;
    }

    public string Name => Ctx.GetString(NameRef);
    
    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotSupportedException();

    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        Names.PrintLn(x => x.Name);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
global using JStringRef = System.Int32;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
JStringRef =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
System.Int32		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.Utils;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.Utils		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Utils		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core.JIL;

public readonly struct JNameRef {
    public readonly int CompileTimeNameRefIndex;
    public readonly ushort CompileTimeExprStackDelta;

    public JNameRef(int nameRefIndex, ushort stackDelta) {
        CompileTimeNameRefIndex = nameRefIndex;
        CompileTimeExprStackDelta = stackDelta;
    }

    public override string ToString() => "Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex;
}

public class JILExpr : IJExpr {
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];
    
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    internal JILExpr(JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)
    {
        Modifiers = modifiers;
        Code = code;
        VarTable = variables;
        Names = names;
        Parent = parent;
    }
}

public class JILMethod : JILExpr, IJMethod
{
    public readonly JNameRef[] Parameters;

    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v) {
        var names = Names;
        foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);

    internal JILMethod(JMethodFlags methodModifiers, JNameRef[] parameters, 
            JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        MethodModifiers = methodModifiers;
        Parameters = parameters;
    }
}

public struct JILField : IJField {
    public JStringRef NameRef { get; internal set; }
    public JNameRef TypeRef { get; internal set; }
    public string Name => Parent.Context.GetString(NameRef);
    public IJType Type => throw new NotSupportedException();
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    internal JILField(JStringRef name, JFieldFlags modifiers, JNameRef type, IJExpr parent) {
        NameRef = name;
        Modifiers = modifiers;
        TypeRef = type;
        Parent = parent;
    }
}

public class JILType : IJType{
    public JStringRef NameRef { get; internal set; }
    public readonly JILField[] Fields;
    public readonly JILMethod[] Constructors;
    public IJExpr Parent { get; internal set; }
    public JTypeType Type { get; }

    internal JILType(JStringRef name, JTypeType type, JILField[] fields, JILMethod[] constructors, IJModule parent) {
        NameRef = name;
        Type = type;
        Fields = fields;
        Constructors = constructors;
        Parent = parent;
    }

    public string Name => Parent.Context.GetString(NameRef);
    public JExprFlags Modifiers => JExprFlags.None;
    public IJModule Module => Parent as IJModule;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => Constructors.Visit(x => v(x));
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }
    
    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}

public sealed class JILModule : JILExpr, IJModule {
    public JStringRef NameRef { get; internal set; }
    internal IJCodeContext Ctx;
    public JModuleFlags ModuleModifiers { get; }

    internal JILModule(JStringRef name, JModuleFlags flags, 
        JExprFlags modifiers, byte[] code, JNameRef[] variables, 
        JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        NameRef = name;
        ModuleModifiers = flags;
        Parent = parent;
    }

    public string Name => Ctx.GetString(NameRef);
    
    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotSupportedException();

    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        Names.PrintLn(x => x.Name);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public readonly struct JNameRef {
    public readonly int CompileTimeNameRefIndex;
    public readonly ushort CompileTimeExprStackDelta;

    public JNameRef(int nameRefIndex, ushort stackDelta) {
        CompileTimeNameRefIndex = nameRefIndex;
        CompileTimeExprStackDelta = stackDelta;
    }

    public override string ToString() => "Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex;
}		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
public readonly int CompileTimeNameRefIndex;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly ushort CompileTimeExprStackDelta;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
ushort CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
ushort		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public JNameRef(int nameRefIndex, ushort stackDelta) {
        CompileTimeNameRefIndex = nameRefIndex;
        CompileTimeExprStackDelta = stackDelta;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(int nameRefIndex, ushort stackDelta)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int nameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
ushort stackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
ushort		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        CompileTimeNameRefIndex = nameRefIndex;
        CompileTimeExprStackDelta = stackDelta;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
CompileTimeNameRefIndex = nameRefIndex;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
CompileTimeNameRefIndex = nameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
nameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeExprStackDelta = stackDelta;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
CompileTimeExprStackDelta = stackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
stackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public override string ToString() => "Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> "Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
"Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:" + CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Expression Depth:" + CompileTimeExprStackDelta + "\tNameRefIndex:"		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Expression Depth:" + CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Expression Depth:"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
"\tNameRefIndex:"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JILExpr : IJExpr {
    public readonly byte[] Code;
    public readonly JNameRef[] VarTable;
    public readonly JILField[] Names;

    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }
    

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];
    
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();

    internal JILExpr(JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)
    {
        Modifiers = modifiers;
        Code = code;
        VarTable = variables;
        Names = names;
        Parent = parent;
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public readonly byte[] Code;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
byte[] Code		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly JNameRef[] VarTable;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JNameRef[] VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JNameRef[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly JILField[] Names;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JILField[] Names		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILField[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public JExprFlags Modifiers { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJExpr Parent { get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public bool VisitVariables(Func<IJField, bool> v) {
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
foreach (var va in VarTable) {
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (!v(Names[va.CompileTimeNameRefIndex]))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!v(Names[va.CompileTimeNameRefIndex])		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
v(Names[va.CompileTimeNameRefIndex])		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Names[va.CompileTimeNameRefIndex])		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Names[va.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Names[va.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[va.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
va.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
va.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
va		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, object, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, object, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
for(int i = 0; i < Names.Length; i++)
            if (!v(Names[i], null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < Names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (!v(Names[i], null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!v(Names[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
v(Names[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Names[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Names[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Names[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Names[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Names[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name, out JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
internal JILExpr(JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)
    {
        Modifiers = modifiers;
        Code = code;
        VarTable = variables;
        Names = names;
        Parent = parent;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JExprFlags modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
byte[] code		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
JNameRef[] variables		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
JILField[] names		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILField[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
IJExpr parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        Modifiers = modifiers;
        Code = code;
        VarTable = variables;
        Names = names;
        Parent = parent;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Modifiers = modifiers;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Modifiers = modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Code = code;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Code = code		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VarTable = variables;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
VarTable = variables		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
VarTable		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
variables		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Names = names;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Names = names		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent = parent;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Parent = parent		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JILMethod : JILExpr, IJMethod
{
    public readonly JNameRef[] Parameters;

    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v) {
        var names = Names;
        foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }

    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);

    internal JILMethod(JMethodFlags methodModifiers, JNameRef[] parameters, 
            JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        MethodModifiers = methodModifiers;
        Parameters = parameters;
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JILExpr, IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JILExpr		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JILExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public readonly JNameRef[] Parameters;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JNameRef[] Parameters		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JNameRef[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Parameters		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public JMethodFlags MethodModifiers { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JMethodFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public bool VisitParameters(Func<IJField, bool> v) {
        var names = Names;
        foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        var names = Names;
        foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var names = Names;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var names = Names		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names = Names		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Names		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
foreach (var va in Parameters) {
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            if (!v(names[va.CompileTimeNameRefIndex]))
                return false;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (!v(names[va.CompileTimeNameRefIndex]))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!v(names[va.CompileTimeNameRefIndex])		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
v(names[va.CompileTimeNameRefIndex])		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(names[va.CompileTimeNameRefIndex])		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
names[va.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
names[va.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[va.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
va.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
va.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
va		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> MethodModifiers.HasFlag(JMethodFlags.Inline)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
MethodModifiers.HasFlag(JMethodFlags.Inline)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
MethodModifiers.HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JMethodFlags.Inline)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JMethodFlags.Inline		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JMethodFlags.Inline		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JMethodFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Inline		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal JILMethod(JMethodFlags methodModifiers, JNameRef[] parameters, 
            JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        MethodModifiers = methodModifiers;
        Parameters = parameters;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JMethodFlags methodModifiers, JNameRef[] parameters, 
            JExprFlags modifiers, byte[] code, JNameRef[] variables, JILField[] names, IJExpr parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JMethodFlags methodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JMethodFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JNameRef[] parameters		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
JExprFlags modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
byte[] code		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
JNameRef[] variables		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
JILField[] names		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILField[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
IJExpr parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: base(modifiers, code, variables, names, parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(modifiers, code, variables, names, parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
variables		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
variables		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        MethodModifiers = methodModifiers;
        Parameters = parameters;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
MethodModifiers = methodModifiers;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
MethodModifiers = methodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
MethodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
methodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parameters = parameters;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Parameters = parameters		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public struct JILField : IJField {
    public JStringRef NameRef { get; internal set; }
    public JNameRef TypeRef { get; internal set; }
    public string Name => Parent.Context.GetString(NameRef);
    public IJType Type => throw new NotSupportedException();
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; internal set; }

    internal JILField(JStringRef name, JFieldFlags modifiers, JNameRef type, IJExpr parent) {
        NameRef = name;
        Modifiers = modifiers;
        TypeRef = type;
        Parent = parent;
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
: IJField		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JStringRef NameRef { get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JNameRef TypeRef { get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public string Name => Parent.Context.GetString(NameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Parent.Context.GetString(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Parent.Context.GetString(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Parent.Context.GetString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent.Context		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJType Type => throw new NotSupportedException();		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotSupportedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotSupportedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotSupportedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotSupportedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public JFieldFlags Modifiers { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JFieldFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJExpr Parent { get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal JILField(JStringRef name, JFieldFlags modifiers, JNameRef type, IJExpr parent) {
        NameRef = name;
        Modifiers = modifiers;
        TypeRef = type;
        Parent = parent;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JStringRef name, JFieldFlags modifiers, JNameRef type, IJExpr parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JStringRef name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JFieldFlags modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JFieldFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JNameRef type		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJExpr parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        NameRef = name;
        Modifiers = modifiers;
        TypeRef = type;
        Parent = parent;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
NameRef = name;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
NameRef = name		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modifiers = modifiers;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Modifiers = modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeRef = type;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
TypeRef = type		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
TypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent = parent;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Parent = parent		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JILType : IJType{
    public JStringRef NameRef { get; internal set; }
    public readonly JILField[] Fields;
    public readonly JILMethod[] Constructors;
    public IJExpr Parent { get; internal set; }
    public JTypeType Type { get; }

    internal JILType(JStringRef name, JTypeType type, JILField[] fields, JILMethod[] constructors, IJModule parent) {
        NameRef = name;
        Type = type;
        Fields = fields;
        Constructors = constructors;
        Parent = parent;
    }

    public string Name => Parent.Context.GetString(NameRef);
    public JExprFlags Modifiers => JExprFlags.None;
    public IJModule Module => Parent as IJModule;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => Constructors.Visit(x => v(x));
    
    public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }
    
    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: IJType		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JStringRef NameRef { get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public readonly JILField[] Fields;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JILField[] Fields		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILField[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public readonly JILMethod[] Constructors;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JILMethod[] Constructors		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILMethod[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JILMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Constructors		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public IJExpr Parent { get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JTypeType Type { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal JILType(JStringRef name, JTypeType type, JILField[] fields, JILMethod[] constructors, IJModule parent) {
        NameRef = name;
        Type = type;
        Fields = fields;
        Constructors = constructors;
        Parent = parent;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JStringRef name, JTypeType type, JILField[] fields, JILMethod[] constructors, IJModule parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JStringRef name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JTypeType type		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILField[] fields		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILField[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
JILMethod[] constructors		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILMethod[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JILMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
IJModule parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        NameRef = name;
        Type = type;
        Fields = fields;
        Constructors = constructors;
        Parent = parent;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
NameRef = name;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
NameRef = name		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type = type;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Type = type		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Fields = fields;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Fields = fields		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Constructors = constructors;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Constructors = constructors		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Constructors		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
constructors		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent = parent;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Parent = parent		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public string Name => Parent.Context.GetString(NameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Parent.Context.GetString(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Parent.Context.GetString(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Parent.Context.GetString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent.Context		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JExprFlags Modifiers => JExprFlags.None;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> JExprFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
JExprFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJModule Module => Parent as IJModule;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Parent as IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Parent as IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitVariables(Func<IJField, bool> v) => true;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> true		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Fields[nameRef.CompileTimeNameRefIndex];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Fields[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Fields[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name, out JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public bool VisitFields(Func<IJField, bool> v) => Fields.Visit(x => v(x));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Fields.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Fields.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Fields.Visit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Visit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitConstructors(Func<IJMethod, bool> v) => Constructors.Visit(x => v(x));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJMethod, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJMethod, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Constructors.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Constructors.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Constructors.Visit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Constructors		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Visit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitNames(Func<IJField, object, bool> v) {
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, object, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, object, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
for(int i = 0; i < Fields.Length; i++)
            if (!v(Fields[i], null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < Fields.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Fields.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (!v(Fields[i], null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!v(Fields[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
v(Fields[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Fields[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Fields[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Fields[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(IContextMerger merger)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IContextMerger merger		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IContextMerger		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        NameRef = merger.GetNewString(NameRef);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
NameRef = merger.GetNewString(NameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
NameRef = merger.GetNewString(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
merger.GetNewString(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
merger.GetNewString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
merger		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNewString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        })		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        })		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
(f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax
(f, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
{
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var jf = (JILField) f;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var jf = (JILField) f		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jf = (JILField) f		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= (JILField) f		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
(JILField) f		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jf.NameRef = merger.GetNewString(jf.NameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
jf.NameRef = merger.GetNewString(jf.NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
jf.NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
jf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
merger.GetNewString(jf.NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
merger.GetNewString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
merger		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNewString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(jf.NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
jf.NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
jf.NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
jf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public sealed class JILModule : JILExpr, IJModule {
    public JStringRef NameRef { get; internal set; }
    internal IJCodeContext Ctx;
    public JModuleFlags ModuleModifiers { get; }

    internal JILModule(JStringRef name, JModuleFlags flags, 
        JExprFlags modifiers, byte[] code, JNameRef[] variables, 
        JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        NameRef = name;
        ModuleModifiers = flags;
        Parent = parent;
    }

    public string Name => Ctx.GetString(NameRef);
    
    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotSupportedException();

    void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        Names.PrintLn(x => x.Name);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JILExpr, IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JILExpr		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JILExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JStringRef NameRef { get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal IJCodeContext Ctx;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IJCodeContext Ctx		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ctx		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public JModuleFlags ModuleModifiers { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JModuleFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal JILModule(JStringRef name, JModuleFlags flags, 
        JExprFlags modifiers, byte[] code, JNameRef[] variables, 
        JILField[] names, IJExpr parent) : base(modifiers, code, variables, names, parent) {
        NameRef = name;
        ModuleModifiers = flags;
        Parent = parent;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JStringRef name, JModuleFlags flags, 
        JExprFlags modifiers, byte[] code, JNameRef[] variables, 
        JILField[] names, IJExpr parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JStringRef name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JModuleFlags flags		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JModuleFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JExprFlags modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
byte[] code		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
JNameRef[] variables		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
JILField[] names		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILField[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
IJExpr parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: base(modifiers, code, variables, names, parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(modifiers, code, variables, names, parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
variables		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
variables		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        NameRef = name;
        ModuleModifiers = flags;
        Parent = parent;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
NameRef = name;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
NameRef = name		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleModifiers = flags;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ModuleModifiers = flags		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
ModuleModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
flags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent = parent;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Parent = parent		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public string Name => Ctx.GetString(NameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Ctx.GetString(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Ctx.GetString(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Ctx.GetString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool GetNameV<T>(JNameRef r, out T t) => throw new NotSupportedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(JNameRef r, out T t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef r		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out T t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotSupportedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotSupportedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotSupportedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotSupportedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
void IJExpr.UpdateContext(IContextMerger merger) {
        NameRef = merger.GetNewString(NameRef);
        Names.PrintLn(x => x.Name);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(IContextMerger merger)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IContextMerger merger		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IContextMerger		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        NameRef = merger.GetNewString(NameRef);
        Names.PrintLn(x => x.Name);
        VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
NameRef = merger.GetNewString(NameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
NameRef = merger.GetNewString(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
merger.GetNewString(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
merger.GetNewString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
merger		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNewString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Names.PrintLn(x => x.Name);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Names.PrintLn(x => x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Names.PrintLn		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
PrintLn		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        });		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
VisitNames((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        })		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
VisitNames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        })		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
(f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(f, v) => {
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax
(f, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
{
            var jf = (JILField) f;
            jf.NameRef = merger.GetNewString(jf.NameRef);
            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var jf = (JILField) f;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var jf = (JILField) f		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jf = (JILField) f		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= (JILField) f		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
(JILField) f		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jf.NameRef = merger.GetNewString(jf.NameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
jf.NameRef = merger.GetNewString(jf.NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
jf.NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
jf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
merger.GetNewString(jf.NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
merger.GetNewString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
merger		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNewString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(jf.NameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
jf.NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
jf.NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
jf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
NameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
using System;
using runtime.core.JIL;

namespace runtime.core;

[Flags]
public enum JExprFlags : byte {
    None = 0
}

[Flags]
public enum JMethodFlags : byte {
    None = 0,
    Inline = 1 << 0
}

[Flags]
public enum JModuleFlags : byte
{
    None = 0,
    Bare = 1 << 0
}

[Flags]
public enum JFieldFlags : byte{
    None = 0,
    Const = 1 << 0,
    Global = 1 << 1,
}

public enum JTypeType : byte{
    None,
    Abstract,
    Mutable,
    Struct,
    Primitive
}



public interface IJCodeContext {
    public string GetString(JStringRef i);
    public IJModule GetCtxModule(int i);
    public IJType GetCtxType(int i);
    public JStringRef GetStringIndex(string s);
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        IJExpr v = e;
        while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
        nameRef = default;
        return false;
    }
    
    public IJField GetNameField(IJExpr e, JNameRef nameRef)  {
        if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
        return e.GetNameFieldImpl(nameRef);
    }
}

public interface IJCodeExecutionContext : IJCodeContext{
    public void EnterModule(IJModule m);
    public void ExitModule();
    public void EnterExpr(IJExpr e);
    public void ExitExpr();
    public IJExpr GetExpr(int i);
    public IJModule CurrentModule { get; }
    public IJExpr CurrentExpr { get; }
}

public interface IJModule : IJExpr
{
    public string Name { get; }
    IJModule IJExpr.Module => this;
    public IJModule ParentModule => Parent.Module;
    public JModuleFlags ModuleModifiers { get; }
    public bool IsBare => ModuleModifiers.HasFlag(JModuleFlags.Bare);
    public bool GetNameV<T>(JNameRef r, out T t);
    public bool GetName(JNameRef r, out object o) => GetNameV(r, out o);
}

public interface IContextMerger : Reader.IJILVisitor {
    public JStringRef GetNewString(JStringRef str);
    public int GetNewType(int oldType);
    public int GetNewModule(int oldModule);
}

public interface IJExpr {
    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; }
    public IJModule Module => Parent.Module;
    public IJCodeContext Context => Parent.Context;
    public bool VisitVariables(Func<IJField, bool> v);
    public bool VisitNames(Func<IJField, object, bool> v);
    public IJField GetNameField(JNameRef nameRef) => Context.GetNameField(this, nameRef);
    internal IJField GetNameFieldImpl(JNameRef nameRef);
    
    public bool GetNameRef(string name, out JNameRef nameRef) => Context.GetNameRef(this, name, out nameRef);
    internal bool GetNameRefImpl(string name, out JNameRef nameRef);
    public JNameRef GetNameRef(string name) {
        if (GetNameRef(name, out var nameRef))
            return nameRef;
        throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");
    }

    protected internal void UpdateContext(IContextMerger merger){}
}

public interface IJMethod : IJExpr{
    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v);
    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);
}

public interface IJType : IJExpr{
    public string Name { get; }
    public JTypeType Type { get; }
    public bool VisitFields(Func<IJField, bool> v);
    public bool VisitConstructors(Func<IJMethod, bool> v);
}

public interface IJField {
    public string Name { get; }
    public IJType Type { get; }
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; }
    protected internal void UpdateContext(JStringRef[] str2strmap, int typeOffset, int moduleOffset){}
    public bool IsConst => Modifiers.HasFlag(JFieldFlags.Const);

    public bool IsGlobal => Modifiers.HasFlag(JFieldFlags.Global);

    public bool IsLocal => !IsGlobal;
}

public interface IJFunction {
    public string Name { get; }

    public bool VisitMethods(Func<IJMethod, bool> v);
}

public interface IJName : IJField {
    public object ObjectValue { get; set; }
    public JNameRef NameRef { get; }
    IJExpr IJField.Parent => Type.Parent;
}

public interface IJName<T> : IJName
{
    public T Value { get; set; }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.JIL;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core;

[Flags]
public enum JExprFlags : byte {
    None = 0
}

[Flags]
public enum JMethodFlags : byte {
    None = 0,
    Inline = 1 << 0
}

[Flags]
public enum JModuleFlags : byte
{
    None = 0,
    Bare = 1 << 0
}

[Flags]
public enum JFieldFlags : byte{
    None = 0,
    Const = 1 << 0,
    Global = 1 << 1,
}

public enum JTypeType : byte{
    None,
    Abstract,
    Mutable,
    Struct,
    Primitive
}



public interface IJCodeContext {
    public string GetString(JStringRef i);
    public IJModule GetCtxModule(int i);
    public IJType GetCtxType(int i);
    public JStringRef GetStringIndex(string s);
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        IJExpr v = e;
        while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
        nameRef = default;
        return false;
    }
    
    public IJField GetNameField(IJExpr e, JNameRef nameRef)  {
        if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
        return e.GetNameFieldImpl(nameRef);
    }
}

public interface IJCodeExecutionContext : IJCodeContext{
    public void EnterModule(IJModule m);
    public void ExitModule();
    public void EnterExpr(IJExpr e);
    public void ExitExpr();
    public IJExpr GetExpr(int i);
    public IJModule CurrentModule { get; }
    public IJExpr CurrentExpr { get; }
}

public interface IJModule : IJExpr
{
    public string Name { get; }
    IJModule IJExpr.Module => this;
    public IJModule ParentModule => Parent.Module;
    public JModuleFlags ModuleModifiers { get; }
    public bool IsBare => ModuleModifiers.HasFlag(JModuleFlags.Bare);
    public bool GetNameV<T>(JNameRef r, out T t);
    public bool GetName(JNameRef r, out object o) => GetNameV(r, out o);
}

public interface IContextMerger : Reader.IJILVisitor {
    public JStringRef GetNewString(JStringRef str);
    public int GetNewType(int oldType);
    public int GetNewModule(int oldModule);
}

public interface IJExpr {
    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; }
    public IJModule Module => Parent.Module;
    public IJCodeContext Context => Parent.Context;
    public bool VisitVariables(Func<IJField, bool> v);
    public bool VisitNames(Func<IJField, object, bool> v);
    public IJField GetNameField(JNameRef nameRef) => Context.GetNameField(this, nameRef);
    internal IJField GetNameFieldImpl(JNameRef nameRef);
    
    public bool GetNameRef(string name, out JNameRef nameRef) => Context.GetNameRef(this, name, out nameRef);
    internal bool GetNameRefImpl(string name, out JNameRef nameRef);
    public JNameRef GetNameRef(string name) {
        if (GetNameRef(name, out var nameRef))
            return nameRef;
        throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");
    }

    protected internal void UpdateContext(IContextMerger merger){}
}

public interface IJMethod : IJExpr{
    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v);
    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);
}

public interface IJType : IJExpr{
    public string Name { get; }
    public JTypeType Type { get; }
    public bool VisitFields(Func<IJField, bool> v);
    public bool VisitConstructors(Func<IJMethod, bool> v);
}

public interface IJField {
    public string Name { get; }
    public IJType Type { get; }
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; }
    protected internal void UpdateContext(JStringRef[] str2strmap, int typeOffset, int moduleOffset){}
    public bool IsConst => Modifiers.HasFlag(JFieldFlags.Const);

    public bool IsGlobal => Modifiers.HasFlag(JFieldFlags.Global);

    public bool IsLocal => !IsGlobal;
}

public interface IJFunction {
    public string Name { get; }

    public bool VisitMethods(Func<IJMethod, bool> v);
}

public interface IJName : IJField {
    public object ObjectValue { get; set; }
    public JNameRef NameRef { get; }
    IJExpr IJField.Parent => Type.Parent;
}

public interface IJName<T> : IJName
{
    public T Value { get; set; }
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[Flags]
public enum JExprFlags : byte {
    None = 0
}		Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax
[Flags]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
Flags		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
Flags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: byte		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
None = 0		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[Flags]
public enum JMethodFlags : byte {
    None = 0,
    Inline = 1 << 0
}		Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax
[Flags]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
Flags		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
Flags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: byte		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
None = 0		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Inline = 1 << 0		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
= 1 << 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
1 << 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[Flags]
public enum JModuleFlags : byte
{
    None = 0,
    Bare = 1 << 0
}		Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax
[Flags]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
Flags		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
Flags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: byte		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
None = 0		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Bare = 1 << 0		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
= 1 << 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
1 << 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[Flags]
public enum JFieldFlags : byte{
    None = 0,
    Const = 1 << 0,
    Global = 1 << 1,
}		Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax
[Flags]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
Flags		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
Flags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: byte		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
None = 0		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Const = 1 << 0		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
= 1 << 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
1 << 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Global = 1 << 1		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
= 1 << 1		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
1 << 1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public enum JTypeType : byte{
    None,
    Abstract,
    Mutable,
    Struct,
    Primitive
}		Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax
: byte		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Abstract		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Mutable		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Struct		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
Primitive		Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
public interface IJCodeContext {
    public string GetString(JStringRef i);
    public IJModule GetCtxModule(int i);
    public IJType GetCtxType(int i);
    public JStringRef GetStringIndex(string s);
    public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        IJExpr v = e;
        while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
        nameRef = default;
        return false;
    }
    
    public IJField GetNameField(IJExpr e, JNameRef nameRef)  {
        if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
        return e.GetNameFieldImpl(nameRef);
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
public string GetString(JStringRef i);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JStringRef i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JStringRef i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJModule GetCtxModule(int i);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public IJType GetCtxType(int i);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public JStringRef GetStringIndex(string s);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string s)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string s		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public bool GetNameRef(IJExpr e, string name, out JNameRef nameRef) {
        IJExpr v = e;
        while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
        nameRef = default;
        return false;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJExpr e, string name, out JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJExpr e		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        IJExpr v = e;
        while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }
        nameRef = default;
        return false;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
IJExpr v = e;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
IJExpr v = e		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v = e		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= e		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
while (v != null) {
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax
v != null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
            if (GetNameRef(v, name, out nameRef))
                return true;
            v = v.Parent;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (GetNameRef(v, name, out nameRef))
                return true;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
GetNameRef(v, name, out nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(v, name, out nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
v = v.Parent;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
v = v.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
nameRef = default;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
nameRef = default		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
default		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public IJField GetNameField(IJExpr e, JNameRef nameRef)  {
        if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
        return e.GetNameFieldImpl(nameRef);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(IJExpr e, JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJExpr e		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));
        return e.GetNameFieldImpl(nameRef);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (nameRef.CompileTimeExprStackDelta != 0)
            return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
nameRef.CompileTimeExprStackDelta != 0		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
nameRef.CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)));		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
GetNameField(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetNameField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(e.Parent,
                new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1)))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
e.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
e.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
new(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1))		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(nameRef.CompileTimeNameRefIndex, (ushort)(nameRef.CompileTimeExprStackDelta - 1))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ushort)(nameRef.CompileTimeExprStackDelta - 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(ushort)(nameRef.CompileTimeExprStackDelta - 1)		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
ushort		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(nameRef.CompileTimeExprStackDelta - 1)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
nameRef.CompileTimeExprStackDelta - 1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
nameRef.CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return e.GetNameFieldImpl(nameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
e.GetNameFieldImpl(nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
e.GetNameFieldImpl		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
e		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNameFieldImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public interface IJCodeExecutionContext : IJCodeContext{
    public void EnterModule(IJModule m);
    public void ExitModule();
    public void EnterExpr(IJExpr e);
    public void ExitExpr();
    public IJExpr GetExpr(int i);
    public IJModule CurrentModule { get; }
    public IJExpr CurrentExpr { get; }
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
: IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void EnterModule(IJModule m);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJModule m)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJModule m		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void ExitModule();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
public void EnterExpr(IJExpr e);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJExpr e)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJExpr e		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void ExitExpr();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
public IJExpr GetExpr(int i);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public IJModule CurrentModule { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJExpr CurrentExpr { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public interface IJModule : IJExpr
{
    public string Name { get; }
    IJModule IJExpr.Module => this;
    public IJModule ParentModule => Parent.Module;
    public JModuleFlags ModuleModifiers { get; }
    public bool IsBare => ModuleModifiers.HasFlag(JModuleFlags.Bare);
    public bool GetNameV<T>(JNameRef r, out T t);
    public bool GetName(JNameRef r, out object o) => GetNameV(r, out o);
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
: IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public string Name { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
IJModule IJExpr.Module => this;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> this		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public IJModule ParentModule => Parent.Module;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Parent.Module		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Parent.Module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JModuleFlags ModuleModifiers { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JModuleFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public bool IsBare => ModuleModifiers.HasFlag(JModuleFlags.Bare);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> ModuleModifiers.HasFlag(JModuleFlags.Bare)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ModuleModifiers.HasFlag(JModuleFlags.Bare)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ModuleModifiers.HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ModuleModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JModuleFlags.Bare)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JModuleFlags.Bare		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JModuleFlags.Bare		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JModuleFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Bare		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool GetNameV<T>(JNameRef r, out T t);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(JNameRef r, out T t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef r		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out T t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool GetName(JNameRef r, out object o) => GetNameV(r, out o);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JNameRef r, out object o)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef r		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out object o		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> GetNameV(r, out o)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
GetNameV(r, out o)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetNameV		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(r, out o)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
r		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
r		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out o		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
o		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public interface IContextMerger : Reader.IJILVisitor {
    public JStringRef GetNewString(JStringRef str);
    public int GetNewType(int oldType);
    public int GetNewModule(int oldModule);
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
: Reader.IJILVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
Reader.IJILVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
Reader.IJILVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
Reader		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJILVisitor		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JStringRef GetNewString(JStringRef str);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JStringRef str)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JStringRef str		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int GetNewType(int oldType);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int oldType)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int oldType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public int GetNewModule(int oldModule);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int oldModule)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int oldModule		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public interface IJExpr {
    public JExprFlags Modifiers { get; }
    public IJExpr Parent { get; }
    public IJModule Module => Parent.Module;
    public IJCodeContext Context => Parent.Context;
    public bool VisitVariables(Func<IJField, bool> v);
    public bool VisitNames(Func<IJField, object, bool> v);
    public IJField GetNameField(JNameRef nameRef) => Context.GetNameField(this, nameRef);
    internal IJField GetNameFieldImpl(JNameRef nameRef);
    
    public bool GetNameRef(string name, out JNameRef nameRef) => Context.GetNameRef(this, name, out nameRef);
    internal bool GetNameRefImpl(string name, out JNameRef nameRef);
    public JNameRef GetNameRef(string name) {
        if (GetNameRef(name, out var nameRef))
            return nameRef;
        throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");
    }

    protected internal void UpdateContext(IContextMerger merger){}
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
public JExprFlags Modifiers { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJExpr Parent { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJModule Module => Parent.Module;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Parent.Module		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Parent.Module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJCodeContext Context => Parent.Context;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Parent.Context		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Parent.Context		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitVariables(Func<IJField, bool> v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public bool VisitNames(Func<IJField, object, bool> v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, object, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, object, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public IJField GetNameField(JNameRef nameRef) => Context.GetNameField(this, nameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Context.GetNameField(this, nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Context.GetNameField(this, nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Context.GetNameField		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNameField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal IJField GetNameFieldImpl(JNameRef nameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool GetNameRef(string name, out JNameRef nameRef) => Context.GetNameRef(this, name, out nameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(string name, out JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Context.GetNameRef(this, name, out nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Context.GetNameRef(this, name, out nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Context.GetNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this, name, out nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal bool GetNameRefImpl(string name, out JNameRef nameRef);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(string name, out JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JNameRef GetNameRef(string name) {
        if (GetNameRef(name, out var nameRef))
            return nameRef;
        throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        if (GetNameRef(name, out var nameRef))
            return nameRef;
        throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (GetNameRef(name, out var nameRef))
            return nameRef;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
GetNameRef(name, out var nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, out var nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out var nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
var nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
return nameRef;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
throw new JuliaException("Unable to Create Name Reference \"" + name + "\"");		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new JuliaException("Unable to Create Name Reference \"" + name + "\"")		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Unable to Create Name Reference \"" + name + "\"")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Unable to Create Name Reference \"" + name + "\""		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Unable to Create Name Reference \"" + name + "\""		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Unable to Create Name Reference \"" + name		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Unable to Create Name Reference \""		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
"\""		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
protected internal void UpdateContext(IContextMerger merger){}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IContextMerger merger)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IContextMerger merger		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IContextMerger		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public interface IJMethod : IJExpr{
    public JMethodFlags MethodModifiers { get; }
    public bool VisitParameters(Func<IJField, bool> v);
    public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
: IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JMethodFlags MethodModifiers { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JMethodFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public bool VisitParameters(Func<IJField, bool> v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public bool ShouldInline => MethodModifiers.HasFlag(JMethodFlags.Inline);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> MethodModifiers.HasFlag(JMethodFlags.Inline)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
MethodModifiers.HasFlag(JMethodFlags.Inline)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
MethodModifiers.HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JMethodFlags.Inline)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JMethodFlags.Inline		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JMethodFlags.Inline		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JMethodFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Inline		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public interface IJType : IJExpr{
    public string Name { get; }
    public JTypeType Type { get; }
    public bool VisitFields(Func<IJField, bool> v);
    public bool VisitConstructors(Func<IJMethod, bool> v);
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
: IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public string Name { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JTypeType Type { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public bool VisitFields(Func<IJField, bool> v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public bool VisitConstructors(Func<IJMethod, bool> v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJMethod, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJMethod, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public interface IJField {
    public string Name { get; }
    public IJType Type { get; }
    public JFieldFlags Modifiers { get; }
    public IJExpr Parent { get; }
    protected internal void UpdateContext(JStringRef[] str2strmap, int typeOffset, int moduleOffset){}
    public bool IsConst => Modifiers.HasFlag(JFieldFlags.Const);

    public bool IsGlobal => Modifiers.HasFlag(JFieldFlags.Global);

    public bool IsLocal => !IsGlobal;
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
public string Name { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJType Type { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JFieldFlags Modifiers { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JFieldFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJExpr Parent { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
protected internal void UpdateContext(JStringRef[] str2strmap, int typeOffset, int moduleOffset){}		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JStringRef[] str2strmap, int typeOffset, int moduleOffset)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JStringRef[] str2strmap		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JStringRef[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
int typeOffset		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
int moduleOffset		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public bool IsConst => Modifiers.HasFlag(JFieldFlags.Const);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Modifiers.HasFlag(JFieldFlags.Const)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Modifiers.HasFlag(JFieldFlags.Const)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Modifiers.HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JFieldFlags.Const)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JFieldFlags.Const		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JFieldFlags.Const		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JFieldFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool IsGlobal => Modifiers.HasFlag(JFieldFlags.Global);		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Modifiers.HasFlag(JFieldFlags.Global)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Modifiers.HasFlag(JFieldFlags.Global)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Modifiers.HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JFieldFlags.Global)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JFieldFlags.Global		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JFieldFlags.Global		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JFieldFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool IsLocal => !IsGlobal;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> !IsGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
!IsGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
IsGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public interface IJFunction {
    public string Name { get; }

    public bool VisitMethods(Func<IJMethod, bool> v);
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
public string Name { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public bool VisitMethods(Func<IJMethod, bool> v);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJMethod, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJMethod, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
public interface IJName : IJField {
    public object ObjectValue { get; set; }
    public JNameRef NameRef { get; }
    IJExpr IJField.Parent => Type.Parent;
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
: IJField		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public object ObjectValue { get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JNameRef NameRef { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
IJExpr IJField.Parent => Type.Parent;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJField.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Type.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Type.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public interface IJName<T> : IJName
{
    public T Value { get; set; }
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
: IJName		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJName		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public T Value { get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
using System;
using runtime.core.JIL;
using runtime.Utils;

namespace runtime.core.Runtime;

public class JRuntimeContext : JObject, IJCodeContext {

    internal MInternContainer<string> Strings { get; }
    internal IJModule[] Modules;
    internal IJType[] Types;

    public JRuntimeContext(string[] strings, IJModule[] modules, IJType[] types) {
        Strings = new(new(strings));
        Modules = modules;
        Types = types;
    }

    public string GetString(int i) => Strings.Get(i);
    public IJModule GetCtxModule(int i) => Modules[i];
    public IJType GetCtxType(int i) => Types[i];
    public int GetStringIndex(string s) => throw new NotImplementedException();

    public void MergeContext(string[] strings, IJModule[] modules, IJType[] types) {
        lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
    }
    
    
}

internal class JRuntimeMerger : IContextMerger {
    private readonly int[] _s;
    private readonly int _mDelta;
    private readonly int _tyDelta;

    internal JRuntimeMerger(int[] s, int mDelta, int tyDelta) {
        _s = s;
        _mDelta = mDelta;
        _tyDelta = tyDelta;
    }
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => loadedTypeIndex = GetNewType(loadedTypeIndex);

    public JStringRef GetNewString(JStringRef str) => _s[str];
    public int GetNewType(int oldType) => oldType + _tyDelta;
    public int GetNewModule(int oldModule) => oldModule + _mDelta;
}

		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.JIL;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.Utils;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.Utils		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Utils		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core.Runtime;

public class JRuntimeContext : JObject, IJCodeContext {

    internal MInternContainer<string> Strings { get; }
    internal IJModule[] Modules;
    internal IJType[] Types;

    public JRuntimeContext(string[] strings, IJModule[] modules, IJType[] types) {
        Strings = new(new(strings));
        Modules = modules;
        Types = types;
    }

    public string GetString(int i) => Strings.Get(i);
    public IJModule GetCtxModule(int i) => Modules[i];
    public IJType GetCtxType(int i) => Types[i];
    public int GetStringIndex(string s) => throw new NotImplementedException();

    public void MergeContext(string[] strings, IJModule[] modules, IJType[] types) {
        lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
    }
    
    
}

internal class JRuntimeMerger : IContextMerger {
    private readonly int[] _s;
    private readonly int _mDelta;
    private readonly int _tyDelta;

    internal JRuntimeMerger(int[] s, int mDelta, int tyDelta) {
        _s = s;
        _mDelta = mDelta;
        _tyDelta = tyDelta;
    }
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => loadedTypeIndex = GetNewType(loadedTypeIndex);

    public JStringRef GetNewString(JStringRef str) => _s[str];
    public int GetNewType(int oldType) => oldType + _tyDelta;
    public int GetNewModule(int oldModule) => oldModule + _mDelta;
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JRuntimeContext : JObject, IJCodeContext {

    internal MInternContainer<string> Strings { get; }
    internal IJModule[] Modules;
    internal IJType[] Types;

    public JRuntimeContext(string[] strings, IJModule[] modules, IJType[] types) {
        Strings = new(new(strings));
        Modules = modules;
        Types = types;
    }

    public string GetString(int i) => Strings.Get(i);
    public IJModule GetCtxModule(int i) => Modules[i];
    public IJType GetCtxType(int i) => Types[i];
    public int GetStringIndex(string s) => throw new NotImplementedException();

    public void MergeContext(string[] strings, IJModule[] modules, IJType[] types) {
        lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
    }
    
    
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JObject, IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JObject		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JObject		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal MInternContainer<string> Strings { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
MInternContainer<string>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<string>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal IJModule[] Modules;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IJModule[] Modules		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJModule[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Modules		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal IJType[] Types;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
IJType[] Types		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
IJType[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
Types		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public JRuntimeContext(string[] strings, IJModule[] modules, IJType[] types) {
        Strings = new(new(strings));
        Modules = modules;
        Types = types;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(string[] strings, IJModule[] modules, IJType[] types)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string[] strings		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
IJModule[] modules		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJModule[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
IJType[] types		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{
        Strings = new(new(strings));
        Modules = modules;
        Types = types;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Strings = new(new(strings));		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Strings = new(new(strings))		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new(new(strings))		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(new(strings))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
new(strings)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
new(strings)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(strings)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
strings		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modules = modules;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Modules = modules		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Types = types;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Types = types		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public string GetString(int i) => Strings.Get(i);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Strings.Get(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Strings.Get(i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Strings.Get		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Get		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJModule GetCtxModule(int i) => Modules[i];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Modules[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Modules[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJType GetCtxType(int i) => Types[i];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Types[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Types[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int GetStringIndex(string s) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(string s)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string s		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public void MergeContext(string[] strings, IJModule[] modules, IJType[] types) {
        lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(string[] strings, IJModule[] modules, IJType[] types)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string[] strings		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
IJModule[] modules		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJModule[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
IJType[] types		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{
        lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
lock (Strings) {
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax
Strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            JStringRef[] str2strmap = new JStringRef[strings.Length];
            
            for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);

            var oldModLen = Modules.Length;
            Array.Resize(ref Modules, oldModLen + modules.Length);
            modules.CopyTo(Modules, oldModLen);
            
            var oldTyLen = Types.Length;
            Array.Resize(ref Types, oldTyLen + types.Length);
            types.CopyTo(Types, oldTyLen);
            
            Console.WriteLine(this);

            JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);

            foreach (var t in types)
                t.UpdateContext(merger);
            
            foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
JStringRef[] str2strmap = new JStringRef[strings.Length];		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
JStringRef[] str2strmap = new JStringRef[strings.Length]		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JStringRef[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
str2strmap = new JStringRef[strings.Length]		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new JStringRef[strings.Length]		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new JStringRef[strings.Length]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax
JStringRef[strings.Length]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[strings.Length]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
strings.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
for (int i = 0; i < str2strmap.Length; i++) 
                str2strmap[i] = Strings.Load(strings[i]);		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < str2strmap.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
str2strmap.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
str2strmap		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
str2strmap[i] = Strings.Load(strings[i]);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
str2strmap[i] = Strings.Load(strings[i])		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
str2strmap[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
str2strmap		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Strings.Load(strings[i])		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Strings.Load		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Load		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(strings[i])		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
strings[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
strings[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var oldModLen = Modules.Length;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var oldModLen = Modules.Length		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
oldModLen = Modules.Length		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Modules.Length		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Modules.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Array.Resize(ref Modules, oldModLen + modules.Length);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Array.Resize(ref Modules, oldModLen + modules.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Array.Resize		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Resize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ref Modules, oldModLen + modules.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ref Modules		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
oldModLen + modules.Length		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
oldModLen + modules.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
oldModLen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
modules.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
modules.CopyTo(Modules, oldModLen);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
modules.CopyTo(Modules, oldModLen)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
modules.CopyTo		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CopyTo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Modules, oldModLen)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Modules		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
oldModLen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
oldModLen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var oldTyLen = Types.Length;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var oldTyLen = Types.Length		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
oldTyLen = Types.Length		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Types.Length		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Types.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Array.Resize(ref Types, oldTyLen + types.Length);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Array.Resize(ref Types, oldTyLen + types.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Array.Resize		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Array		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Resize		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ref Types, oldTyLen + types.Length)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ref Types		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
oldTyLen + types.Length		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
oldTyLen + types.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
oldTyLen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
types.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
types.CopyTo(Types, oldTyLen);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
types.CopyTo(Types, oldTyLen)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
types.CopyTo		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CopyTo		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Types, oldTyLen)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Types		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
oldTyLen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
oldTyLen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.WriteLine(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Console.WriteLine(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Console.WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
JRuntimeMerger merger = new(str2strmap, oldModLen, oldTyLen)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JRuntimeMerger		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
merger = new(str2strmap, oldModLen, oldTyLen)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(str2strmap, oldModLen, oldTyLen)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(str2strmap, oldModLen, oldTyLen)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(str2strmap, oldModLen, oldTyLen)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
str2strmap		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
str2strmap		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
oldModLen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
oldModLen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
oldTyLen		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
oldTyLen		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
foreach (var t in types)
                t.UpdateContext(merger);		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t.UpdateContext(merger);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
t.UpdateContext(merger)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
t.UpdateContext		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UpdateContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(merger)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
merger		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
merger		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
foreach (var m in modules) {
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                var jm = (JILModule) m;
                m.UpdateContext(merger);
                jm.Ctx = this;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var jm = (JILModule) m;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var jm = (JILModule) m		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jm = (JILModule) m		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= (JILModule) m		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
(JILModule) m		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
JILModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
m.UpdateContext(merger);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
m.UpdateContext(merger)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
m.UpdateContext		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
UpdateContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(merger)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
merger		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
merger		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jm.Ctx = this;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
jm.Ctx = this		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
jm.Ctx		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
jm		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Ctx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
internal class JRuntimeMerger : IContextMerger {
    private readonly int[] _s;
    private readonly int _mDelta;
    private readonly int _tyDelta;

    internal JRuntimeMerger(int[] s, int mDelta, int tyDelta) {
        _s = s;
        _mDelta = mDelta;
        _tyDelta = tyDelta;
    }
    
    public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => loadedTypeIndex = GetNewType(loadedTypeIndex);

    public JStringRef GetNewString(JStringRef str) => _s[str];
    public int GetNewType(int oldType) => oldType + _tyDelta;
    public int GetNewModule(int oldModule) => oldModule + _mDelta;
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: IContextMerger		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IContextMerger		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IContextMerger		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private readonly int[] _s;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int[] _s		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
_s		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private readonly int _mDelta;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int _mDelta		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_mDelta		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private readonly int _tyDelta;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
int _tyDelta		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_tyDelta		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
internal JRuntimeMerger(int[] s, int mDelta, int tyDelta) {
        _s = s;
        _mDelta = mDelta;
        _tyDelta = tyDelta;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(int[] s, int mDelta, int tyDelta)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int[] s		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
int mDelta		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
int tyDelta		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        _s = s;
        _mDelta = mDelta;
        _tyDelta = tyDelta;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_s = s;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_s = s		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_mDelta = mDelta;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_mDelta = mDelta		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_mDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_tyDelta = tyDelta;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_tyDelta = tyDelta		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_tyDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tyDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void VisitLoadTypeImpl(IJType loadedType, ref int loadedTypeIndex) => loadedTypeIndex = GetNewType(loadedTypeIndex);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(IJType loadedType, ref int loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJType loadedType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ref int loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> loadedTypeIndex = GetNewType(loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
loadedTypeIndex = GetNewType(loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetNewType(loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetNewType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(loadedTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
loadedTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JStringRef GetNewString(JStringRef str) => _s[str];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JStringRef str)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JStringRef str		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _s[str]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_s[str]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[str]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
str		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
str		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int GetNewType(int oldType) => oldType + _tyDelta;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int oldType)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int oldType		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> oldType + _tyDelta		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
oldType + _tyDelta		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
oldType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_tyDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int GetNewModule(int oldModule) => oldModule + _mDelta;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int oldModule)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int oldModule		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> oldModule + _mDelta		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
oldModule + _mDelta		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
oldModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_mDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using System.IO;

namespace runtime.core;

public interface IJObject{
    public virtual void Print(TextWriter tw)
    {
        var ty = GetType();
        tw.Write(ty.Name);
        tw.Write("[");
        foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
        tw.Write("]");
    }
    

    public void PrintLn(TextWriter tw) {
        tw ??= new StringWriter();
        Print(tw);
        tw.WriteLine();
    }

    [Obsolete]
    public string ToStringImpl()
    {
        var sw = new StringWriter();
        Print(sw);
        return sw.ToString();
    }
}

public class JObject : IJObject
{
    public override string ToString() => ((IJObject) this).ToStringImpl();
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.IO;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.IO		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IO		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core;

public interface IJObject{
    public virtual void Print(TextWriter tw)
    {
        var ty = GetType();
        tw.Write(ty.Name);
        tw.Write("[");
        foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
        tw.Write("]");
    }
    

    public void PrintLn(TextWriter tw) {
        tw ??= new StringWriter();
        Print(tw);
        tw.WriteLine();
    }

    [Obsolete]
    public string ToStringImpl()
    {
        var sw = new StringWriter();
        Print(sw);
        return sw.ToString();
    }
}

public class JObject : IJObject
{
    public override string ToString() => ((IJObject) this).ToStringImpl();
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public interface IJObject{
    public virtual void Print(TextWriter tw)
    {
        var ty = GetType();
        tw.Write(ty.Name);
        tw.Write("[");
        foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
        tw.Write("]");
    }
    

    public void PrintLn(TextWriter tw) {
        tw ??= new StringWriter();
        Print(tw);
        tw.WriteLine();
    }

    [Obsolete]
    public string ToStringImpl()
    {
        var sw = new StringWriter();
        Print(sw);
        return sw.ToString();
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
public virtual void Print(TextWriter tw)
    {
        var ty = GetType();
        tw.Write(ty.Name);
        tw.Write("[");
        foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
        tw.Write("]");
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(TextWriter tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
TextWriter tw		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        var ty = GetType();
        tw.Write(ty.Name);
        tw.Write("[");
        foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }
        tw.Write("]");
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var ty = GetType();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var ty = GetType()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ty = GetType()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= GetType()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
GetType()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
GetType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
tw.Write(ty.Name);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write(ty.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ty.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ty.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ty.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ty		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw.Write("[");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write("[")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("[")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"["		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"["		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
foreach (var f in ty.GetFields()) {
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ty.GetFields()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ty.GetFields		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ty		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetFields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
{
            if (f.IsStatic) continue;
            tw.Write(f.Name);
            tw.Write("=");
            var o = f.GetValue(this);
            if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (f.IsStatic) continue;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
f.IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsStatic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
continue;		Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax
tw.Write(f.Name);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write(f.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(f.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
f.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw.Write("=");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write("=")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("=")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"="		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"="		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
var o = f.GetValue(this);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var o = f.GetValue(this)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
o = f.GetValue(this)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= f.GetValue(this)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
f.GetValue(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
f.GetValue		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetValue		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
if (o is IJObject j)
                j.Print(tw);
            else 
                tw.Write(o);		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
o is IJObject j		Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax
o		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJObject j		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax
IJObject		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
j		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
j.Print(tw);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
j.Print(tw)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
j.Print		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
j		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else 
                tw.Write(o);		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
tw.Write(o);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write(o)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(o)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
o		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
o		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw.Write("]");		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.Write("]")		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("]")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"]"		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"]"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public void PrintLn(TextWriter tw) {
        tw ??= new StringWriter();
        Print(tw);
        tw.WriteLine();
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(TextWriter tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
TextWriter tw		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
TextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        tw ??= new StringWriter();
        Print(tw);
        tw.WriteLine();
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
tw ??= new StringWriter();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw ??= new StringWriter()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new StringWriter()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
StringWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Print(tw);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Print(tw)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(tw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tw.WriteLine();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
tw.WriteLine()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
tw.WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
[Obsolete]
    public string ToStringImpl()
    {
        var sw = new StringWriter();
        Print(sw);
        return sw.ToString();
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[Obsolete]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
Obsolete		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
Obsolete		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
        var sw = new StringWriter();
        Print(sw);
        return sw.ToString();
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var sw = new StringWriter();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var sw = new StringWriter()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sw = new StringWriter()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new StringWriter()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new StringWriter()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
StringWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Print(sw);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Print(sw)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Print		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(sw)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
sw		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
sw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return sw.ToString();		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
sw.ToString()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
sw.ToString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
sw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public class JObject : IJObject
{
    public override string ToString() => ((IJObject) this).ToStringImpl();
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: IJObject		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJObject		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJObject		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public override string ToString() => ((IJObject) this).ToStringImpl();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> ((IJObject) this).ToStringImpl()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
((IJObject) this).ToStringImpl()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
((IJObject) this).ToStringImpl		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
((IJObject) this)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(IJObject) this		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
IJObject		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
ToStringImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
global using JContextTypeRef = System.Int32;
global using JContextModuleRef = System.Int32;
using System;
using System.Collections.Generic;
using System.Linq;
using runtime.core.Runtime;
using runtime.Utils;

namespace runtime.core.JIL;

public class JILILGenerator : JObject
{
    public readonly UnsafeStream Code = new();

    private void WriteS<T>(byte p, T data) where T : unmanaged
    {
        Code.Write(p);
        Code.Write(data);
    }

    public void InstantiateType(JILTypeBuilder tb) => WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex);

    internal byte[] Create() => Code.ToByteArray();
}

public class JILExprBuilder : JObject, IJExpr
{
    public readonly JILILGenerator Code = new();
    protected JILExpr CreatedExpr;
    protected readonly MInternContainer<string> Namesnames = new();
    protected readonly List<JILFieldBuilder> Names = new();
    protected readonly List<JILFieldBuilder> Vars = new();

    public IJExpr Parent { get; }
    public JExprFlags Modifiers { get; set; }

    internal JILExprBuilder(IJExpr parent) => Parent = parent;

    public JNameRef AddVariable(JILFieldBuilder f)
    {
        var var = AddName(f.Name);
        Vars.Add(f);
        return var;
    }

    public JNameRef AddName(string name, bool isConst = false, bool isGlobal = false)
    {
        JILFieldBuilder fb = new(name, this);
        fb.IsConst = isConst;
        fb.IsGlobal = isGlobal;
        return AddName(fb);
    }

    public JNameRef AddName(JILFieldBuilder fb)
    {
        var idx = Namesnames.GetIndex(fb.Name);
        if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
        //@DUMP("Adding Name:" + fb.Name + " to " + this)
        Names.Add(fb);
        return new(Namesnames.Load(fb.Name), 0);
    }

    public bool VisitVariables(Func<IJField, bool> v) => Vars.Visit(x => v(x));

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        foreach (var t in Names)
            if (!v(t, null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef)
    {
        var nf = Namesnames.GetIndex(name);
        if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }

        nameRef = default;
        return false;
    }

    internal JILExpr Create()
    {
        if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return CreatedExpr;
    }
}

public struct JILFieldBuilder : IJField
{
    public string Name { get; }
    public IJExpr Parent { get; }
    public JFieldFlags Modifiers { get; set; }
    public JNameRef TypeRef { get; internal set; }

    internal JILFieldBuilder(string name, IJExpr parent)
    {
        Name = name;
        Parent = parent;
        Modifiers = JFieldFlags.None;
        TypeRef = default;
    }

    internal JILField Create() => new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null);

    public IJType Type => throw new JuliaException();

    public bool IsConst
    {
        get => Modifiers.HasFlag(JFieldFlags.Const);
        set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);
    }

    public bool IsGlobal
    {
        set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);
    }

    public bool IsLocal
    {
        set => IsGlobal = !value;
    }

    public override int GetHashCode() => Name.GetHashCode();
    public override string ToString() => Name;
}

public sealed class JILMethodBuilder : JILExprBuilder, IJMethod
{
    private readonly List<JILFieldBuilder> _parameters = new();

    public JMethodFlags MethodModifiers { get; set; }

    internal JILMethodBuilder(IJExpr parent) : base(parent) => MethodModifiers = JMethodFlags.None;

    public JNameRef AddParameter(JILFieldBuilder f)
    {
        //@DUMP("(Parameter)")
        _parameters.Add(f);
        return AddName(f.Name);
    }

    internal new JILMethod Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return (JILMethod)CreatedExpr;
    }

    public bool VisitParameters(Func<IJField, bool> v) => _parameters.Visit(x => v(x));
}

public class JILModuleBuilder : JILExprBuilder, IJModule
{
    public readonly JContextModuleRef CtxModuleIndex;

    public string Name { get; }
    public IJCodeContext Context { get; }
    internal JILContextWriter ContextWriter => Context as JILContextWriter;
    public JModuleFlags ModuleModifiers { get; set; }

    IJModule IJModule.ParentModule => Parent.Module;

    public bool IsBare
    {
        set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);
    }

    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotImplementedException();

    public JILTypeBuilder DefineType(string name)
    {
        //@DUMP("(Type) ")
        var tb = new JILTypeBuilder(name, this);
        AddName(name, true);
        return tb;
    }

    public JILMethodBuilder DefineMethod(string name)
    {
        //@DUMP("(Method) ")
        var mb = new JILMethodBuilder(this);
        AddName(name, true);
        return mb;
    }

    public JILModuleBuilder DefineModule(string name)
    {
        //@DUMP("(Module) ")
        var mb = new JILModuleBuilder(name, this, ContextWriter);
        AddName(name, true);
        return mb;
    }

    internal new JILModule Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }

        return CreatedExpr as JILModule;
    }

    bool IJExpr.GetNameRef(string name, out JNameRef nameRef)
    {
        nameRef = AddName(name);
        return true;
    }

    internal JILModuleBuilder(string name, IJModule parent, JILContextWriter cw) : base(parent)
    {
        Name = name;
        Context = cw;
        ModuleModifiers = JModuleFlags.None;
        CtxModuleIndex = ContextWriter.WriteCtxModule(this);
    }
    
    public override string ToString() => Name;
}

public sealed class JILTypeBuilder : IJType
{
    public readonly JContextTypeRef CtxTypeIndex;
    private readonly List<JILFieldBuilder> _fields = new();
    private readonly List<JILMethodBuilder> _constructors = new();
    private JILType _createdType;

    public IJModule Module { get; }
    public IJExpr Parent => Module;
    public string Name { get; }
    public JTypeType Type { get; set; }

    internal JILTypeBuilder(string name, IJModule parent)
    {
        Name = name;
        CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);
        Type = JTypeType.None;
        Module = parent;
    }

    internal JILContextWriter ContextWriter => Parent.Context as JILContextWriter;

    public bool VisitFields(Func<IJField, bool> v) => _fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.Visit(x => v(x));

    public JNameRef AddField(JILFieldBuilder f)
    {
        var idx = _fields.Count;
        _fields.Add(f);
        return new(idx, 0);
    }

    public JNameRef AddConstructor(JILMethodBuilder c)
    {
        var idx = _constructors.Count;
        _constructors.Add(c);
        return new(-idx, 0);
    }

    internal JILType Create()
    {
        if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }

        return _createdType;
    }

    public JExprFlags Modifiers => JExprFlags.None;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => _fields[nameRef.CompileTimeExprStackDelta];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public override string ToString() => Name;
}

internal class JILContextWriter : JObject, IJCodeContext
{
    public JRuntimeModule ParentModule { get; }
    private readonly MInternContainer<string> _strings = new();
    private readonly List<JILModuleBuilder> _modules = new();
    private readonly List<JILTypeBuilder> _types = new();

    internal JILContextWriter(JRuntimeModule parentModule) => ParentModule = parentModule;

    public JStringRef WriteString(string s) => _strings.Load(s);

    public int WriteCtxModule(JILModuleBuilder mb)
    {
        var midx = _modules.Count;
        _modules.Add(mb);
        return midx;
    }

    public JContextTypeRef WriteCtxType(JILTypeBuilder tb)
    {
        var tidx = _types.Count;
        _types.Add(tb);
        return tidx;
    }

    public void CreateContext(out string[] strings, out IJModule[] modules, out IJType[] types) {
        //@DUMP("Creating Context:" + this)
        modules = _modules.Select(x => (IJModule)x.Create()).ToArray();
        types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();
        strings = _strings.Data.ToArray();
    }

    public string GetString(int i) => _strings.Get(i);
    public IJModule GetCtxModule(int i) => _modules[i];
    public IJType GetCtxType(int i) => _types[i];
    public int GetStringIndex(string s) => _strings.GetIndex(s);
}

public class JILBuilder : JILModuleBuilder {
    public JILBuilder(JRuntimeModule m) : base(m.Name, m, new JILContextWriter(m)) {}

    public JRuntimeExpr CreateExpression() {
        //@DUMP("Generating Runtime Expr:" + this)
        var expr = Create();
        (Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);
        (Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);
        return new JRuntimeExpr(expr, Parent);
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
global using JContextTypeRef = System.Int32;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
JContextTypeRef =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
JContextTypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
System.Int32		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
global using JContextModuleRef = System.Int32;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
JContextModuleRef =		Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax
JContextModuleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
System.Int32		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Int32		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Collections.Generic;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Collections.Generic		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Collections		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Collections		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Generic		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Linq;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Linq		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Linq		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.core.Runtime;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.core.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using runtime.Utils;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
runtime.Utils		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Utils		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core.JIL;

public class JILILGenerator : JObject
{
    public readonly UnsafeStream Code = new();

    private void WriteS<T>(byte p, T data) where T : unmanaged
    {
        Code.Write(p);
        Code.Write(data);
    }

    public void InstantiateType(JILTypeBuilder tb) => WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex);

    internal byte[] Create() => Code.ToByteArray();
}

public class JILExprBuilder : JObject, IJExpr
{
    public readonly JILILGenerator Code = new();
    protected JILExpr CreatedExpr;
    protected readonly MInternContainer<string> Namesnames = new();
    protected readonly List<JILFieldBuilder> Names = new();
    protected readonly List<JILFieldBuilder> Vars = new();

    public IJExpr Parent { get; }
    public JExprFlags Modifiers { get; set; }

    internal JILExprBuilder(IJExpr parent) => Parent = parent;

    public JNameRef AddVariable(JILFieldBuilder f)
    {
        var var = AddName(f.Name);
        Vars.Add(f);
        return var;
    }

    public JNameRef AddName(string name, bool isConst = false, bool isGlobal = false)
    {
        JILFieldBuilder fb = new(name, this);
        fb.IsConst = isConst;
        fb.IsGlobal = isGlobal;
        return AddName(fb);
    }

    public JNameRef AddName(JILFieldBuilder fb)
    {
        var idx = Namesnames.GetIndex(fb.Name);
        if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
        //@DUMP("Adding Name:" + fb.Name + " to " + this)
        Names.Add(fb);
        return new(Namesnames.Load(fb.Name), 0);
    }

    public bool VisitVariables(Func<IJField, bool> v) => Vars.Visit(x => v(x));

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        foreach (var t in Names)
            if (!v(t, null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef)
    {
        var nf = Namesnames.GetIndex(name);
        if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }

        nameRef = default;
        return false;
    }

    internal JILExpr Create()
    {
        if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return CreatedExpr;
    }
}

public struct JILFieldBuilder : IJField
{
    public string Name { get; }
    public IJExpr Parent { get; }
    public JFieldFlags Modifiers { get; set; }
    public JNameRef TypeRef { get; internal set; }

    internal JILFieldBuilder(string name, IJExpr parent)
    {
        Name = name;
        Parent = parent;
        Modifiers = JFieldFlags.None;
        TypeRef = default;
    }

    internal JILField Create() => new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null);

    public IJType Type => throw new JuliaException();

    public bool IsConst
    {
        get => Modifiers.HasFlag(JFieldFlags.Const);
        set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);
    }

    public bool IsGlobal
    {
        set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);
    }

    public bool IsLocal
    {
        set => IsGlobal = !value;
    }

    public override int GetHashCode() => Name.GetHashCode();
    public override string ToString() => Name;
}

public sealed class JILMethodBuilder : JILExprBuilder, IJMethod
{
    private readonly List<JILFieldBuilder> _parameters = new();

    public JMethodFlags MethodModifiers { get; set; }

    internal JILMethodBuilder(IJExpr parent) : base(parent) => MethodModifiers = JMethodFlags.None;

    public JNameRef AddParameter(JILFieldBuilder f)
    {
        //@DUMP("(Parameter)")
        _parameters.Add(f);
        return AddName(f.Name);
    }

    internal new JILMethod Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return (JILMethod)CreatedExpr;
    }

    public bool VisitParameters(Func<IJField, bool> v) => _parameters.Visit(x => v(x));
}

public class JILModuleBuilder : JILExprBuilder, IJModule
{
    public readonly JContextModuleRef CtxModuleIndex;

    public string Name { get; }
    public IJCodeContext Context { get; }
    internal JILContextWriter ContextWriter => Context as JILContextWriter;
    public JModuleFlags ModuleModifiers { get; set; }

    IJModule IJModule.ParentModule => Parent.Module;

    public bool IsBare
    {
        set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);
    }

    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotImplementedException();

    public JILTypeBuilder DefineType(string name)
    {
        //@DUMP("(Type) ")
        var tb = new JILTypeBuilder(name, this);
        AddName(name, true);
        return tb;
    }

    public JILMethodBuilder DefineMethod(string name)
    {
        //@DUMP("(Method) ")
        var mb = new JILMethodBuilder(this);
        AddName(name, true);
        return mb;
    }

    public JILModuleBuilder DefineModule(string name)
    {
        //@DUMP("(Module) ")
        var mb = new JILModuleBuilder(name, this, ContextWriter);
        AddName(name, true);
        return mb;
    }

    internal new JILModule Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }

        return CreatedExpr as JILModule;
    }

    bool IJExpr.GetNameRef(string name, out JNameRef nameRef)
    {
        nameRef = AddName(name);
        return true;
    }

    internal JILModuleBuilder(string name, IJModule parent, JILContextWriter cw) : base(parent)
    {
        Name = name;
        Context = cw;
        ModuleModifiers = JModuleFlags.None;
        CtxModuleIndex = ContextWriter.WriteCtxModule(this);
    }
    
    public override string ToString() => Name;
}

public sealed class JILTypeBuilder : IJType
{
    public readonly JContextTypeRef CtxTypeIndex;
    private readonly List<JILFieldBuilder> _fields = new();
    private readonly List<JILMethodBuilder> _constructors = new();
    private JILType _createdType;

    public IJModule Module { get; }
    public IJExpr Parent => Module;
    public string Name { get; }
    public JTypeType Type { get; set; }

    internal JILTypeBuilder(string name, IJModule parent)
    {
        Name = name;
        CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);
        Type = JTypeType.None;
        Module = parent;
    }

    internal JILContextWriter ContextWriter => Parent.Context as JILContextWriter;

    public bool VisitFields(Func<IJField, bool> v) => _fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.Visit(x => v(x));

    public JNameRef AddField(JILFieldBuilder f)
    {
        var idx = _fields.Count;
        _fields.Add(f);
        return new(idx, 0);
    }

    public JNameRef AddConstructor(JILMethodBuilder c)
    {
        var idx = _constructors.Count;
        _constructors.Add(c);
        return new(-idx, 0);
    }

    internal JILType Create()
    {
        if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }

        return _createdType;
    }

    public JExprFlags Modifiers => JExprFlags.None;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => _fields[nameRef.CompileTimeExprStackDelta];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public override string ToString() => Name;
}

internal class JILContextWriter : JObject, IJCodeContext
{
    public JRuntimeModule ParentModule { get; }
    private readonly MInternContainer<string> _strings = new();
    private readonly List<JILModuleBuilder> _modules = new();
    private readonly List<JILTypeBuilder> _types = new();

    internal JILContextWriter(JRuntimeModule parentModule) => ParentModule = parentModule;

    public JStringRef WriteString(string s) => _strings.Load(s);

    public int WriteCtxModule(JILModuleBuilder mb)
    {
        var midx = _modules.Count;
        _modules.Add(mb);
        return midx;
    }

    public JContextTypeRef WriteCtxType(JILTypeBuilder tb)
    {
        var tidx = _types.Count;
        _types.Add(tb);
        return tidx;
    }

    public void CreateContext(out string[] strings, out IJModule[] modules, out IJType[] types) {
        //@DUMP("Creating Context:" + this)
        modules = _modules.Select(x => (IJModule)x.Create()).ToArray();
        types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();
        strings = _strings.Data.ToArray();
    }

    public string GetString(int i) => _strings.Get(i);
    public IJModule GetCtxModule(int i) => _modules[i];
    public IJType GetCtxType(int i) => _types[i];
    public int GetStringIndex(string s) => _strings.GetIndex(s);
}

public class JILBuilder : JILModuleBuilder {
    public JILBuilder(JRuntimeModule m) : base(m.Name, m, new JILContextWriter(m)) {}

    public JRuntimeExpr CreateExpression() {
        //@DUMP("Generating Runtime Expr:" + this)
        var expr = Create();
        (Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);
        (Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);
        return new JRuntimeExpr(expr, Parent);
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax
runtime.core.JIL		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JIL		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JILILGenerator : JObject
{
    public readonly UnsafeStream Code = new();

    private void WriteS<T>(byte p, T data) where T : unmanaged
    {
        Code.Write(p);
        Code.Write(data);
    }

    public void InstantiateType(JILTypeBuilder tb) => WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex);

    internal byte[] Create() => Code.ToByteArray();
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JObject		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JObject		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JObject		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public readonly UnsafeStream Code = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
UnsafeStream Code = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
UnsafeStream		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Code = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
private void WriteS<T>(byte p, T data) where T : unmanaged
    {
        Code.Write(p);
        Code.Write(data);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(byte p, T data)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
byte p		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
T data		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
where T : unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        Code.Write(p);
        Code.Write(data);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Code.Write(p);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Code.Write(p)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Code.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(p)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
p		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Code.Write(data);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Code.Write(data)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Code.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(data)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
data		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void InstantiateType(JILTypeBuilder tb) => WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JILTypeBuilder tb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILTypeBuilder tb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILTypeBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
WriteS(JOp.LoadTypeOp, tb.CtxTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
WriteS		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JOp.LoadTypeOp, tb.CtxTypeIndex)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JOp.LoadTypeOp		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JOp.LoadTypeOp		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
LoadTypeOp		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tb.CtxTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tb.CtxTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
tb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CtxTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal byte[] Create() => Code.ToByteArray();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
byte[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Code.ToByteArray()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Code.ToByteArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Code.ToByteArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToByteArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public class JILExprBuilder : JObject, IJExpr
{
    public readonly JILILGenerator Code = new();
    protected JILExpr CreatedExpr;
    protected readonly MInternContainer<string> Namesnames = new();
    protected readonly List<JILFieldBuilder> Names = new();
    protected readonly List<JILFieldBuilder> Vars = new();

    public IJExpr Parent { get; }
    public JExprFlags Modifiers { get; set; }

    internal JILExprBuilder(IJExpr parent) => Parent = parent;

    public JNameRef AddVariable(JILFieldBuilder f)
    {
        var var = AddName(f.Name);
        Vars.Add(f);
        return var;
    }

    public JNameRef AddName(string name, bool isConst = false, bool isGlobal = false)
    {
        JILFieldBuilder fb = new(name, this);
        fb.IsConst = isConst;
        fb.IsGlobal = isGlobal;
        return AddName(fb);
    }

    public JNameRef AddName(JILFieldBuilder fb)
    {
        var idx = Namesnames.GetIndex(fb.Name);
        if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
        //@DUMP("Adding Name:" + fb.Name + " to " + this)
        Names.Add(fb);
        return new(Namesnames.Load(fb.Name), 0);
    }

    public bool VisitVariables(Func<IJField, bool> v) => Vars.Visit(x => v(x));

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        foreach (var t in Names)
            if (!v(t, null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];

    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef)
    {
        var nf = Namesnames.GetIndex(name);
        if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }

        nameRef = default;
        return false;
    }

    internal JILExpr Create()
    {
        if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return CreatedExpr;
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JObject, IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JObject		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JObject		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public readonly JILILGenerator Code = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JILILGenerator Code = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILILGenerator		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Code = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
protected JILExpr CreatedExpr;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JILExpr CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
protected readonly MInternContainer<string> Namesnames = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
MInternContainer<string> Namesnames = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
MInternContainer<string>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<string>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
Namesnames = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
protected readonly List<JILFieldBuilder> Names = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<JILFieldBuilder> Names = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<JILFieldBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<JILFieldBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
JILFieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Names = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
protected readonly List<JILFieldBuilder> Vars = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<JILFieldBuilder> Vars = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<JILFieldBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<JILFieldBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
JILFieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Vars = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public IJExpr Parent { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JExprFlags Modifiers { get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal JILExprBuilder(IJExpr parent) => Parent = parent;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(IJExpr parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJExpr parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Parent = parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Parent = parent		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JNameRef AddVariable(JILFieldBuilder f)
    {
        var var = AddName(f.Name);
        Vars.Add(f);
        return var;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JILFieldBuilder f)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILFieldBuilder f		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILFieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        var var = AddName(f.Name);
        Vars.Add(f);
        return var;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var var = AddName(f.Name);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var var = AddName(f.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
var = AddName(f.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= AddName(f.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
AddName(f.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
AddName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(f.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
f.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Vars.Add(f);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Vars.Add(f)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Vars.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Vars		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(f)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return var;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JNameRef AddName(string name, bool isConst = false, bool isGlobal = false)
    {
        JILFieldBuilder fb = new(name, this);
        fb.IsConst = isConst;
        fb.IsGlobal = isGlobal;
        return AddName(fb);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name, bool isConst = false, bool isGlobal = false)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
bool isConst = false		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= false		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
bool isGlobal = false		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
= false		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
        JILFieldBuilder fb = new(name, this);
        fb.IsConst = isConst;
        fb.IsGlobal = isGlobal;
        return AddName(fb);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
JILFieldBuilder fb = new(name, this);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
JILFieldBuilder fb = new(name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILFieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
fb = new(name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new(name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new(name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
fb.IsConst = isConst;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
fb.IsConst = isConst		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
fb.IsConst		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsConst		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
isConst		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
fb.IsGlobal = isGlobal;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
fb.IsGlobal = isGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
fb.IsGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
isGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return AddName(fb);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
AddName(fb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
AddName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JNameRef AddName(JILFieldBuilder fb)
    {
        var idx = Namesnames.GetIndex(fb.Name);
        if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
        //@DUMP("Adding Name:" + fb.Name + " to " + this)
        Names.Add(fb);
        return new(Namesnames.Load(fb.Name), 0);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JILFieldBuilder fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILFieldBuilder fb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILFieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        var idx = Namesnames.GetIndex(fb.Name);
        if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }
        //@DUMP("Adding Name:" + fb.Name + " to " + this)
        Names.Add(fb);
        return new(Namesnames.Load(fb.Name), 0);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var idx = Namesnames.GetIndex(fb.Name);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var idx = Namesnames.GetIndex(fb.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx = Namesnames.GetIndex(fb.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Namesnames.GetIndex(fb.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Namesnames.GetIndex(fb.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Namesnames.GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Namesnames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(fb.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
fb.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
fb.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (idx != -1) {
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
idx != -1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
            if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (Names[idx].IsConst)
                throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
Names[idx].IsConst		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Names[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[idx]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IsConst		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
throw new JuliaException("Cannot redefine constant \"" + fb.Name + "\"");		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax
new JuliaException("Cannot redefine constant \"" + fb.Name + "\"")		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Cannot redefine constant \"" + fb.Name + "\"")		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
"Cannot redefine constant \"" + fb.Name + "\""		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
"Cannot redefine constant \"" + fb.Name + "\""		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Cannot redefine constant \"" + fb.Name		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
"Cannot redefine constant \""		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
fb.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
"\""		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
Names.Add(fb);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Names.Add(fb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Names.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(fb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return new(Namesnames.Load(fb.Name), 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
new(Namesnames.Load(fb.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(Namesnames.Load(fb.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Namesnames.Load(fb.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Namesnames.Load(fb.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Namesnames.Load		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Namesnames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Load		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(fb.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
fb.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
fb.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
fb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public bool VisitVariables(Func<IJField, bool> v) => Vars.Visit(x => v(x));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Vars.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Vars.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Vars.Visit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Vars		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Visit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitNames(Func<IJField, object, bool> v)
    {
        foreach (var t in Names)
            if (!v(t, null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, object, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, object, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        foreach (var t in Names)
            if (!v(t, null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
foreach (var t in Names)
            if (!v(t, null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (!v(t, null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!v(t, null)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
v(t, null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => Names[nameRef.CompileTimeNameRefIndex];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Names[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Names[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[nameRef.CompileTimeNameRefIndex]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef.CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeNameRefIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef)
    {
        var nf = Namesnames.GetIndex(name);
        if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }

        nameRef = default;
        return false;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name, out JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        var nf = Namesnames.GetIndex(name);
        if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }

        nameRef = default;
        return false;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var nf = Namesnames.GetIndex(name);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var nf = Namesnames.GetIndex(name)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
nf = Namesnames.GetIndex(name)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Namesnames.GetIndex(name)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Namesnames.GetIndex(name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Namesnames.GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Namesnames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (nf != -1)
        {
            nameRef = new(nf, 0);
            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
nf != -1		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
nf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
-1		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
1		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
            nameRef = new(nf, 0);
            return true;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
nameRef = new(nf, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
nameRef = new(nf, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new(nf, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(nf, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
nf		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nf		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
nameRef = default;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
nameRef = default		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
default		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
internal JILExpr Create()
    {
        if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return CreatedExpr;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JILExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
        if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return CreatedExpr;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (CreatedExpr == null)
        {
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
CreatedExpr == null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
            //@DUMP("Generating Expression:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new(Modifiers, code, vt, names, null);
            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var code = Code.Create();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var code = Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
code = Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Code.Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
var names = Names.Select(x => x.Create()).ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var names = Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names = Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Names.Select(x => x.Create()).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Names.Select(x => x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Names.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
x.Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Vars.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Vars		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Namesnames.GetIndex(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Namesnames.GetIndex(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Namesnames.GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Namesnames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
CreatedExpr = new(Modifiers, code, vt, names, null);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
CreatedExpr = new(Modifiers, code, vt, names, null)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new(Modifiers, code, vt, names, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(Modifiers, code, vt, names, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
vt		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
vt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names[i].Parent = CreatedExpr;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
names[i].Parent = CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
names[i].Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
names[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return CreatedExpr;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public struct JILFieldBuilder : IJField
{
    public string Name { get; }
    public IJExpr Parent { get; }
    public JFieldFlags Modifiers { get; set; }
    public JNameRef TypeRef { get; internal set; }

    internal JILFieldBuilder(string name, IJExpr parent)
    {
        Name = name;
        Parent = parent;
        Modifiers = JFieldFlags.None;
        TypeRef = default;
    }

    internal JILField Create() => new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null);

    public IJType Type => throw new JuliaException();

    public bool IsConst
    {
        get => Modifiers.HasFlag(JFieldFlags.Const);
        set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);
    }

    public bool IsGlobal
    {
        set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);
    }

    public bool IsLocal
    {
        set => IsGlobal = !value;
    }

    public override int GetHashCode() => Name.GetHashCode();
    public override string ToString() => Name;
}		Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
: IJField		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public string Name { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJExpr Parent { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JFieldFlags Modifiers { get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JFieldFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JNameRef TypeRef { get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; internal set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal JILFieldBuilder(string name, IJExpr parent)
    {
        Name = name;
        Parent = parent;
        Modifiers = JFieldFlags.None;
        TypeRef = default;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(string name, IJExpr parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJExpr parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        Name = name;
        Parent = parent;
        Modifiers = JFieldFlags.None;
        TypeRef = default;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Name = name;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Name = name		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent = parent;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Parent = parent		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modifiers = JFieldFlags.None;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Modifiers = JFieldFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JFieldFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JFieldFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeRef = default;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
TypeRef = default		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
TypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
default		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
internal JILField Create() => new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JILField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
new((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
((Parent.Context as JILContextWriter).WriteString(Name), Modifiers, TypeRef, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
(Parent.Context as JILContextWriter).WriteString(Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
(Parent.Context as JILContextWriter).WriteString(Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
(Parent.Context as JILContextWriter).WriteString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
(Parent.Context as JILContextWriter)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
Parent.Context as JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Parent.Context		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
TypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
TypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public IJType Type => throw new JuliaException();		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new JuliaException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new JuliaException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new JuliaException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JuliaException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public bool IsConst
    {
        get => Modifiers.HasFlag(JFieldFlags.Const);
        set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        get => Modifiers.HasFlag(JFieldFlags.Const);
        set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get => Modifiers.HasFlag(JFieldFlags.Const);		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
=> Modifiers.HasFlag(JFieldFlags.Const)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Modifiers.HasFlag(JFieldFlags.Const)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Modifiers.HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
HasFlag		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JFieldFlags.Const)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JFieldFlags.Const		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JFieldFlags.Const		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JFieldFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
set => Modifiers = Modifiers.Set(JFieldFlags.Const, value);		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
=> Modifiers = Modifiers.Set(JFieldFlags.Const, value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Modifiers = Modifiers.Set(JFieldFlags.Const, value)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modifiers.Set(JFieldFlags.Const, value)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Modifiers.Set		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Set		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JFieldFlags.Const, value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JFieldFlags.Const		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JFieldFlags.Const		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JFieldFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Const		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool IsGlobal
    {
        set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
set => Modifiers = Modifiers.Set(JFieldFlags.Global, value);		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
=> Modifiers = Modifiers.Set(JFieldFlags.Global, value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Modifiers = Modifiers.Set(JFieldFlags.Global, value)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modifiers.Set(JFieldFlags.Global, value)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Modifiers.Set		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Set		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JFieldFlags.Global, value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JFieldFlags.Global		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JFieldFlags.Global		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JFieldFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Global		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool IsLocal
    {
        set => IsGlobal = !value;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        set => IsGlobal = !value;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
set => IsGlobal = !value;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
=> IsGlobal = !value		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
IsGlobal = !value		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
IsGlobal		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
!value		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public override int GetHashCode() => Name.GetHashCode();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Name.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Name.GetHashCode()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Name.GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetHashCode		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public override string ToString() => Name;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public sealed class JILMethodBuilder : JILExprBuilder, IJMethod
{
    private readonly List<JILFieldBuilder> _parameters = new();

    public JMethodFlags MethodModifiers { get; set; }

    internal JILMethodBuilder(IJExpr parent) : base(parent) => MethodModifiers = JMethodFlags.None;

    public JNameRef AddParameter(JILFieldBuilder f)
    {
        //@DUMP("(Parameter)")
        _parameters.Add(f);
        return AddName(f.Name);
    }

    internal new JILMethod Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return (JILMethod)CreatedExpr;
    }

    public bool VisitParameters(Func<IJField, bool> v) => _parameters.Visit(x => v(x));
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JILExprBuilder, IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JILExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JILExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
private readonly List<JILFieldBuilder> _parameters = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<JILFieldBuilder> _parameters = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<JILFieldBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<JILFieldBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
JILFieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_parameters = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public JMethodFlags MethodModifiers { get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JMethodFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal JILMethodBuilder(IJExpr parent) : base(parent) => MethodModifiers = JMethodFlags.None;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(IJExpr parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
IJExpr parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: base(parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> MethodModifiers = JMethodFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
MethodModifiers = JMethodFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
MethodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JMethodFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JMethodFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JNameRef AddParameter(JILFieldBuilder f)
    {
        //@DUMP("(Parameter)")
        _parameters.Add(f);
        return AddName(f.Name);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JILFieldBuilder f)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILFieldBuilder f		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILFieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        //@DUMP("(Parameter)")
        _parameters.Add(f);
        return AddName(f.Name);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
_parameters.Add(f);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_parameters.Add(f)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_parameters.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(f)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return AddName(f.Name);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
AddName(f.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
AddName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(f.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
f.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal new JILMethod Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return (JILMethod)CreatedExpr;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JILMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
        if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }

        return (JILMethod)CreatedExpr;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (CreatedExpr == null) {
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
CreatedExpr == null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
            //@DUMP("Generating Method:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);

            for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var code = Code.Create();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var code = Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
code = Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Code.Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
var names = Names.Select(x => x.Create()).ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var names = Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names = Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Names.Select(x => x.Create()).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Names.Select(x => x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Names.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
x.Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Vars.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Vars		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Namesnames.GetIndex(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Namesnames.GetIndex(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Namesnames.GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Namesnames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
pt = _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= _parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
_parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_parameters.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_parameters.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Namesnames.GetIndex(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Namesnames.GetIndex(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Namesnames.GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Namesnames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
CreatedExpr = new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new JILMethod(MethodModifiers, pt, Modifiers, code, vt, names, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JILMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(MethodModifiers, pt, Modifiers, code, vt, names, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
MethodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
MethodModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
pt		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
pt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
vt		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
vt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
for (int i = 0; i < names.Length; i++)
                names[i].Parent = CreatedExpr;		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names[i].Parent = CreatedExpr;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
names[i].Parent = CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
names[i].Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
names[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return (JILMethod)CreatedExpr;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
(JILMethod)CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
JILMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitParameters(Func<IJField, bool> v) => _parameters.Visit(x => v(x));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _parameters.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_parameters.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_parameters.Visit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_parameters		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Visit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JILModuleBuilder : JILExprBuilder, IJModule
{
    public readonly JContextModuleRef CtxModuleIndex;

    public string Name { get; }
    public IJCodeContext Context { get; }
    internal JILContextWriter ContextWriter => Context as JILContextWriter;
    public JModuleFlags ModuleModifiers { get; set; }

    IJModule IJModule.ParentModule => Parent.Module;

    public bool IsBare
    {
        set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);
    }

    public bool GetNameV<T>(JNameRef r, out T t) => throw new NotImplementedException();

    public JILTypeBuilder DefineType(string name)
    {
        //@DUMP("(Type) ")
        var tb = new JILTypeBuilder(name, this);
        AddName(name, true);
        return tb;
    }

    public JILMethodBuilder DefineMethod(string name)
    {
        //@DUMP("(Method) ")
        var mb = new JILMethodBuilder(this);
        AddName(name, true);
        return mb;
    }

    public JILModuleBuilder DefineModule(string name)
    {
        //@DUMP("(Module) ")
        var mb = new JILModuleBuilder(name, this, ContextWriter);
        AddName(name, true);
        return mb;
    }

    internal new JILModule Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }

        return CreatedExpr as JILModule;
    }

    bool IJExpr.GetNameRef(string name, out JNameRef nameRef)
    {
        nameRef = AddName(name);
        return true;
    }

    internal JILModuleBuilder(string name, IJModule parent, JILContextWriter cw) : base(parent)
    {
        Name = name;
        Context = cw;
        ModuleModifiers = JModuleFlags.None;
        CtxModuleIndex = ContextWriter.WriteCtxModule(this);
    }
    
    public override string ToString() => Name;
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JILExprBuilder, IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JILExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JILExprBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public readonly JContextModuleRef CtxModuleIndex;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JContextModuleRef CtxModuleIndex		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JContextModuleRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CtxModuleIndex		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public string Name { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJCodeContext Context { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal JILContextWriter ContextWriter => Context as JILContextWriter;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Context as JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Context as JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JModuleFlags ModuleModifiers { get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JModuleFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
IJModule IJModule.ParentModule => Parent.Module;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJModule.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Parent.Module		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Parent.Module		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool IsBare
    {
        set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
set => ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value);		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
=> ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ModuleModifiers = ModuleModifiers.Set(JModuleFlags.Bare, value)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
ModuleModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleModifiers.Set(JModuleFlags.Bare, value)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ModuleModifiers.Set		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ModuleModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Set		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JModuleFlags.Bare, value)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
JModuleFlags.Bare		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
JModuleFlags.Bare		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JModuleFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Bare		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
value		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool GetNameV<T>(JNameRef r, out T t) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(JNameRef r, out T t)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef r		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
out T t		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public JILTypeBuilder DefineType(string name)
    {
        //@DUMP("(Type) ")
        var tb = new JILTypeBuilder(name, this);
        AddName(name, true);
        return tb;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JILTypeBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        //@DUMP("(Type) ")
        var tb = new JILTypeBuilder(name, this);
        AddName(name, true);
        return tb;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var tb = new JILTypeBuilder(name, this);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var tb = new JILTypeBuilder(name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tb = new JILTypeBuilder(name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new JILTypeBuilder(name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new JILTypeBuilder(name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JILTypeBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
AddName(name, true);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
AddName(name, true)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
AddName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, true)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return tb;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
tb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JILMethodBuilder DefineMethod(string name)
    {
        //@DUMP("(Method) ")
        var mb = new JILMethodBuilder(this);
        AddName(name, true);
        return mb;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JILMethodBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        //@DUMP("(Method) ")
        var mb = new JILMethodBuilder(this);
        AddName(name, true);
        return mb;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var mb = new JILMethodBuilder(this);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var mb = new JILMethodBuilder(this)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mb = new JILMethodBuilder(this)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new JILMethodBuilder(this)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new JILMethodBuilder(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JILMethodBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
AddName(name, true);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
AddName(name, true)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
AddName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, true)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return mb;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
mb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JILModuleBuilder DefineModule(string name)
    {
        //@DUMP("(Module) ")
        var mb = new JILModuleBuilder(name, this, ContextWriter);
        AddName(name, true);
        return mb;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JILModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        //@DUMP("(Module) ")
        var mb = new JILModuleBuilder(name, this, ContextWriter);
        AddName(name, true);
        return mb;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var mb = new JILModuleBuilder(name, this, ContextWriter);		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var mb = new JILModuleBuilder(name, this, ContextWriter)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
mb = new JILModuleBuilder(name, this, ContextWriter)		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new JILModuleBuilder(name, this, ContextWriter)		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new JILModuleBuilder(name, this, ContextWriter)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JILModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, this, ContextWriter)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
ContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AddName(name, true);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
AddName(name, true)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
AddName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name, true)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return mb;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
mb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal new JILModule Create()
    {
        if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }

        return CreatedExpr as JILModule;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JILModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
        if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }

        return CreatedExpr as JILModule;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (CreatedExpr == null) {
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
CreatedExpr == null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
            //@DUMP("Generating Module:" + this)
            var code = Code.Create();
            var names = Names.Select(x => x.Create()).ToArray();
            var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();
            CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);
            var parentModule = this is JILBuilder ? Parent : CreatedExpr;

            for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var code = Code.Create();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var code = Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
code = Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Code.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Code.Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
var names = Names.Select(x => x.Create()).ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var names = Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names = Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Names.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Names.Select(x => x.Create()).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Names.Select(x => x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Names.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
x.Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
vt = Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0)).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Vars.Select(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Vars.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Vars		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => new JNameRef(Namesnames.GetIndex(x.Name), 0))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
new JNameRef(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Namesnames.GetIndex(x.Name), 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Namesnames.GetIndex(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Namesnames.GetIndex(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Namesnames.GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Namesnames		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x.Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
CreatedExpr = new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new JILModule(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JILModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(ContextWriter.WriteString(Name), ModuleModifiers, Modifiers, code, vt, names,
                null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ContextWriter.WriteString(Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ContextWriter.WriteString(Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ContextWriter.WriteString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ModuleModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Modifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
code		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
vt		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
vt		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
var parentModule = this is JILBuilder ? Parent : CreatedExpr;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var parentModule = this is JILBuilder ? Parent : CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parentModule = this is JILBuilder ? Parent : CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= this is JILBuilder ? Parent : CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
this is JILBuilder ? Parent : CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax
this is JILBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
JILBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
for (int i = 0; i < names.Length; i++)
            {
                names[i].Parent = parentModule;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
names.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
                names[i].Parent = parentModule;
            }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
names[i].Parent = parentModule;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
names[i].Parent = parentModule		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
names[i].Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
names[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
names		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parentModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return CreatedExpr as JILModule;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
CreatedExpr as JILModule		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
CreatedExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool IJExpr.GetNameRef(string name, out JNameRef nameRef)
    {
        nameRef = AddName(name);
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name, out JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        nameRef = AddName(name);
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
nameRef = AddName(name);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
nameRef = AddName(name)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AddName(name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
AddName		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
internal JILModuleBuilder(string name, IJModule parent, JILContextWriter cw) : base(parent)
    {
        Name = name;
        Context = cw;
        ModuleModifiers = JModuleFlags.None;
        CtxModuleIndex = ContextWriter.WriteCtxModule(this);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(string name, IJModule parent, JILContextWriter cw)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJModule parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILContextWriter cw		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: base(parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        Name = name;
        Context = cw;
        ModuleModifiers = JModuleFlags.None;
        CtxModuleIndex = ContextWriter.WriteCtxModule(this);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Name = name;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Name = name		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Context = cw;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Context = cw		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
cw		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ModuleModifiers = JModuleFlags.None;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ModuleModifiers = JModuleFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
ModuleModifiers		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JModuleFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JModuleFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CtxModuleIndex = ContextWriter.WriteCtxModule(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
CtxModuleIndex = ContextWriter.WriteCtxModule(this)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
CtxModuleIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ContextWriter.WriteCtxModule(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ContextWriter.WriteCtxModule		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteCtxModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
public override string ToString() => Name;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public sealed class JILTypeBuilder : IJType
{
    public readonly JContextTypeRef CtxTypeIndex;
    private readonly List<JILFieldBuilder> _fields = new();
    private readonly List<JILMethodBuilder> _constructors = new();
    private JILType _createdType;

    public IJModule Module { get; }
    public IJExpr Parent => Module;
    public string Name { get; }
    public JTypeType Type { get; set; }

    internal JILTypeBuilder(string name, IJModule parent)
    {
        Name = name;
        CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);
        Type = JTypeType.None;
        Module = parent;
    }

    internal JILContextWriter ContextWriter => Parent.Context as JILContextWriter;

    public bool VisitFields(Func<IJField, bool> v) => _fields.Visit(x => v(x));
    public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.Visit(x => v(x));

    public JNameRef AddField(JILFieldBuilder f)
    {
        var idx = _fields.Count;
        _fields.Add(f);
        return new(idx, 0);
    }

    public JNameRef AddConstructor(JILMethodBuilder c)
    {
        var idx = _constructors.Count;
        _constructors.Add(c);
        return new(-idx, 0);
    }

    internal JILType Create()
    {
        if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }

        return _createdType;
    }

    public JExprFlags Modifiers => JExprFlags.None;
    public bool VisitVariables(Func<IJField, bool> v) => true;

    public bool VisitNames(Func<IJField, object, bool> v)
    {
        for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;
        return true;
    }

    IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => _fields[nameRef.CompileTimeExprStackDelta];
    bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();
    public override string ToString() => Name;
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: IJType		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public readonly JContextTypeRef CtxTypeIndex;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JContextTypeRef CtxTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JContextTypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CtxTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
private readonly List<JILFieldBuilder> _fields = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<JILFieldBuilder> _fields = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<JILFieldBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<JILFieldBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
JILFieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_fields = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
private readonly List<JILMethodBuilder> _constructors = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<JILMethodBuilder> _constructors = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<JILMethodBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<JILMethodBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
JILMethodBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_constructors = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
private JILType _createdType;		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
JILType _createdType		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
JILType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_createdType		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
public IJModule Module { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public IJExpr Parent => Module;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Module		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public string Name { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
public JTypeType Type { get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; set; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
set;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
internal JILTypeBuilder(string name, IJModule parent)
    {
        Name = name;
        CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);
        Type = JTypeType.None;
        Module = parent;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(string name, IJModule parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJModule parent		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        Name = name;
        CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);
        Type = JTypeType.None;
        Module = parent;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Name = name;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Name = name		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
CtxTypeIndex = ((JILContextWriter)parent.Context).WriteCtxType(this)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
CtxTypeIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
((JILContextWriter)parent.Context).WriteCtxType(this)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
((JILContextWriter)parent.Context).WriteCtxType		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
((JILContextWriter)parent.Context)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
(JILContextWriter)parent.Context		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent.Context		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteCtxType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(this)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
this		Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax
Type = JTypeType.None;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Type = JTypeType.None		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JTypeType.None		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JTypeType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Module = parent;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Module = parent		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
Module		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal JILContextWriter ContextWriter => Parent.Context as JILContextWriter;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> Parent.Context as JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Parent.Context as JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Parent.Context		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitFields(Func<IJField, bool> v) => _fields.Visit(x => v(x));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _fields.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_fields.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_fields.Visit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Visit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitConstructors(Func<IJMethod, bool> v) => _constructors.Visit(x => v(x));		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJMethod, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJMethod, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJMethod, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJMethod		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _constructors.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_constructors.Visit(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_constructors.Visit		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_constructors		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Visit		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => v(x))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
v(x)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JNameRef AddField(JILFieldBuilder f)
    {
        var idx = _fields.Count;
        _fields.Add(f);
        return new(idx, 0);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JILFieldBuilder f)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILFieldBuilder f		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILFieldBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        var idx = _fields.Count;
        _fields.Add(f);
        return new(idx, 0);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var idx = _fields.Count;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var idx = _fields.Count		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx = _fields.Count		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= _fields.Count		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
_fields.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_fields.Add(f);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_fields.Add(f)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_fields.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(f)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
f		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return new(idx, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
new(idx, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(idx, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public JNameRef AddConstructor(JILMethodBuilder c)
    {
        var idx = _constructors.Count;
        _constructors.Add(c);
        return new(-idx, 0);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JILMethodBuilder c)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILMethodBuilder c		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILMethodBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        var idx = _constructors.Count;
        _constructors.Add(c);
        return new(-idx, 0);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var idx = _constructors.Count;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var idx = _constructors.Count		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
idx = _constructors.Count		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= _constructors.Count		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
_constructors.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_constructors		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_constructors.Add(c);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_constructors.Add(c)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_constructors.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_constructors		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(c)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
c		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
c		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return new(-idx, 0);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
new(-idx, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(-idx, 0)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
-idx		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
-idx		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
idx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
internal JILType Create()
    {
        if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }

        return _createdType;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JILType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
        if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }

        return _createdType;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
if (_createdType == null) {
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
_createdType == null		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
_createdType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
{
            //@DUMP("Generating Type:" + this)
            var farr = _fields.Select(x => x.Create()).ToArray();
            var carr = _constructors.Select(x => x.Create()).ToArray();
            _createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);

            for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;

            foreach (var t in carr)
                t.Parent = _createdType;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var farr = _fields.Select(x => x.Create()).ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var farr = _fields.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
farr = _fields.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= _fields.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
_fields.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_fields.Select(x => x.Create()).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_fields.Select(x => x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_fields.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
x.Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
var carr = _constructors.Select(x => x.Create()).ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var carr = _constructors.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
carr = _constructors.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= _constructors.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
_constructors.Select(x => x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_constructors.Select(x => x.Create()).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_constructors.Select(x => x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_constructors.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_constructors		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
x.Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_createdType = new(ContextWriter.WriteString(Name), Type, farr, carr, null)		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
_createdType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new(ContextWriter.WriteString(Name), Type, farr, carr, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
(ContextWriter.WriteString(Name), Type, farr, carr, null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ContextWriter.WriteString(Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
ContextWriter.WriteString(Name)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
ContextWriter.WriteString		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteString		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(Name)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Type		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
farr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
farr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
carr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
carr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
for (int i = 0; i < farr.Length; i++)
                farr[i].Parent = _createdType;		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < farr.Length		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
farr.Length		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
farr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Length		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
farr[i].Parent = _createdType;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
farr[i].Parent = _createdType		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
farr[i].Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
farr[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
farr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_createdType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
foreach (var t in carr)
                t.Parent = _createdType;		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
carr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
t.Parent = _createdType;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
t.Parent = _createdType		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
t.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_createdType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return _createdType;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
_createdType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JExprFlags Modifiers => JExprFlags.None;		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> JExprFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
JExprFlags.None		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
JExprFlags		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
None		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public bool VisitVariables(Func<IJField, bool> v) => true;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> true		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
public bool VisitNames(Func<IJField, object, bool> v)
    {
        for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(Func<IJField, object, bool> v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
Func<IJField, object, bool> v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
Func<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<IJField, object, bool>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
{
        for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;
        return true;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
for (int i = 0; i < _fields.Count; i++)
            if (!v(_fields[i], null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax
int i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
i = 0		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= 0		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
0		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
i < _fields.Count		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_fields.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
i++		Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
if (!v(_fields[i], null))
                return false;		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
!v(_fields[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
v(_fields[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(_fields[i], null)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
_fields[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
_fields[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
null		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return false;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
false		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
return true;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
true		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
IJField IJExpr.GetNameFieldImpl(JNameRef nameRef) => _fields[nameRef.CompileTimeExprStackDelta];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJField		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> _fields[nameRef.CompileTimeExprStackDelta]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_fields[nameRef.CompileTimeExprStackDelta]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_fields		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[nameRef.CompileTimeExprStackDelta]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
nameRef.CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
nameRef.CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompileTimeExprStackDelta		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
bool IJExpr.GetNameRefImpl(string name, out JNameRef nameRef) => throw new NotImplementedException();		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
bool		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
IJExpr.		Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax
IJExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string name, out JNameRef nameRef)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string name		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out JNameRef nameRef		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JNameRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
throw new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax
new NotImplementedException()		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
NotImplementedException		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public override string ToString() => Name;		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
=> Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
internal class JILContextWriter : JObject, IJCodeContext
{
    public JRuntimeModule ParentModule { get; }
    private readonly MInternContainer<string> _strings = new();
    private readonly List<JILModuleBuilder> _modules = new();
    private readonly List<JILTypeBuilder> _types = new();

    internal JILContextWriter(JRuntimeModule parentModule) => ParentModule = parentModule;

    public JStringRef WriteString(string s) => _strings.Load(s);

    public int WriteCtxModule(JILModuleBuilder mb)
    {
        var midx = _modules.Count;
        _modules.Add(mb);
        return midx;
    }

    public JContextTypeRef WriteCtxType(JILTypeBuilder tb)
    {
        var tidx = _types.Count;
        _types.Add(tb);
        return tidx;
    }

    public void CreateContext(out string[] strings, out IJModule[] modules, out IJType[] types) {
        //@DUMP("Creating Context:" + this)
        modules = _modules.Select(x => (IJModule)x.Create()).ToArray();
        types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();
        strings = _strings.Data.ToArray();
    }

    public string GetString(int i) => _strings.Get(i);
    public IJModule GetCtxModule(int i) => _modules[i];
    public IJType GetCtxType(int i) => _types[i];
    public int GetStringIndex(string s) => _strings.GetIndex(s);
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JObject, IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JObject		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JObject		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
IJCodeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JRuntimeModule ParentModule { get; }		Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
JRuntimeModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{ get; }		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax
get;		Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
private readonly MInternContainer<string> _strings = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
MInternContainer<string> _strings = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
MInternContainer<string>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<string>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
_strings = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
private readonly List<JILModuleBuilder> _modules = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<JILModuleBuilder> _modules = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<JILModuleBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<JILModuleBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
JILModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_modules = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
private readonly List<JILTypeBuilder> _types = new();		Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax
List<JILTypeBuilder> _types = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
List<JILTypeBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax
<JILTypeBuilder>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax
JILTypeBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_types = new()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= new()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
new()		Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
internal JILContextWriter(JRuntimeModule parentModule) => ParentModule = parentModule;		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JRuntimeModule parentModule)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JRuntimeModule parentModule		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JRuntimeModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
=> ParentModule = parentModule		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
ParentModule = parentModule		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
ParentModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
parentModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JStringRef WriteString(string s) => _strings.Load(s);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JStringRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(string s)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string s		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _strings.Load(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_strings.Load(s)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_strings.Load		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Load		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int WriteCtxModule(JILModuleBuilder mb)
    {
        var midx = _modules.Count;
        _modules.Add(mb);
        return midx;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(JILModuleBuilder mb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILModuleBuilder mb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        var midx = _modules.Count;
        _modules.Add(mb);
        return midx;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var midx = _modules.Count;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var midx = _modules.Count		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
midx = _modules.Count		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= _modules.Count		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
_modules.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_modules.Add(mb);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_modules.Add(mb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_modules.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(mb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
mb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
mb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return midx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
midx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JContextTypeRef WriteCtxType(JILTypeBuilder tb)
    {
        var tidx = _types.Count;
        _types.Add(tb);
        return tidx;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JContextTypeRef		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(JILTypeBuilder tb)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JILTypeBuilder tb		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JILTypeBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
        var tidx = _types.Count;
        _types.Add(tb);
        return tidx;
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var tidx = _types.Count;		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var tidx = _types.Count		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
tidx = _types.Count		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= _types.Count		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
_types.Count		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Count		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_types.Add(tb);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
_types.Add(tb)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_types.Add		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Add		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(tb)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
tb		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
tb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return tidx;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
tidx		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public void CreateContext(out string[] strings, out IJModule[] modules, out IJType[] types) {
        //@DUMP("Creating Context:" + this)
        modules = _modules.Select(x => (IJModule)x.Create()).ToArray();
        types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();
        strings = _strings.Data.ToArray();
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(out string[] strings, out IJModule[] modules, out IJType[] types)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
out string[] strings		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
out IJModule[] modules		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJModule[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
out IJType[] types		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
IJType[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{
        //@DUMP("Creating Context:" + this)
        modules = _modules.Select(x => (IJModule)x.Create()).ToArray();
        types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();
        strings = _strings.Data.ToArray();
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
modules = _modules.Select(x => (IJModule)x.Create()).ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
modules = _modules.Select(x => (IJModule)x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_modules.Select(x => (IJModule)x.Create()).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_modules.Select(x => (IJModule)x.Create()).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_modules.Select(x => (IJModule)x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_modules.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x => (IJModule)x.Create())		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x => (IJModule)x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x => (IJModule)x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
(IJModule)x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
x.Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
types = _types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }).ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_types.Select(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        })		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_types.Select		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Select		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        })		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
x =>
        {
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
{
            var ty = x.Create();

            if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();

            return (IJType)ty;
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var ty = x.Create();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var ty = x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ty = x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
x.Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
x.Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
if (x.Parent is JILBuilder jb)
                ty.Parent = jb.Parent;
            else ty.Parent = (x.Parent as JILModuleBuilder).Create();		Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax
x.Parent is JILBuilder jb		Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax
x.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILBuilder jb		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax
JILBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jb		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
ty.Parent = jb.Parent;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ty.Parent = jb.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
ty.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ty		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
jb.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
jb		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
else ty.Parent = (x.Parent as JILModuleBuilder).Create();		Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax
ty.Parent = (x.Parent as JILModuleBuilder).Create();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
ty.Parent = (x.Parent as JILModuleBuilder).Create()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
ty.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
ty		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(x.Parent as JILModuleBuilder).Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
(x.Parent as JILModuleBuilder).Create		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
(x.Parent as JILModuleBuilder)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
x.Parent as JILModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
x.Parent		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
x		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
return (IJType)ty;		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
(IJType)ty		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ty		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
strings = _strings.Data.ToArray();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
strings = _strings.Data.ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
_strings.Data.ToArray()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_strings.Data.ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_strings.Data		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Data		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
ToArray		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public string GetString(int i) => _strings.Get(i);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _strings.Get(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_strings.Get(i)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_strings.Get		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Get		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(i)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJModule GetCtxModule(int i) => _modules[i];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _modules[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_modules[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public IJType GetCtxType(int i) => _types[i];		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
IJType		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(int i)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
int i		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _types[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_types[i]		Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax
_types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[i]		Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
i		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public int GetStringIndex(string s) => _strings.GetIndex(s);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
int		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(string s)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
string s		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
string		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> _strings.GetIndex(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
_strings.GetIndex(s)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
_strings.GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
_strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
GetIndex		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(s)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
s		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class JILBuilder : JILModuleBuilder {
    public JILBuilder(JRuntimeModule m) : base(m.Name, m, new JILContextWriter(m)) {}

    public JRuntimeExpr CreateExpression() {
        //@DUMP("Generating Runtime Expr:" + this)
        var expr = Create();
        (Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);
        (Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);
        return new JRuntimeExpr(expr, Parent);
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
: JILModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax
JILModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax
JILModuleBuilder		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public JILBuilder(JRuntimeModule m) : base(m.Name, m, new JILContextWriter(m)) {}		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax
(JRuntimeModule m)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
JRuntimeModule m		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
JRuntimeModule		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
: base(m.Name, m, new JILContextWriter(m))		Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
(m.Name, m, new JILContextWriter(m))		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
m.Name		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
m.Name		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Name		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
new JILContextWriter(m)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
new JILContextWriter(m)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(m)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
m		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{}		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
public JRuntimeExpr CreateExpression() {
        //@DUMP("Generating Runtime Expr:" + this)
        var expr = Create();
        (Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);
        (Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);
        return new JRuntimeExpr(expr, Parent);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
JRuntimeExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
{
        //@DUMP("Generating Runtime Expr:" + this)
        var expr = Create();
        (Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);
        (Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);
        return new JRuntimeExpr(expr, Parent);
    }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
var expr = Create();		Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax
var expr = Create()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
expr = Create()		Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
= Create()		Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Create()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Create		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
(Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
(Context as JILContextWriter).CreateContext(out var strings, out var modules, out var types)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
(Context as JILContextWriter).CreateContext		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
(Context as JILContextWriter)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
Context as JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JILContextWriter		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CreateContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(out var strings, out var modules, out var types)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
out var strings		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
var strings		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
strings		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
out var modules		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
var modules		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
modules		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
out var types		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
var types		Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax
(Parent.Context as JRuntimeContext).MergeContext(strings, modules, types);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
(Parent.Context as JRuntimeContext).MergeContext(strings, modules, types)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
(Parent.Context as JRuntimeContext).MergeContext		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
(Parent.Context as JRuntimeContext)		Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax
Parent.Context as JRuntimeContext		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
Parent.Context		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Context		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
JRuntimeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
MergeContext		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(strings, modules, types)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
strings		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
strings		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
modules		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
modules		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
types		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return new JRuntimeExpr(expr, Parent);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
new JRuntimeExpr(expr, Parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax
JRuntimeExpr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(expr, Parent)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
expr		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
expr		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
Parent		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace runtime.core {
    public class IO {

        public static void STOUTPrint(object o) => Console.Write(o);
        public static void STOUTPrintLn(object o) => Console.WriteLine(o);

        public static void PrintLn(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
            Console.WriteLine();
        }
        
        public static void Print(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeWrite<T>(void* destination, T v) where T: unmanaged{
            Unsafe.Write(destination, v);
            return (byte*) destination + sizeof(T);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeRead<T>(void* source, out T v) where T: unmanaged {
            v = *(T*) source;
            return (byte*) source + sizeof(T);
        }
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Runtime.CompilerServices;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Runtime.CompilerServices		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
CompilerServices		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Runtime.InteropServices;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Runtime.InteropServices		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
InteropServices		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
namespace runtime.core {
    public class IO {

        public static void STOUTPrint(object o) => Console.Write(o);
        public static void STOUTPrintLn(object o) => Console.WriteLine(o);

        public static void PrintLn(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
            Console.WriteLine();
        }
        
        public static void Print(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeWrite<T>(void* destination, T v) where T: unmanaged{
            Unsafe.Write(destination, v);
            return (byte*) destination + sizeof(T);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeRead<T>(void* source, out T v) where T: unmanaged {
            v = *(T*) source;
            return (byte*) source + sizeof(T);
        }
    }
}		Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
runtime.core		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
runtime		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
core		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public class IO {

        public static void STOUTPrint(object o) => Console.Write(o);
        public static void STOUTPrintLn(object o) => Console.WriteLine(o);

        public static void PrintLn(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
            Console.WriteLine();
        }
        
        public static void Print(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeWrite<T>(void* destination, T v) where T: unmanaged{
            Unsafe.Write(destination, v);
            return (byte*) destination + sizeof(T);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeRead<T>(void* source, out T v) where T: unmanaged {
            v = *(T*) source;
            return (byte*) source + sizeof(T);
        }
    }		Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
public static void STOUTPrint(object o) => Console.Write(o);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(object o)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
object o		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Console.Write(o)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Console.Write(o)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Console.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(o)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
o		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
o		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static void STOUTPrintLn(object o) => Console.WriteLine(o);		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(object o)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
object o		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
=> Console.WriteLine(o)		Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
Console.WriteLine(o)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Console.WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(o)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
o		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
o		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
public static void PrintLn(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
            Console.WriteLine();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(params object[] v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
params object[] v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
object[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{
            foreach(var t in v)
                Console.Write(t);
            Console.WriteLine();
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
foreach(var t in v)
                Console.Write(t);		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.Write(t);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Console.Write(t)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Console.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.WriteLine();		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Console.WriteLine()		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Console.WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
WriteLine		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
()		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
public static void Print(params object[] v) {
            foreach(var t in v)
                Console.Write(t);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
(params object[] v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
params object[] v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
object[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax
object		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
[]		Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax
		Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax
{
            foreach(var t in v)
                Console.Write(t);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
foreach(var t in v)
                Console.Write(t);		Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
var		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Console.Write(t);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Console.Write(t)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Console.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Console		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(t)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
t		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeWrite<T>(void* destination, T v) where T: unmanaged{
            Unsafe.Write(destination, v);
            return (byte*) destination + sizeof(T);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
MethodImpl(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
MethodImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodImplOptions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(void* destination, T v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
void* destination		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
void*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
T v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
where T: unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            Unsafe.Write(destination, v);
            return (byte*) destination + sizeof(T);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
Unsafe.Write(destination, v);		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
Unsafe.Write(destination, v)		Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax
Unsafe.Write		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
Unsafe		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Write		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(destination, v)		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax
destination		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
destination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return (byte*) destination + sizeof(T);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
(byte*) destination + sizeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(byte*) destination		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
destination		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sizeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void* UnsafeRead<T>(void* source, out T v) where T: unmanaged {
            v = *(T*) source;
            return (byte*) source + sizeof(T);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax
[MethodImpl(MethodImplOptions.AggressiveInlining)]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
MethodImpl(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
MethodImpl		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
(MethodImplOptions.AggressiveInlining)		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
MethodImplOptions.AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax
MethodImplOptions		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AggressiveInlining		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
void*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
<T>		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
(void* source, out T v)		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax
void* source		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
void*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
void		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
out T v		Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
where T: unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax
unmanaged		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
{
            v = *(T*) source;
            return (byte*) source + sizeof(T);
        }		Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax
v = *(T*) source;		Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax
v = *(T*) source		Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax
v		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
*(T*) source		Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax
(T*) source		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
T*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
source		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
return (byte*) source + sizeof(T);		Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax
(byte*) source + sizeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax
(byte*) source		Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax
byte*		Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax
byte		Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax
source		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
sizeof(T)		Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax
T		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("runtime")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("runtime")]
[assembly: System.Reflection.AssemblyTitleAttribute("runtime")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

		Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
using System;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
using System.Reflection;		Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
[assembly: System.Reflection.AssemblyCompanyAttribute("runtime")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
assembly:		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax
System.Reflection.AssemblyCompanyAttribute("runtime")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Reflection.AssemblyCompanyAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AssemblyCompanyAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("runtime")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"runtime"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"runtime"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
assembly:		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax
System.Reflection.AssemblyConfigurationAttribute("Debug")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Reflection.AssemblyConfigurationAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AssemblyConfigurationAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("Debug")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"Debug"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"Debug"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
assembly:		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax
System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Reflection.AssemblyFileVersionAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AssemblyFileVersionAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("1.0.0.0")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"1.0.0.0"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"1.0.0.0"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
assembly:		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax
System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Reflection.AssemblyInformationalVersionAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AssemblyInformationalVersionAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("1.0.0")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"1.0.0"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"1.0.0"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[assembly: System.Reflection.AssemblyProductAttribute("runtime")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
assembly:		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax
System.Reflection.AssemblyProductAttribute("runtime")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Reflection.AssemblyProductAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AssemblyProductAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("runtime")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"runtime"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"runtime"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[assembly: System.Reflection.AssemblyTitleAttribute("runtime")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
assembly:		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax
System.Reflection.AssemblyTitleAttribute("runtime")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Reflection.AssemblyTitleAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
AssemblyTitleAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
("runtime")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax
"runtime"		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax
"runtime"		Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax
assembly:		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax
System.Reflection.AssemblyVersionAttribute("1.0.0.0")		Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
System.Reflection.AssemblyVersionAttribute		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System.Reflection		Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax
System		Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
Reflection	